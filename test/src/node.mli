[@@@ocaml.warning "-7-11-32-33-39"]
[@@@js.implem 
  [@@@ocaml.warning "-7-11-32-33-39"]
]
open Ts2ocaml
open Ts2ocaml.Dom
module Internal : sig
  module AnonymousInterfaces : sig
    type anonymous_interface_0 = [`anonymous_interface_0] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_1 = [`anonymous_interface_1] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_2 = [`anonymous_interface_2] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_3 = [`anonymous_interface_3] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_4 = [`anonymous_interface_4] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_5 = [`anonymous_interface_5] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_6 = [`anonymous_interface_6] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_7 = [`anonymous_interface_7] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_8 = [`anonymous_interface_8] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_9 = [`anonymous_interface_9] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_10 = [`anonymous_interface_10] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_11 = [`anonymous_interface_11] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_12 = [`anonymous_interface_12] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_13 = [`anonymous_interface_13] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_14 = [`anonymous_interface_14] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_15 = [`anonymous_interface_15] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_16 = [`anonymous_interface_16] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_17 = [`anonymous_interface_17] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_18 = [`anonymous_interface_18] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_19 = [`anonymous_interface_19] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_20 = [`anonymous_interface_20] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_21 = [`anonymous_interface_21] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_22 = [`anonymous_interface_22] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_23 = [`anonymous_interface_23] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_24 = [`anonymous_interface_24] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_25 = [`anonymous_interface_25] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_26 = [`anonymous_interface_26] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_27 = [`anonymous_interface_27] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_28 = [`anonymous_interface_28] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_29 = [`anonymous_interface_29] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_30 = [`anonymous_interface_30] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_31 = [`anonymous_interface_31] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_32 = [`anonymous_interface_32] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_33 = [`anonymous_interface_33] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_34 = [`anonymous_interface_34] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_35 = [`anonymous_interface_35] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_36 = [`anonymous_interface_36] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_37 = [`anonymous_interface_37] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_38 = [`anonymous_interface_38] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_39 = [`anonymous_interface_39] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_40 = [`anonymous_interface_40] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_41 = [`anonymous_interface_41] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_42 = [`anonymous_interface_42] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_43 = [`anonymous_interface_43] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_44 = [`anonymous_interface_44] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_45 = [`anonymous_interface_45] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_46 = [`anonymous_interface_46] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_47 = [`anonymous_interface_47] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_48 = [`anonymous_interface_48] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_49 = [`anonymous_interface_49] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_50 = [`anonymous_interface_50] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_51 = [`anonymous_interface_51] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_52 = [`anonymous_interface_52] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_53 = [`anonymous_interface_53] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_54 = [`anonymous_interface_54] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_55 = [`anonymous_interface_55] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_56 = [`anonymous_interface_56] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_57 = [`anonymous_interface_57] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_58 = [`anonymous_interface_58] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_59 = [`anonymous_interface_59] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_60 = [`anonymous_interface_60] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_61 = [`anonymous_interface_61] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_62 = [`anonymous_interface_62] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_63 = [`anonymous_interface_63] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_64 = [`anonymous_interface_64] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_65 = [`anonymous_interface_65] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_66 = [`anonymous_interface_66] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_67 = [`anonymous_interface_67] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_68 = [`anonymous_interface_68] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_69 = [`anonymous_interface_69] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_70 = [`anonymous_interface_70] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_71 = [`anonymous_interface_71] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_72 = [`anonymous_interface_72] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_73 = [`anonymous_interface_73] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_74 = [`anonymous_interface_74] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    type anonymous_interface_75 = [`anonymous_interface_75] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  end
  module Types : sig
    open AnonymousInterfaces
    type _Buffer = [`Buffer | Uint8Array.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _BufferEncoding = ([`L_s179_ascii[@js "ascii"] | `L_s181_base64[@js "base64"] | `L_s182_base64url[@js "base64url"] | `L_s185_binary[@js "binary"] | `L_s226_hex[@js "hex"] | `L_s242_latin1[@js "latin1"] | `L_s315_ucs_2[@js "ucs-2"] | `L_s316_ucs2[@js "ucs2"] | `L_s327_utf_8[@js "utf-8"] | `L_s328_utf16le[@js "utf16le"] | `L_s329_utf8[@js "utf8"]] [@js.enum])
    and _ErrorConstructor = [`ErrorConstructor] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _ImportMeta = [`ImportMeta] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_ArrayBufferView = (DataView.t_0, _NodeJS_TypedArray) union2
    and _NodeJS_CallSite = [`NodeJS_CallSite] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T _NodeJS_Dict = [`NodeJS_Dict of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and _NodeJS_ErrnoException = [`NodeJS_ErrnoException | Error.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_Global = [`NodeJS_Global] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_Immediate = [`NodeJS_Immediate | `NodeJS_RefCounted] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_InspectOptions = [`NodeJS_InspectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_Module = [`NodeJS_Module] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T _NodeJS_ReadOnlyDict = [`NodeJS_ReadOnlyDict of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and _NodeJS_ReadWriteStream = [`NodeJS_ReadWriteStream | `NodeJS_ReadableStream | `NodeJS_WritableStream | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_ReadableStream = [`NodeJS_ReadableStream | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_RefCounted = [`NodeJS_RefCounted] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_Require = [`NodeJS_Require] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_RequireExtensions = [`NodeJS_Dict of m:_NodeJS_Module -> filename:string -> any | `NodeJS_RequireExtensions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_RequireResolve = [`NodeJS_RequireResolve] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_Timeout = [`NodeJS_RefCounted | `NodeJS_Timeout | `NodeJS_Timer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_Timer = [`NodeJS_RefCounted | `NodeJS_Timer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeJS_TypedArray = ((((Float64Array.t_0, Int16Array.t_0, Int32Array.t_0, Int8Array.t_0, Uint16Array.t_0, Uint32Array.t_0, Uint8Array.t_0, Uint8ClampedArray.t_0) union8, Float32Array.t_0) or_, BigUint64Array.t_0) or_, BigInt64Array.t_0) or_
    and _NodeJS_WritableStream = [`NodeJS_WritableStream | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeModule = [`NodeJS_Module | `NodeModule] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _NodeRequire = [`NodeJS_Require | `NodeRequire] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _RequireResolve = [`NodeJS_RequireResolve | `RequireResolve] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and _String = [`String] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T _WithImplicitCoercion = ('T, anonymous_interface_65) union2
    and assert_assert_AssertPredicate = (Error.t_0, regexp, untyped_object, anonymous_interface_70, (thrown:any -> bool)) union5
    and assert_assert_AssertionError = [`Assert_assert_AssertionError | Error.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and assert_assert_CallTracker = [`Assert_assert_CallTracker] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and assert_assert_CallTrackerReportInformation = [`Assert_assert_CallTrackerReportInformation] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and async_hooks_AsyncHook = [`Async_hooks_AsyncHook] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T async_hooks_AsyncLocalStorage = [`Async_hooks_AsyncLocalStorage of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and async_hooks_AsyncResource = [`Async_hooks_AsyncResource] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and async_hooks_AsyncResourceOptions = [`Async_hooks_AsyncResourceOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and async_hooks_HookCallbacks = [`Async_hooks_HookCallbacks] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and buffer_TranscodeEncoding = ([`L_s179_ascii[@js "ascii"] | `L_s185_binary[@js "binary"] | `L_s242_latin1[@js "latin1"] | `L_s316_ucs2[@js "ucs2"] | `L_s328_utf16le[@js "utf16le"] | `L_s329_utf8[@js "utf8"]] [@js.enum])
    and child_process_ChildProcess = [`Child_process_ChildProcess | `Events_EventEmitter | NodeJS.EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('I, 'O, 'E) child_process_ChildProcessByStdio = [`Child_process_ChildProcess | `Child_process_ChildProcessByStdio of ('I * 'O * 'E) | `Events_EventEmitter | NodeJS.EventEmitter.tags] intf
    [@@js.custom { of_js=(fun _I _O _E -> Obj.magic); to_js=(fun _I _O _E -> Obj.magic) }]
    and child_process_ChildProcessWithoutNullStreams = [`Child_process_ChildProcess | `Child_process_ChildProcessWithoutNullStreams | `Events_EventEmitter | NodeJS.EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_CommonOptions = [`Child_process_CommonOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_CommonSpawnOptions = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecException = [`Child_process_ExecException | Error.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileException = (child_process_ExecException, _NodeJS_ErrnoException) intersection2
    and child_process_ExecFileOptions = [`Child_process_CommonOptions | `Child_process_ExecFileOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileOptionsWithBufferEncoding = [`Child_process_CommonOptions | `Child_process_ExecFileOptions | `Child_process_ExecFileOptionsWithBufferEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileOptionsWithOtherEncoding = [`Child_process_CommonOptions | `Child_process_ExecFileOptions | `Child_process_ExecFileOptionsWithOtherEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileOptionsWithStringEncoding = [`Child_process_CommonOptions | `Child_process_ExecFileOptions | `Child_process_ExecFileOptionsWithStringEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileSyncOptions = [`Child_process_CommonOptions | `Child_process_ExecFileSyncOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileSyncOptionsWithBufferEncoding = [`Child_process_CommonOptions | `Child_process_ExecFileSyncOptions | `Child_process_ExecFileSyncOptionsWithBufferEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecFileSyncOptionsWithStringEncoding = [`Child_process_CommonOptions | `Child_process_ExecFileSyncOptions | `Child_process_ExecFileSyncOptionsWithStringEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecOptions = [`Child_process_CommonOptions | `Child_process_ExecOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecOptionsWithBufferEncoding = [`Child_process_CommonOptions | `Child_process_ExecOptions | `Child_process_ExecOptionsWithBufferEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecOptionsWithStringEncoding = [`Child_process_CommonOptions | `Child_process_ExecOptions | `Child_process_ExecOptionsWithStringEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecSyncOptions = [`Child_process_CommonOptions | `Child_process_ExecSyncOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecSyncOptionsWithBufferEncoding = [`Child_process_CommonOptions | `Child_process_ExecSyncOptions | `Child_process_ExecSyncOptionsWithBufferEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ExecSyncOptionsWithStringEncoding = [`Child_process_CommonOptions | `Child_process_ExecSyncOptions | `Child_process_ExecSyncOptionsWithStringEncoding | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ForkOptions = [`Child_process_ForkOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_MessageOptions = [`Child_process_MessageOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_MessagingOptions = [`Child_process_MessagingOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_ProcessEnvOptions = [`Child_process_ProcessEnvOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T child_process_PromiseWithChild = [`Child_process_PromiseWithChild of 'T | Promise.tags] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and child_process_SendHandle = (net_Server, net_Socket) union2
    and child_process_Serializable = untyped_object or_boolean or_string or_number
    and child_process_SerializationType = ([`L_s168_advanced[@js "advanced"] | `L_s239_json[@js "json"]] [@js.enum])
    and child_process_SpawnOptions = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions | `Child_process_SpawnOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('Stdin, 'Stdout, 'Stderr) child_process_SpawnOptionsWithStdioTuple = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions | `Child_process_SpawnOptions | `Child_process_SpawnOptionsWithStdioTuple of ('Stdin * 'Stdout * 'Stderr)] intf
    [@@js.custom { of_js=(fun _Stdin _Stdout _Stderr -> Obj.magic); to_js=(fun _Stdin _Stdout _Stderr -> Obj.magic) }]
    and child_process_SpawnOptionsWithoutStdio = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions | `Child_process_SpawnOptions | `Child_process_SpawnOptionsWithoutStdio] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_SpawnSyncOptions = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions | `Child_process_SpawnSyncOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_SpawnSyncOptionsWithBufferEncoding = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions | `Child_process_SpawnSyncOptions | `Child_process_SpawnSyncOptionsWithBufferEncoding] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and child_process_SpawnSyncOptionsWithStringEncoding = [`Child_process_CommonOptions | `Child_process_CommonSpawnOptions | `Child_process_MessagingOptions | `Child_process_ProcessEnvOptions | `Child_process_SpawnSyncOptions | `Child_process_SpawnSyncOptionsWithStringEncoding] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T child_process_SpawnSyncReturns = [`Child_process_SpawnSyncReturns of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and child_process_StdioNull = (Stream.t_0, ([`L_s234_ignore[@js "ignore"] | `L_s236_inherit[@js "inherit"]] [@js.enum])) or_enum
    and child_process_StdioOptions = ((Stream.t_0, ([`L_s234_ignore[@js "ignore"] | `L_s236_inherit[@js "inherit"] | `L_s238_ipc[@js "ipc"] | `L_s271_pipe[@js "pipe"]] [@js.enum])) or_enum or_number or_null_or_undefined list, ([`L_s234_ignore[@js "ignore"] | `L_s236_inherit[@js "inherit"] | `L_s271_pipe[@js "pipe"]] [@js.enum])) or_enum
    and child_process_StdioPipe = ([`L_s271_pipe[@js "pipe"]] [@js.enum]) or_null_or_undefined
    and cluster_Address = [`Cluster_Address] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and cluster_Cluster = [`Cluster_Cluster | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and cluster_ClusterSettings = [`Cluster_ClusterSettings] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and cluster_Worker = [`Cluster_Worker | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and console_global_Console = [`Console_global_Console] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and console_global_NodeJS_ConsoleConstructor = [`Console_global_NodeJS_ConsoleConstructor] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and console_global_NodeJS_ConsoleConstructorOptions = [`Console_global_NodeJS_ConsoleConstructorOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and console_global_NodeJS_Global = [`Console_global_NodeJS_Global] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T crypto_BasePrivateKeyEncodingOptions = [`Crypto_BasePrivateKeyEncodingOptions of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and crypto_BinaryLike = _NodeJS_ArrayBufferView or_string
    and crypto_BinaryToTextEncoding = ([`L_s181_base64[@js "base64"] | `L_s226_hex[@js "hex"]] [@js.enum])
    and crypto_Certificate = [`Crypto_Certificate] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_CharacterEncoding = ([`L_s242_latin1[@js "latin1"] | `L_s327_utf_8[@js "utf-8"] | `L_s328_utf16le[@js "utf16le"] | `L_s329_utf8[@js "utf8"]] [@js.enum])
    and crypto_Cipher = [`Crypto_Cipher | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_CipherCCM = [`Crypto_Cipher | `Crypto_CipherCCM | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_CipherCCMOptions = [`Crypto_CipherCCMOptions | Stream.TransformOptions.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_CipherCCMTypes = ([`L_s169_aes_128_ccm[@js "aes-128-ccm"] | `L_s171_aes_192_ccm[@js "aes-192-ccm"] | `L_s173_aes_256_ccm[@js "aes-256-ccm"] | `L_s188_chacha20_poly1305[@js "chacha20-poly1305"]] [@js.enum])
    and crypto_CipherGCM = [`Crypto_Cipher | `Crypto_CipherGCM | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_CipherGCMOptions = [`Crypto_CipherGCMOptions | Stream.TransformOptions.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_CipherGCMTypes = ([`L_s170_aes_128_gcm[@js "aes-128-gcm"] | `L_s172_aes_192_gcm[@js "aes-192-gcm"] | `L_s174_aes_256_gcm[@js "aes-256-gcm"]] [@js.enum])
    and crypto_CipherKey = (crypto_BinaryLike, crypto_KeyObject) union2
    and crypto_DSAEncoding = ([`L_s202_der[@js "der"] | `L_s232_ieee_p1363[@js "ieee-p1363"]] [@js.enum])
    and crypto_DSAKeyPairKeyObjectOptions = [`Crypto_DSAKeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_DSAKeyPairOptions = [`Crypto_DSAKeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and crypto_Decipher = [`Crypto_Decipher | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_DecipherCCM = [`Crypto_Decipher | `Crypto_DecipherCCM | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_DecipherGCM = [`Crypto_Decipher | `Crypto_DecipherGCM | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_DiffieHellman = [`Crypto_DiffieHellman] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_ECDH = [`Crypto_ECDH] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_ECDHKeyFormat = ([`L_s192_compressed[@js "compressed"] | `L_s231_hybrid[@js "hybrid"] | `L_s321_uncompressed[@js "uncompressed"]] [@js.enum])
    and crypto_ECKeyPairKeyObjectOptions = [`Crypto_ECKeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_ECKeyPairOptions = [`Crypto_ECKeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and crypto_ED25519KeyPairKeyObjectOptions = [`Crypto_ED25519KeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_ED25519KeyPairOptions = [`Crypto_ED25519KeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and crypto_ED448KeyPairKeyObjectOptions = [`Crypto_ED448KeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_ED448KeyPairOptions = [`Crypto_ED448KeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and crypto_Encoding = ((crypto_BinaryToTextEncoding, crypto_CharacterEncoding, crypto_LegacyCharacterEncoding) union3, ([`L_s179_ascii[@js "ascii"] | `L_s181_base64[@js "base64"] | `L_s185_binary[@js "binary"] | `L_s226_hex[@js "hex"] | `L_s242_latin1[@js "latin1"] | `L_s315_ucs_2[@js "ucs-2"] | `L_s316_ucs2[@js "ucs2"] | `L_s327_utf_8[@js "utf-8"] | `L_s328_utf16le[@js "utf16le"] | `L_s329_utf8[@js "utf8"]] [@js.enum])) or_enum
    and crypto_Hash = [`Crypto_Hash | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_HashOptions = [`Crypto_HashOptions | Stream.TransformOptions.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_Hmac = [`Crypto_Hmac | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T crypto_KeyExportOptions = [`Crypto_KeyExportOptions of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and crypto_KeyFormat = ([`L_s202_der[@js "der"] | `L_s269_pem[@js "pem"]] [@js.enum])
    and crypto_KeyLike = (_Buffer, crypto_KeyObject) union2 or_string
    and crypto_KeyObject = [`Crypto_KeyObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_KeyObjectType = ([`L_s274_private[@js "private"] | `L_s275_public[@js "public"] | `L_s294_secret[@js "secret"]] [@js.enum])
    and crypto_KeyPairKeyObjectResult = [`Crypto_KeyPairKeyObjectResult] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('T1, 'T2) crypto_KeyPairSyncResult = [`Crypto_KeyPairSyncResult of ('T1 * 'T2)] intf
    [@@js.custom { of_js=(fun _T1 _T2 -> Obj.magic); to_js=(fun _T1 _T2 -> Obj.magic) }]
    and crypto_KeyType = ([`L_s207_dsa[@js "dsa"] | `L_s208_ec[@js "ec"] | `L_s209_ed25519[@js "ed25519"] | `L_s210_ed448[@js "ed448"] | `L_s292_rsa[@js "rsa"] | `L_s333_x25519[@js "x25519"] | `L_s334_x448[@js "x448"]] [@js.enum])
    and crypto_LegacyCharacterEncoding = ([`L_s179_ascii[@js "ascii"] | `L_s185_binary[@js "binary"] | `L_s315_ucs_2[@js "ucs-2"] | `L_s316_ucs2[@js "ucs2"]] [@js.enum])
    and crypto_PrivateKeyInput = [`Crypto_PrivateKeyInput] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_PublicKeyInput = [`Crypto_PublicKeyInput] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_RSAKeyPairKeyObjectOptions = [`Crypto_RSAKeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_RSAKeyPairOptions = [`Crypto_RSAKeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and crypto_RsaPrivateKey = [`Crypto_RsaPrivateKey] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_RsaPublicKey = [`Crypto_RsaPublicKey] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_ScryptOptions = [`Crypto_ScryptOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_SignKeyObjectInput = [`Crypto_SignKeyObjectInput | `Crypto_SigningOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_SignPrivateKeyInput = [`Crypto_PrivateKeyInput | `Crypto_SignPrivateKeyInput | `Crypto_SigningOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_Signer = [`Crypto_Signer | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_SigningOptions = [`Crypto_SigningOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_Verify = [`Crypto_Verify | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_VerifyKeyObjectInput = [`Crypto_SigningOptions | `Crypto_VerifyKeyObjectInput] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_VerifyPublicKeyInput = [`Crypto_PublicKeyInput | `Crypto_SigningOptions | `Crypto_VerifyPublicKeyInput] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and crypto_X25519KeyPairKeyObjectOptions = [`Crypto_X25519KeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_X25519KeyPairOptions = [`Crypto_X25519KeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and crypto_X448KeyPairKeyObjectOptions = [`Crypto_X448KeyPairKeyObjectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and ('PubF, 'PrivF) crypto_X448KeyPairOptions = [`Crypto_X448KeyPairOptions of ('PubF * 'PrivF)] intf
    [@@js.custom { of_js=(fun _PubF _PrivF -> Obj.magic); to_js=(fun _PubF _PrivF -> Obj.magic) }]
    and dgram_BindOptions = [`Dgram_BindOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dgram_RemoteInfo = [`Dgram_RemoteInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dgram_Socket = [`Dgram_Socket | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dgram_SocketOptions = [`Dgram_SocketOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dgram_SocketType = ([`L_s317_udp4[@js "udp4"] | `L_s318_udp6[@js "udp6"]] [@js.enum])
    and dns_AnyARecord = [`Dns_AnyARecord | `Dns_RecordWithTtl] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyAaaaRecord = [`Dns_AnyAaaaRecord | `Dns_RecordWithTtl] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyCnameRecord = [`Dns_AnyCnameRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyMxRecord = [`Dns_AnyMxRecord | `Dns_MxRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyNaptrRecord = [`Dns_AnyNaptrRecord | `Dns_NaptrRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyNsRecord = [`Dns_AnyNsRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyPtrRecord = [`Dns_AnyPtrRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyRecord = ([`U_s1_A of dns_AnyARecord [@js "A"] | `U_s2_AAAA of dns_AnyAaaaRecord [@js "AAAA"] | `U_s6_CNAME of dns_AnyCnameRecord [@js "CNAME"] | `U_s65_MX of dns_AnyMxRecord [@js "MX"] | `U_s66_NAPTR of dns_AnyNaptrRecord [@js "NAPTR"] | `U_s67_NS of dns_AnyNsRecord [@js "NS"] | `U_s84_PTR of dns_AnyPtrRecord [@js "PTR"] | `U_s158_SOA of dns_AnySoaRecord [@js "SOA"] | `U_s159_SRV of dns_AnySrvRecord [@js "SRV"] | `U_s165_TXT of dns_AnyTxtRecord [@js "TXT"]] [@js.union on_field "type"])
    and dns_AnyRecordWithTtl = ([`U_s1_A of dns_AnyARecord [@js "A"] | `U_s2_AAAA of dns_AnyAaaaRecord [@js "AAAA"]] [@js.union on_field "type"])
    and dns_AnySoaRecord = [`Dns_AnySoaRecord | `Dns_SoaRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnySrvRecord = [`Dns_AnySrvRecord | `Dns_SrvRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_AnyTxtRecord = [`Dns_AnyTxtRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_LookupAddress = [`Dns_LookupAddress] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_LookupAllOptions = [`Dns_LookupAllOptions | `Dns_LookupOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_LookupOneOptions = [`Dns_LookupOneOptions | `Dns_LookupOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_LookupOptions = [`Dns_LookupOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_MxRecord = [`Dns_MxRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_NaptrRecord = [`Dns_NaptrRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_RecordWithTtl = [`Dns_RecordWithTtl] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_ResolveOptions = [`Dns_ResolveOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_ResolveWithTtlOptions = [`Dns_ResolveOptions | `Dns_ResolveWithTtlOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_Resolver = [`Dns_Resolver] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_ResolverOptions = [`Dns_ResolverOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_SoaRecord = [`Dns_SoaRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_SrvRecord = [`Dns_SrvRecord] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and dns_promises_Resolver = [`Dns_promises_Resolver] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and domain_Domain = [`Domain_Domain | EventEmitter.tags | NodeJS.Domain.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and domain_global_NodeJS_Domain = [`Domain_global_NodeJS_Domain | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and events_DOMEventTarget = [`Events_DOMEventTarget] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and events_EventEmitter = [`Events_EventEmitter | NodeJS.EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and events_EventEmitterOptions = [`Events_EventEmitterOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and events_NodeEventTarget = [`Events_NodeEventTarget] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and events_global_NodeJS_EventEmitter = [`Events_global_NodeJS_EventEmitter] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_BaseEncodingOptions = [`Fs_BaseEncodingOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_BigIntOptions = [`Fs_BigIntOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_BigIntStats = [`Fs_BigIntStats | `Fs_StatsBase of bigint] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_BufferEncodingOption = (anonymous_interface_14, ([`L_s187_buffer[@js "buffer"]] [@js.enum])) or_enum
    and fs_Dir = [`Fs_Dir] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_Dirent = [`Fs_Dirent] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_FSWatcher = [`Fs_FSWatcher | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_MakeDirectoryOptions = [`Fs_MakeDirectoryOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_Mode = string or_number
    and fs_NoParamCallback = [`Fs_NoParamCallback] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_OpenDirOptions = [`Fs_OpenDirOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_OpenMode = string or_number
    and fs_PathLike = (_Buffer, URL.t_0) union2 or_string
    and fs_ReadStream = [`Fs_ReadStream | Stream.Readable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_ReadSyncOptions = [`Fs_ReadSyncOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_ReadVResult = [`Fs_ReadVResult] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_RmDirOptions = [`Fs_RmDirOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_RmOptions = [`Fs_RmOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_StatOptions = [`Fs_StatOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_Stats = [`Fs_Stats | `Fs_StatsBase of float] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T fs_StatsBase = [`Fs_StatsBase of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and fs_WriteFileOptions = (fs_BaseEncodingOptions, anonymous_interface_33) intersection2 or_string or_null
    and fs_WriteStream = [`Fs_WriteStream | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_WriteVResult = [`Fs_WriteVResult] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and fs_symlink_Type = ([`L_s204_dir[@js "dir"] | `L_s216_file[@js "file"] | `L_s240_junction[@js "junction"]] [@js.enum])
    and http_Agent = [`Http_Agent] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_AgentOptions = [`Http_AgentOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_ClientRequest = [`Http_ClientRequest | `Http_OutgoingMessage | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_ClientRequestArgs = [`Http_ClientRequestArgs] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_HttpBase = [`Http_HttpBase] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_IncomingHttpHeaders = [`NodeJS_Dict of string list or_string | `Http_IncomingHttpHeaders] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_IncomingMessage = [`Http_IncomingMessage | Stream.Readable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_InformationEvent = [`Http_InformationEvent] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_OutgoingHttpHeader = string list or_string or_number
    and http_OutgoingHttpHeaders = [`NodeJS_Dict of http_OutgoingHttpHeader | `Http_OutgoingHttpHeaders] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_OutgoingMessage = [`Http_OutgoingMessage | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_RequestListener = [`Http_RequestListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_RequestOptions = [`Http_ClientRequestArgs | `Http_RequestOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_Server = [`Http_HttpBase | `Http_Server | NetServer.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_ServerOptions = [`Http_ServerOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http_ServerResponse = [`Http_OutgoingMessage | `Http_ServerResponse | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_AlternativeServiceOptions = [`Http2_AlternativeServiceOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ClientHttp2Session = [`Http2_ClientHttp2Session | `Http2_Http2Session | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ClientHttp2Stream = [`Http2_ClientHttp2Stream | `Http2_Http2Stream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ClientSessionOptions = [`Http2_ClientSessionOptions | `Http2_SessionOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ClientSessionRequestOptions = [`Http2_ClientSessionRequestOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Http2SecureServer = [`Http2_Http2SecureServer | `Net_Server | `Tls_Server | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Http2Server = [`Http2_Http2Server | `Net_Server | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Http2ServerRequest = [`Http2_Http2ServerRequest | Stream.Readable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Http2ServerResponse = [`Http2_Http2ServerResponse | Stream.Writable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Http2Session = [`Http2_Http2Session | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Http2Stream = [`Http2_Http2Stream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_IncomingHttpHeaders = [`Http2_IncomingHttpHeaders | Http1IncomingHttpHeaders.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_IncomingHttpStatusHeader = [`Http2_IncomingHttpStatusHeader] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_SecureClientSessionOptions = [`Http2_ClientSessionOptions | `Http2_SecureClientSessionOptions | `Http2_SessionOptions | `Tls_CommonConnectionOptions | `Tls_ConnectionOptions | `Tls_SecureContextOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_SecureServerOptions = [`Http2_SecureServerOptions | `Http2_SecureServerSessionOptions | `Http2_ServerSessionOptions | `Http2_SessionOptions | `Net_ServerOpts | `Tls_CommonConnectionOptions | `Tls_SecureContextOptions | `Tls_TlsOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_SecureServerSessionOptions = [`Http2_SecureServerSessionOptions | `Http2_ServerSessionOptions | `Http2_SessionOptions | `Net_ServerOpts | `Tls_CommonConnectionOptions | `Tls_SecureContextOptions | `Tls_TlsOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerHttp2Session = [`Http2_Http2Session | `Http2_ServerHttp2Session | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerHttp2Stream = [`Http2_Http2Stream | `Http2_ServerHttp2Stream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerOptions = [`Http2_ServerOptions | `Http2_ServerSessionOptions | `Http2_SessionOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerSessionOptions = [`Http2_ServerSessionOptions | `Http2_SessionOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerStreamFileResponseOptions = [`Http2_ServerStreamFileResponseOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerStreamFileResponseOptionsWithError = [`Http2_ServerStreamFileResponseOptions | `Http2_ServerStreamFileResponseOptionsWithError] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_ServerStreamResponseOptions = [`Http2_ServerStreamResponseOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_SessionOptions = [`Http2_SessionOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_SessionState = [`Http2_SessionState] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_Settings = [`Http2_Settings] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_StatOptions = [`Http2_StatOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_StreamPriorityOptions = [`Http2_StreamPriorityOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and http2_StreamState = [`Http2_StreamState] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and https_Agent = [`Http_Agent | `Https_Agent] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and https_AgentOptions = [`Http_AgentOptions | `Https_AgentOptions | `Tls_CommonConnectionOptions | `Tls_ConnectionOptions | `Tls_SecureContextOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and https_RequestOptions = (http_RequestOptions, tls_SecureContextOptions, anonymous_interface_48) intersection3
    and https_Server = [`Http_HttpBase | `Https_Server | `Net_Server | `Tls_Server | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and https_ServerOptions = (tls_SecureContextOptions, tls_TlsOptions, http_ServerOptions) intersection3
    and inspector_Console_ConsoleMessage = [`Inspector_Console_ConsoleMessage] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Console_MessageAddedEventDataType = [`Inspector_Console_MessageAddedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_BreakLocation = [`Inspector_Debugger_BreakLocation] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_BreakpointId = string
    and inspector_Debugger_BreakpointResolvedEventDataType = [`Inspector_Debugger_BreakpointResolvedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_CallFrame = [`Inspector_Debugger_CallFrame] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_CallFrameId = string
    and inspector_Debugger_ContinueToLocationParameterType = [`Inspector_Debugger_ContinueToLocationParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_EnableReturnType = [`Inspector_Debugger_EnableReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_EvaluateOnCallFrameParameterType = [`Inspector_Debugger_EvaluateOnCallFrameParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_EvaluateOnCallFrameReturnType = [`Inspector_Debugger_EvaluateOnCallFrameReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_GetPossibleBreakpointsParameterType = [`Inspector_Debugger_GetPossibleBreakpointsParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_GetPossibleBreakpointsReturnType = [`Inspector_Debugger_GetPossibleBreakpointsReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_GetScriptSourceParameterType = [`Inspector_Debugger_GetScriptSourceParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_GetScriptSourceReturnType = [`Inspector_Debugger_GetScriptSourceReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_GetStackTraceParameterType = [`Inspector_Debugger_GetStackTraceParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_GetStackTraceReturnType = [`Inspector_Debugger_GetStackTraceReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_Location = [`Inspector_Debugger_Location] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_PauseOnAsyncCallParameterType = [`Inspector_Debugger_PauseOnAsyncCallParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_PausedEventDataType = [`Inspector_Debugger_PausedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_RemoveBreakpointParameterType = [`Inspector_Debugger_RemoveBreakpointParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_RestartFrameParameterType = [`Inspector_Debugger_RestartFrameParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_RestartFrameReturnType = [`Inspector_Debugger_RestartFrameReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_Scope = [`Inspector_Debugger_Scope] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_ScriptFailedToParseEventDataType = [`Inspector_Debugger_ScriptFailedToParseEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_ScriptParsedEventDataType = [`Inspector_Debugger_ScriptParsedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_ScriptPosition = [`Inspector_Debugger_ScriptPosition] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SearchInContentParameterType = [`Inspector_Debugger_SearchInContentParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SearchInContentReturnType = [`Inspector_Debugger_SearchInContentReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SearchMatch = [`Inspector_Debugger_SearchMatch] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetAsyncCallStackDepthParameterType = [`Inspector_Debugger_SetAsyncCallStackDepthParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBlackboxPatternsParameterType = [`Inspector_Debugger_SetBlackboxPatternsParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBlackboxedRangesParameterType = [`Inspector_Debugger_SetBlackboxedRangesParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBreakpointByUrlParameterType = [`Inspector_Debugger_SetBreakpointByUrlParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBreakpointByUrlReturnType = [`Inspector_Debugger_SetBreakpointByUrlReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBreakpointParameterType = [`Inspector_Debugger_SetBreakpointParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBreakpointReturnType = [`Inspector_Debugger_SetBreakpointReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetBreakpointsActiveParameterType = [`Inspector_Debugger_SetBreakpointsActiveParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetPauseOnExceptionsParameterType = [`Inspector_Debugger_SetPauseOnExceptionsParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetReturnValueParameterType = [`Inspector_Debugger_SetReturnValueParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetScriptSourceParameterType = [`Inspector_Debugger_SetScriptSourceParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetScriptSourceReturnType = [`Inspector_Debugger_SetScriptSourceReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetSkipAllPausesParameterType = [`Inspector_Debugger_SetSkipAllPausesParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_SetVariableValueParameterType = [`Inspector_Debugger_SetVariableValueParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Debugger_StepIntoParameterType = [`Inspector_Debugger_StepIntoParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType = [`Inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_AddInspectedHeapObjectParameterType = [`Inspector_HeapProfiler_AddInspectedHeapObjectParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_GetHeapObjectIdParameterType = [`Inspector_HeapProfiler_GetHeapObjectIdParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_GetHeapObjectIdReturnType = [`Inspector_HeapProfiler_GetHeapObjectIdReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_GetObjectByHeapObjectIdParameterType = [`Inspector_HeapProfiler_GetObjectByHeapObjectIdParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_GetObjectByHeapObjectIdReturnType = [`Inspector_HeapProfiler_GetObjectByHeapObjectIdReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_GetSamplingProfileReturnType = [`Inspector_HeapProfiler_GetSamplingProfileReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_HeapSnapshotObjectId = string
    and inspector_HeapProfiler_HeapStatsUpdateEventDataType = [`Inspector_HeapProfiler_HeapStatsUpdateEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_LastSeenObjectIdEventDataType = [`Inspector_HeapProfiler_LastSeenObjectIdEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType = [`Inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_SamplingHeapProfile = [`Inspector_HeapProfiler_SamplingHeapProfile] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_SamplingHeapProfileNode = [`Inspector_HeapProfiler_SamplingHeapProfileNode] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_StartSamplingParameterType = [`Inspector_HeapProfiler_StartSamplingParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_StartTrackingHeapObjectsParameterType = [`Inspector_HeapProfiler_StartTrackingHeapObjectsParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_StopSamplingReturnType = [`Inspector_HeapProfiler_StopSamplingReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_StopTrackingHeapObjectsParameterType = [`Inspector_HeapProfiler_StopTrackingHeapObjectsParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_HeapProfiler_TakeHeapSnapshotParameterType = [`Inspector_HeapProfiler_TakeHeapSnapshotParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'T inspector_InspectorNotification = [`Inspector_InspectorNotification of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and inspector_NodeRuntime_NotifyWhenWaitingForDisconnectParameterType = [`Inspector_NodeRuntime_NotifyWhenWaitingForDisconnectParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeTracing_DataCollectedEventDataType = [`Inspector_NodeTracing_DataCollectedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeTracing_GetCategoriesReturnType = [`Inspector_NodeTracing_GetCategoriesReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeTracing_StartParameterType = [`Inspector_NodeTracing_StartParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeTracing_TraceConfig = [`Inspector_NodeTracing_TraceConfig] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_AttachedToWorkerEventDataType = [`Inspector_NodeWorker_AttachedToWorkerEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_DetachParameterType = [`Inspector_NodeWorker_DetachParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_DetachedFromWorkerEventDataType = [`Inspector_NodeWorker_DetachedFromWorkerEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_EnableParameterType = [`Inspector_NodeWorker_EnableParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType = [`Inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_SendMessageToWorkerParameterType = [`Inspector_NodeWorker_SendMessageToWorkerParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_NodeWorker_SessionID = string
    and inspector_NodeWorker_WorkerID = string
    and inspector_NodeWorker_WorkerInfo = [`Inspector_NodeWorker_WorkerInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_ConsoleProfileFinishedEventDataType = [`Inspector_Profiler_ConsoleProfileFinishedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_ConsoleProfileStartedEventDataType = [`Inspector_Profiler_ConsoleProfileStartedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_CoverageRange = [`Inspector_Profiler_CoverageRange] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_FunctionCoverage = [`Inspector_Profiler_FunctionCoverage] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_GetBestEffortCoverageReturnType = [`Inspector_Profiler_GetBestEffortCoverageReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_PositionTickInfo = [`Inspector_Profiler_PositionTickInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_Profile = [`Inspector_Profiler_Profile] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_ProfileNode = [`Inspector_Profiler_ProfileNode] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_ScriptCoverage = [`Inspector_Profiler_ScriptCoverage] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_ScriptTypeProfile = [`Inspector_Profiler_ScriptTypeProfile] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_SetSamplingIntervalParameterType = [`Inspector_Profiler_SetSamplingIntervalParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_StartPreciseCoverageParameterType = [`Inspector_Profiler_StartPreciseCoverageParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_StopReturnType = [`Inspector_Profiler_StopReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_TakePreciseCoverageReturnType = [`Inspector_Profiler_TakePreciseCoverageReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_TakeTypeProfileReturnType = [`Inspector_Profiler_TakeTypeProfileReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_TypeObject = [`Inspector_Profiler_TypeObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Profiler_TypeProfileEntry = [`Inspector_Profiler_TypeProfileEntry] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_AwaitPromiseParameterType = [`Inspector_Runtime_AwaitPromiseParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_AwaitPromiseReturnType = [`Inspector_Runtime_AwaitPromiseReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CallArgument = [`Inspector_Runtime_CallArgument] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CallFrame = [`Inspector_Runtime_CallFrame] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CallFunctionOnParameterType = [`Inspector_Runtime_CallFunctionOnParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CallFunctionOnReturnType = [`Inspector_Runtime_CallFunctionOnReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CompileScriptParameterType = [`Inspector_Runtime_CompileScriptParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CompileScriptReturnType = [`Inspector_Runtime_CompileScriptReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ConsoleAPICalledEventDataType = [`Inspector_Runtime_ConsoleAPICalledEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_CustomPreview = [`Inspector_Runtime_CustomPreview] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_EntryPreview = [`Inspector_Runtime_EntryPreview] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_EvaluateParameterType = [`Inspector_Runtime_EvaluateParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_EvaluateReturnType = [`Inspector_Runtime_EvaluateReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExceptionDetails = [`Inspector_Runtime_ExceptionDetails] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExceptionRevokedEventDataType = [`Inspector_Runtime_ExceptionRevokedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExceptionThrownEventDataType = [`Inspector_Runtime_ExceptionThrownEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExecutionContextCreatedEventDataType = [`Inspector_Runtime_ExecutionContextCreatedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExecutionContextDescription = [`Inspector_Runtime_ExecutionContextDescription] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExecutionContextDestroyedEventDataType = [`Inspector_Runtime_ExecutionContextDestroyedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ExecutionContextId = float
    and inspector_Runtime_GetPropertiesParameterType = [`Inspector_Runtime_GetPropertiesParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_GetPropertiesReturnType = [`Inspector_Runtime_GetPropertiesReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_GlobalLexicalScopeNamesParameterType = [`Inspector_Runtime_GlobalLexicalScopeNamesParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_GlobalLexicalScopeNamesReturnType = [`Inspector_Runtime_GlobalLexicalScopeNamesReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_InspectRequestedEventDataType = [`Inspector_Runtime_InspectRequestedEventDataType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_InternalPropertyDescriptor = [`Inspector_Runtime_InternalPropertyDescriptor] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ObjectPreview = [`Inspector_Runtime_ObjectPreview] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_PropertyDescriptor = [`Inspector_Runtime_PropertyDescriptor] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_PropertyPreview = [`Inspector_Runtime_PropertyPreview] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_QueryObjectsParameterType = [`Inspector_Runtime_QueryObjectsParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_QueryObjectsReturnType = [`Inspector_Runtime_QueryObjectsReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ReleaseObjectGroupParameterType = [`Inspector_Runtime_ReleaseObjectGroupParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ReleaseObjectParameterType = [`Inspector_Runtime_ReleaseObjectParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_RemoteObject = [`Inspector_Runtime_RemoteObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_RemoteObjectId = string
    and inspector_Runtime_RunScriptParameterType = [`Inspector_Runtime_RunScriptParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_RunScriptReturnType = [`Inspector_Runtime_RunScriptReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_ScriptId = string
    and inspector_Runtime_SetCustomObjectFormatterEnabledParameterType = [`Inspector_Runtime_SetCustomObjectFormatterEnabledParameterType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_StackTrace = [`Inspector_Runtime_StackTrace] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_StackTraceId = [`Inspector_Runtime_StackTraceId] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Runtime_Timestamp = float
    and inspector_Runtime_UniqueDebuggerId = string
    and inspector_Runtime_UnserializableValue = string
    and inspector_Schema_Domain = [`Inspector_Schema_Domain] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Schema_GetDomainsReturnType = [`Inspector_Schema_GetDomainsReturnType] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and inspector_Session = [`Inspector_Session | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and module_Module = [`NodeJS_Module | `NodeModule | `Module_Module] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and module_Module_SourceMap = [`Module_Module_SourceMap] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and module_Module_SourceMapPayload = [`Module_Module_SourceMapPayload] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and module_Module_SourceMapping = [`Module_Module_SourceMapping] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_AddressInfo = [`Net_AddressInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_ConnectOpts = [`Net_ConnectOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_IpcNetConnectOpts = [`Net_ConnectOpts | `Net_IpcNetConnectOpts | `Net_IpcSocketConnectOpts | `Net_SocketConstructorOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_IpcSocketConnectOpts = [`Net_ConnectOpts | `Net_IpcSocketConnectOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_ListenOptions = [`Net_ListenOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_LookupFunction = [`Net_LookupFunction] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_NetConnectOpts = (net_IpcNetConnectOpts, net_TcpNetConnectOpts) union2
    and net_OnReadOpts = [`Net_OnReadOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_Server = [`Net_Server | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_ServerOpts = [`Net_ServerOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_Socket = [`Net_Socket | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_SocketConnectOpts = (net_IpcSocketConnectOpts, net_TcpSocketConnectOpts) union2
    and net_SocketConstructorOpts = [`Net_SocketConstructorOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_TcpNetConnectOpts = [`Net_ConnectOpts | `Net_SocketConstructorOpts | `Net_TcpNetConnectOpts | `Net_TcpSocketConnectOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and net_TcpSocketConnectOpts = [`Net_ConnectOpts | `Net_TcpSocketConnectOpts] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and os_CpuInfo = [`Os_CpuInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and os_NetworkInterfaceBase = [`Os_NetworkInterfaceBase] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and os_NetworkInterfaceInfo = ([`U_s62_IPv4 of os_NetworkInterfaceInfoIPv4 [@js "IPv4"] | `U_s63_IPv6 of os_NetworkInterfaceInfoIPv6 [@js "IPv6"]] [@js.union on_field "family"])
    and os_NetworkInterfaceInfoIPv4 = [`Os_NetworkInterfaceBase | `Os_NetworkInterfaceInfoIPv4] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and os_NetworkInterfaceInfoIPv6 = [`Os_NetworkInterfaceBase | `Os_NetworkInterfaceInfoIPv6] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and os_SignalConstants = (* FIXME: unknown type '{
            [key in NodeJS.Signals]: number;
        }' *)any
    and 'T os_UserInfo = [`Os_UserInfo of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and path_path_FormatInputPathObject = [`Path_path_FormatInputPathObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and path_path_ParsedPath = [`Path_path_ParsedPath] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and path_path_PlatformPath = [`Path_path_PlatformPath] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_EntryType = ([`L_s221_function[@js "function"] | `L_s222_gc[@js "gc"] | `L_s227_http[@js "http"] | `L_s228_http2[@js "http2"] | `L_s249_mark[@js "mark"] | `L_s250_measure[@js "measure"] | `L_s258_node[@js "node"]] [@js.enum])
    and perf_hooks_EventLoopDelayMonitor = [`Perf_hooks_EventLoopDelayMonitor] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_EventLoopMonitorOptions = [`Perf_hooks_EventLoopMonitorOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_EventLoopUtilization = [`Perf_hooks_EventLoopUtilization] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_Performance = [`Perf_hooks_Performance] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_PerformanceEntry = [`Perf_hooks_PerformanceEntry] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_PerformanceNodeTiming = [`Perf_hooks_PerformanceEntry | `Perf_hooks_PerformanceNodeTiming] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_PerformanceObserver = [`Perf_hooks_PerformanceObserver | AsyncResource.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_PerformanceObserverCallback = [`Perf_hooks_PerformanceObserverCallback] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and perf_hooks_PerformanceObserverEntryList = [`Perf_hooks_PerformanceObserverEntryList] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_BeforeExitListener = [`Process_global_NodeJS_BeforeExitListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_CpuUsage = [`Process_global_NodeJS_CpuUsage] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_DisconnectListener = [`Process_global_NodeJS_DisconnectListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_EmitWarningOptions = [`Process_global_NodeJS_EmitWarningOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ExitListener = [`Process_global_NodeJS_ExitListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_Global = [`Process_global_NodeJS_Global] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_HRTime = [`Process_global_NodeJS_HRTime] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_MemoryUsage = [`Process_global_NodeJS_MemoryUsage] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_MessageListener = [`Process_global_NodeJS_MessageListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_MultipleResolveListener = [`Process_global_NodeJS_MultipleResolveListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_MultipleResolveType = ([`L_s280_reject[@js "reject"] | `L_s288_resolve[@js "resolve"]] [@js.enum])
    and process_global_NodeJS_NewListenerListener = [`Process_global_NodeJS_NewListenerListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_Platform = ([`L_s176_aix[@js "aix"] | `L_s178_android[@js "android"] | `L_s196_cygwin[@js "cygwin"] | `L_s197_darwin[@js "darwin"] | `L_s220_freebsd[@js "freebsd"] | `L_s245_linux[@js "linux"] | `L_s255_netbsd[@js "netbsd"] | `L_s266_openbsd[@js "openbsd"] | `L_s310_sunos[@js "sunos"] | `L_s332_win32[@js "win32"]] [@js.enum])
    and process_global_NodeJS_Process = [`Process_global_NodeJS_Process | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ProcessEnv = [`Process_global_NodeJS_ProcessEnv | Dict.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ProcessRelease = [`Process_global_NodeJS_ProcessRelease] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ProcessReport = [`Process_global_NodeJS_ProcessReport] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ProcessVersions = [`Process_global_NodeJS_ProcessVersions | Dict.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ReadStream = [`Net_Socket | `Process_global_NodeJS_ReadStream | `Tty_ReadStream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_RejectionHandledListener = [`Process_global_NodeJS_RejectionHandledListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_RemoveListenerListener = [`Process_global_NodeJS_RemoveListenerListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_ResourceUsage = [`Process_global_NodeJS_ResourceUsage] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_Signals = ([`L_s121_SIGABRT[@js "SIGABRT"] | `L_s122_SIGALRM[@js "SIGALRM"] | `L_s123_SIGBREAK[@js "SIGBREAK"] | `L_s124_SIGBUS[@js "SIGBUS"] | `L_s125_SIGCHLD[@js "SIGCHLD"] | `L_s126_SIGCONT[@js "SIGCONT"] | `L_s127_SIGFPE[@js "SIGFPE"] | `L_s128_SIGHUP[@js "SIGHUP"] | `L_s129_SIGILL[@js "SIGILL"] | `L_s130_SIGINFO[@js "SIGINFO"] | `L_s131_SIGINT[@js "SIGINT"] | `L_s132_SIGIO[@js "SIGIO"] | `L_s133_SIGIOT[@js "SIGIOT"] | `L_s134_SIGKILL[@js "SIGKILL"] | `L_s135_SIGLOST[@js "SIGLOST"] | `L_s136_SIGPIPE[@js "SIGPIPE"] | `L_s137_SIGPOLL[@js "SIGPOLL"] | `L_s138_SIGPROF[@js "SIGPROF"] | `L_s139_SIGPWR[@js "SIGPWR"] | `L_s140_SIGQUIT[@js "SIGQUIT"] | `L_s141_SIGSEGV[@js "SIGSEGV"] | `L_s142_SIGSTKFLT[@js "SIGSTKFLT"] | `L_s143_SIGSTOP[@js "SIGSTOP"] | `L_s144_SIGSYS[@js "SIGSYS"] | `L_s145_SIGTERM[@js "SIGTERM"] | `L_s146_SIGTRAP[@js "SIGTRAP"] | `L_s147_SIGTSTP[@js "SIGTSTP"] | `L_s148_SIGTTIN[@js "SIGTTIN"] | `L_s149_SIGTTOU[@js "SIGTTOU"] | `L_s150_SIGUNUSED[@js "SIGUNUSED"] | `L_s151_SIGURG[@js "SIGURG"] | `L_s152_SIGUSR1[@js "SIGUSR1"] | `L_s153_SIGUSR2[@js "SIGUSR2"] | `L_s154_SIGVTALRM[@js "SIGVTALRM"] | `L_s155_SIGWINCH[@js "SIGWINCH"] | `L_s156_SIGXCPU[@js "SIGXCPU"] | `L_s157_SIGXFSZ[@js "SIGXFSZ"]] [@js.enum])
    and process_global_NodeJS_SignalsListener = [`Process_global_NodeJS_SignalsListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_Socket = [`Process_global_NodeJS_Socket | ReadWriteStream.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_UncaughtExceptionListener = [`Process_global_NodeJS_UncaughtExceptionListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_UnhandledRejectionListener = [`Process_global_NodeJS_UnhandledRejectionListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_WarningListener = [`Process_global_NodeJS_WarningListener] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and process_global_NodeJS_WriteStream = [`Net_Socket | `Process_global_NodeJS_WriteStream | `Tty_WriteStream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and punycode_ucs2 = [`Punycode_ucs2] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and querystring_ParseOptions = [`Querystring_ParseOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and querystring_ParsedUrlQuery = [`NodeJS_Dict of string list or_string | `Querystring_ParsedUrlQuery] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and querystring_ParsedUrlQueryInput = [`NodeJS_Dict of (string list, bool list, float list) union3 or_boolean or_string or_number or_null | `Querystring_ParsedUrlQueryInput] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and querystring_StringifyOptions = [`Querystring_StringifyOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and readline_AsyncCompleter = [`Readline_AsyncCompleter] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and readline_Completer = [`Readline_Completer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and readline_CompleterResult = (string list * string)
    and readline_CursorPos = [`Readline_CursorPos] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and readline_Direction = ([`L_n_minus1[@js -1] | `L_n_0[@js 0] | `L_n_1[@js 1]] [@js.enum])
    and readline_Interface = [`Readline_Interface | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and readline_Key = [`Readline_Key] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and readline_ReadLine = readline_Interface
    and readline_ReadLineOptions = [`Readline_ReadLineOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_REPLCommand = [`Repl_REPLCommand] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_REPLCommandAction = [`Repl_REPLCommandAction] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_REPLEval = [`Repl_REPLEval] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_REPLServer = [`Repl_REPLServer | Interface.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_REPLWriter = [`Repl_REPLWriter] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_Recoverable = [`Repl_Recoverable | SyntaxError.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and repl_ReplOptions = [`Repl_ReplOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal = [`Stream_internal | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_Duplex = [`NodeJS_ReadableStream | `NodeJS_WritableStream | `Stream_internal | `Stream_internal_Duplex | `Stream_internal_Readable | `Stream_internal_Stream | `Stream_internal_Writable | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_DuplexOptions = [`Stream_internal_DuplexOptions | `Stream_internal_ReadableOptions | `Stream_internal_WritableOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_FinishedOptions = [`Stream_internal_FinishedOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_PassThrough = [`NodeJS_ReadableStream | `NodeJS_WritableStream | `Stream_internal | `Stream_internal_Duplex | `Stream_internal_PassThrough | `Stream_internal_Readable | `Stream_internal_Stream | `Stream_internal_Transform | `Stream_internal_Writable | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_Pipe = [`Stream_internal_Pipe] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'S stream_internal_PipelineCallback = (* FIXME: unknown type 'S extends PipelineDestinationPromiseFunction<any, infer P> ? (err: NodeJS.ErrnoException | null, value: P) => void :
                    (err: NodeJS.ErrnoException | null) => void' *)any
    and ('S, 'P) stream_internal_PipelineDestination = (* FIXME: unknown type 'S extends PipelineTransformSource<infer ST> ?
                    (NodeJS.WritableStream | PipelineDestinationIterableFunction<ST> | PipelineDestinationPromiseFunction<ST, P>) : never' *)any
    and 'T stream_internal_PipelineDestinationIterableFunction = [`Stream_internal_PipelineDestinationIterableFunction of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and ('T, 'P) stream_internal_PipelineDestinationPromiseFunction = [`Stream_internal_PipelineDestinationPromiseFunction of ('T * 'P)] intf
    [@@js.custom { of_js=(fun _T _P -> Obj.magic); to_js=(fun _T _P -> Obj.magic) }]
    and 'S stream_internal_PipelinePromise = (* FIXME: unknown type 'S extends PipelineDestinationPromiseFunction<any, infer P> ? Promise<P> : Promise<void>' *)any
    and 'T stream_internal_PipelineSource = (_NodeJS_ReadableStream, 'T AsyncIterable.t_1, 'T Iterable.t_1, 'T stream_internal_PipelineSourceFunction) union4
    and 'T stream_internal_PipelineSourceFunction = [`Stream_internal_PipelineSourceFunction of 'T] intf
    [@@js.custom { of_js=(fun _T -> Obj.magic); to_js=(fun _T -> Obj.magic) }]
    and ('S, 'U) stream_internal_PipelineTransform = (_NodeJS_ReadWriteStream, (source:(* FIXME: unknown type 'S extends (...args: any[]) => Iterable<infer ST> | AsyncIterable<infer ST> ?
                    AsyncIterable<ST> : S' *)any -> 'U AsyncIterable.t_1)) union2
    and 'T stream_internal_PipelineTransformSource = ('T stream_internal_PipelineSource, (any, 'T) stream_internal_PipelineTransform) union2
    and stream_internal_Readable = [`NodeJS_ReadableStream | `Stream_internal | `Stream_internal_Readable | `Stream_internal_Stream | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_ReadableOptions = [`Stream_internal_ReadableOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_Stream = [`Stream_internal | `Stream_internal_Stream | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_Transform = [`NodeJS_ReadableStream | `NodeJS_WritableStream | `Stream_internal | `Stream_internal_Duplex | `Stream_internal_Readable | `Stream_internal_Stream | `Stream_internal_Transform | `Stream_internal_Writable | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_TransformCallback = [`Stream_internal_TransformCallback] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_TransformOptions = [`Stream_internal_DuplexOptions | `Stream_internal_ReadableOptions | `Stream_internal_TransformOptions | `Stream_internal_WritableOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_Writable = [`NodeJS_WritableStream | `Stream_internal | `Stream_internal_Stream | `Stream_internal_Writable | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and stream_internal_WritableOptions = [`Stream_internal_WritableOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and string_decoder_StringDecoder = [`String_decoder_StringDecoder] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_Certificate = [`Tls_Certificate] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_CipherNameAndProtocol = [`Tls_CipherNameAndProtocol] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_CommonConnectionOptions = [`Tls_CommonConnectionOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_ConnectionOptions = [`Tls_CommonConnectionOptions | `Tls_ConnectionOptions | `Tls_SecureContextOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_DetailedPeerCertificate = [`Tls_DetailedPeerCertificate | `Tls_PeerCertificate] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_EphemeralKeyInfo = [`Tls_EphemeralKeyInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_KeyObject = [`Tls_KeyObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_PSKCallbackNegotation = [`Tls_PSKCallbackNegotation] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_PeerCertificate = [`Tls_PeerCertificate] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_PxfObject = [`Tls_PxfObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_SecureContext = [`Tls_SecureContext] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_SecureContextOptions = [`Tls_SecureContextOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_SecurePair = [`Tls_SecurePair] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_SecureVersion = ([`L_s161_TLSv1[@js "TLSv1"] | `L_s162_TLSv1_1[@js "TLSv1.1"] | `L_s163_TLSv1_2[@js "TLSv1.2"] | `L_s164_TLSv1_3[@js "TLSv1.3"]] [@js.enum])
    and tls_Server = [`Net_Server | `Tls_Server | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_TLSSocket = [`Net_Socket | `Tls_TLSSocket | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_TLSSocketOptions = [`Tls_CommonConnectionOptions | `Tls_SecureContextOptions | `Tls_TLSSocketOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tls_TlsOptions = [`Net_ServerOpts | `Tls_CommonConnectionOptions | `Tls_SecureContextOptions | `Tls_TlsOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and trace_events_CreateTracingOptions = [`Trace_events_CreateTracingOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and trace_events_Tracing = [`Trace_events_Tracing] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tty_Direction = ([`L_n_minus1[@js -1] | `L_n_0[@js 0] | `L_n_1[@js 1]] [@js.enum])
    and tty_ReadStream = [`Net_Socket | `Tty_ReadStream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and tty_WriteStream = [`Net_Socket | `Tty_WriteStream | Stream.Duplex.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_URL = [`Url_URL] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_URLFormatOptions = [`Url_URLFormatOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_URLSearchParams = [`Url_URLSearchParams | Iterable.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_Url = [`Url_Url] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_UrlObject = [`Url_UrlObject] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_UrlWithParsedQuery = [`Url_Url | `Url_UrlWithParsedQuery] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and url_UrlWithStringQuery = [`Url_Url | `Url_UrlWithStringQuery] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and util_CustomInspectFunction = [`Util_CustomInspectFunction] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and 'TCustom util_CustomPromisify = ('TCustom util_CustomPromisifyLegacy, 'TCustom util_CustomPromisifySymbol) union2
    and 'TCustom util_CustomPromisifyLegacy = [`Util_CustomPromisifyLegacy of 'TCustom | `Function] intf
    [@@js.custom { of_js=(fun _TCustom -> Obj.magic); to_js=(fun _TCustom -> Obj.magic) }]
    and 'TCustom util_CustomPromisifySymbol = [`Util_CustomPromisifySymbol of 'TCustom | `Function] intf
    [@@js.custom { of_js=(fun _TCustom -> Obj.magic); to_js=(fun _TCustom -> Obj.magic) }]
    and util_EncodeIntoResult = [`Util_EncodeIntoResult] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and util_InspectOptions = [`NodeJS_InspectOptions | `Util_InspectOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and util_InspectOptionsStylized = [`NodeJS_InspectOptions | `Util_InspectOptions | `Util_InspectOptionsStylized] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and util_Style = ([`L_s184_bigint[@js "bigint"] | `L_s186_boolean[@js "boolean"] | `L_s199_date[@js "date"] | `L_s253_module[@js "module"] | `L_s261_null[@js "null"] | `L_s262_number[@js "number"] | `L_s279_regexp[@js "regexp"] | `L_s302_special[@js "special"] | `L_s308_string[@js "string"] | `L_s311_symbol[@js "symbol"] | `L_s322_undefined[@js "undefined"]] [@js.enum])
    and util_TextDecoder = [`Util_TextDecoder] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and util_TextEncoder = [`Util_TextEncoder] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_DefaultDeserializer = [`V8_DefaultDeserializer | `V8_Deserializer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_DefaultSerializer = [`V8_DefaultSerializer | `V8_Serializer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_Deserializer = [`V8_Deserializer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_DoesZapCodeSpaceFlag = ([`L_n_0[@js 0] | `L_n_1[@js 1]] [@js.enum])
    and v8_HeapCodeStatistics = [`V8_HeapCodeStatistics] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_HeapInfo = [`V8_HeapInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_HeapSpaceInfo = [`V8_HeapSpaceInfo] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and v8_Serializer = [`V8_Serializer] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_BaseOptions = [`Vm_BaseOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_CompileFunctionOptions = [`Vm_BaseOptions | `Vm_CompileFunctionOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_Context = [`NodeJS_Dict of any | `Vm_Context] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_CreateContextOptions = [`Vm_CreateContextOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_MeasureMemoryMode = ([`L_s203_detailed[@js "detailed"] | `L_s309_summary[@js "summary"]] [@js.enum])
    and vm_MeasureMemoryOptions = [`Vm_MeasureMemoryOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_MemoryMeasurement = [`Vm_MemoryMeasurement] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_RunningScriptOptions = [`Vm_BaseOptions | `Vm_RunningScriptOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_Script = [`Vm_Script] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and vm_ScriptOptions = [`Vm_BaseOptions | `Vm_ScriptOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and wasi_WASI = [`Wasi_WASI] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and wasi_WASIOptions = [`Wasi_WASIOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and worker_threads_MessageChannel = [`Worker_threads_MessageChannel] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and worker_threads_MessagePort = [`Worker_threads_MessagePort | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and worker_threads_ResourceLimits = [`Worker_threads_ResourceLimits] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and worker_threads_TransferListItem = (ArrayBuffer.t_0, FileHandle.t_0, worker_threads_MessagePort) union3
    and worker_threads_Worker = [`Worker_threads_Worker | EventEmitter.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and worker_threads_WorkerOptions = [`Worker_threads_WorkerOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_BrotliCompress = [`Zlib_BrotliCompress | `Zlib_Zlib | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_BrotliDecompress = [`Zlib_BrotliDecompress | `Zlib_Zlib | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_BrotliOptions = [`Zlib_BrotliOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_CompressCallback = [`Zlib_CompressCallback] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_Deflate = [`Zlib_Deflate | `Zlib_Zlib | `Zlib_ZlibParams | `Zlib_ZlibReset | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_DeflateRaw = [`Zlib_DeflateRaw | `Zlib_Zlib | `Zlib_ZlibParams | `Zlib_ZlibReset | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_Gunzip = [`Zlib_Gunzip | `Zlib_Zlib | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_Gzip = [`Zlib_Gzip | `Zlib_Zlib | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_Inflate = [`Zlib_Inflate | `Zlib_Zlib | `Zlib_ZlibReset | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_InflateRaw = [`Zlib_InflateRaw | `Zlib_Zlib | `Zlib_ZlibReset | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_InputType = (ArrayBuffer.t_0, _NodeJS_ArrayBufferView) union2 or_string
    and zlib_Unzip = [`Zlib_Unzip | `Zlib_Zlib | Stream.Transform.tags] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_Zlib = [`Zlib_Zlib] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_ZlibOptions = [`Zlib_ZlibOptions] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_ZlibParams = [`Zlib_ZlibParams] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
    and zlib_ZlibReset = [`Zlib_ZlibReset] intf
    [@@js.custom { of_js=Obj.magic; to_js=Obj.magic }]
  end
end

open Internal
open AnonymousInterfaces
open Types
module AnonymousInterface0 : sig
  type t = anonymous_interface_0
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module AnonymousInterface1 : sig
  type t = anonymous_interface_1
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_MAX_LENGTH: t -> float [@@js.get "MAX_LENGTH"]
  val set_MAX_LENGTH: t -> float -> unit [@@js.set "MAX_LENGTH"]
  val get_MAX_STRING_LENGTH: t -> float [@@js.get "MAX_STRING_LENGTH"]
  val set_MAX_STRING_LENGTH: t -> float -> unit [@@js.set "MAX_STRING_LENGTH"]
end
module AnonymousInterface2 : sig
  type t = anonymous_interface_2
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_asyncResource: t -> async_hooks_AsyncResource [@@js.get "asyncResource"]
  val set_asyncResource: t -> async_hooks_AsyncResource -> unit [@@js.set "asyncResource"]
end
module AnonymousInterface3 : sig
  type t = anonymous_interface_3
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bigint: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "bigint"]
  val set_bigint: t -> ([`L_b_false] [@js.enum]) -> unit [@@js.set "bigint"]
end
module AnonymousInterface4 : sig
  type t = anonymous_interface_4
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bigint: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "bigint"]
  val set_bigint: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "bigint"]
end
module AnonymousInterface5 : sig
  type t = anonymous_interface_5
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bytesRead: t -> float [@@js.get "bytesRead"]
  val set_bytesRead: t -> float -> unit [@@js.set "bytesRead"]
  val get_buffer: t -> 'TBuffer [@@js.get "buffer"]
  val set_buffer: t -> 'TBuffer -> unit [@@js.set "buffer"]
end
module AnonymousInterface6 : sig
  type t = anonymous_interface_6
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bytesWritten: t -> float [@@js.get "bytesWritten"]
  val set_bytesWritten: t -> float -> unit [@@js.set "bytesWritten"]
  val get_buffer: t -> 'TBuffer [@@js.get "buffer"]
  val set_buffer: t -> 'TBuffer -> unit [@@js.set "buffer"]
end
module AnonymousInterface7 : sig
  type t = anonymous_interface_7
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_bytesWritten: t -> float [@@js.get "bytesWritten"]
  val set_bytesWritten: t -> float -> unit [@@js.set "bytesWritten"]
  val get_buffer: t -> string [@@js.get "buffer"]
  val set_buffer: t -> string -> unit [@@js.set "buffer"]
end
module AnonymousInterface8 : sig
  type t = anonymous_interface_8
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_cflags: t -> any list [@@js.get "cflags"]
  val set_cflags: t -> any list -> unit [@@js.set "cflags"]
  val get_default_configuration: t -> string [@@js.get "default_configuration"]
  val set_default_configuration: t -> string -> unit [@@js.set "default_configuration"]
  val get_defines: t -> string list [@@js.get "defines"]
  val set_defines: t -> string list -> unit [@@js.set "defines"]
  val get_include_dirs: t -> string list [@@js.get "include_dirs"]
  val set_include_dirs: t -> string list -> unit [@@js.set "include_dirs"]
  val get_libraries: t -> string list [@@js.get "libraries"]
  val set_libraries: t -> string list -> unit [@@js.set "libraries"]
end
module AnonymousInterface9 : sig
  type t = anonymous_interface_9
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_chunk: t -> any [@@js.get "chunk"]
  val set_chunk: t -> any -> unit [@@js.set "chunk"]
  val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
end
module AnonymousInterface10 : sig
  type t = anonymous_interface_10
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_clang: t -> float [@@js.get "clang"]
  val set_clang: t -> float -> unit [@@js.set "clang"]
  val get_host_arch: t -> string [@@js.get "host_arch"]
  val set_host_arch: t -> string -> unit [@@js.set "host_arch"]
  val get_node_install_npm: t -> bool [@@js.get "node_install_npm"]
  val set_node_install_npm: t -> bool -> unit [@@js.set "node_install_npm"]
  val get_node_install_waf: t -> bool [@@js.get "node_install_waf"]
  val set_node_install_waf: t -> bool -> unit [@@js.set "node_install_waf"]
  val get_node_prefix: t -> string [@@js.get "node_prefix"]
  val set_node_prefix: t -> string -> unit [@@js.set "node_prefix"]
  val get_node_shared_openssl: t -> bool [@@js.get "node_shared_openssl"]
  val set_node_shared_openssl: t -> bool -> unit [@@js.set "node_shared_openssl"]
  val get_node_shared_v8: t -> bool [@@js.get "node_shared_v8"]
  val set_node_shared_v8: t -> bool -> unit [@@js.set "node_shared_v8"]
  val get_node_shared_zlib: t -> bool [@@js.get "node_shared_zlib"]
  val set_node_shared_zlib: t -> bool -> unit [@@js.set "node_shared_zlib"]
  val get_node_use_dtrace: t -> bool [@@js.get "node_use_dtrace"]
  val set_node_use_dtrace: t -> bool -> unit [@@js.set "node_use_dtrace"]
  val get_node_use_etw: t -> bool [@@js.get "node_use_etw"]
  val set_node_use_etw: t -> bool -> unit [@@js.set "node_use_etw"]
  val get_node_use_openssl: t -> bool [@@js.get "node_use_openssl"]
  val set_node_use_openssl: t -> bool -> unit [@@js.set "node_use_openssl"]
  val get_target_arch: t -> string [@@js.get "target_arch"]
  val set_target_arch: t -> string -> unit [@@js.set "target_arch"]
  val get_v8_no_strict_aliasing: t -> float [@@js.get "v8_no_strict_aliasing"]
  val set_v8_no_strict_aliasing: t -> float -> unit [@@js.set "v8_no_strict_aliasing"]
  val get_v8_use_snapshot: t -> bool [@@js.get "v8_use_snapshot"]
  val set_v8_use_snapshot: t -> bool -> unit [@@js.set "v8_use_snapshot"]
  val get_visibility: t -> string [@@js.get "visibility"]
  val set_visibility: t -> string -> unit [@@js.set "visibility"]
end
module AnonymousInterface11 : sig
  type t = anonymous_interface_11
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
end
module AnonymousInterface12 : sig
  type t = anonymous_interface_12
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
  val get_flag: t -> string [@@js.get "flag"]
  val set_flag: t -> string -> unit [@@js.set "flag"]
end
module AnonymousInterface13 : sig
  type t = anonymous_interface_13
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> never or_null [@@js.get "encoding"]
  val set_encoding: t -> never or_null -> unit [@@js.set "encoding"]
  val get_flag: t -> string [@@js.get "flag"]
  val set_flag: t -> string -> unit [@@js.set "flag"]
end
module AnonymousInterface14 : sig
  type t = anonymous_interface_14
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) [@@js.get "encoding"]
  val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) -> unit [@@js.set "encoding"]
end
module AnonymousInterface15 : sig
  type t = anonymous_interface_15
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) [@@js.get "encoding"]
  val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) -> unit [@@js.set "encoding"]
  val get_persistent: t -> bool [@@js.get "persistent"]
  val set_persistent: t -> bool -> unit [@@js.set "persistent"]
  val get_recursive: t -> bool [@@js.get "recursive"]
  val set_recursive: t -> bool -> unit [@@js.set "recursive"]
end
module AnonymousInterface16 : sig
  type t = anonymous_interface_16
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) [@@js.get "encoding"]
  val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) -> unit [@@js.set "encoding"]
  val get_withFileTypes: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "withFileTypes"]
  val set_withFileTypes: t -> ([`L_b_false] [@js.enum]) -> unit [@@js.set "withFileTypes"]
end
module AnonymousInterface17 : sig
  type t = anonymous_interface_17
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> _BufferEncoding or_null [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding or_null -> unit [@@js.set "encoding"]
  val get_persistent: t -> bool [@@js.get "persistent"]
  val set_persistent: t -> bool -> unit [@@js.set "persistent"]
  val get_recursive: t -> bool [@@js.get "recursive"]
  val set_recursive: t -> bool -> unit [@@js.set "recursive"]
end
module AnonymousInterface18 : sig
  type t = anonymous_interface_18
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> _BufferEncoding or_null [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding or_null -> unit [@@js.set "encoding"]
  val get_withFileTypes: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "withFileTypes"]
  val set_withFileTypes: t -> ([`L_b_false] [@js.enum]) -> unit [@@js.set "withFileTypes"]
end
module AnonymousInterface19 : sig
  type t = anonymous_interface_19
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) or_null [@@js.get "encoding"]
  val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) or_null -> unit [@@js.set "encoding"]
end
module AnonymousInterface20 : sig
  type t = anonymous_interface_20
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_end: t -> bool [@@js.get "end"]
  val set_end: t -> bool -> unit [@@js.set "end"]
end
module AnonymousInterface21 : sig
  type t = anonymous_interface_21
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_entryTypes: t -> perf_hooks_EntryType list [@@js.get "entryTypes"]
  val set_entryTypes: t -> perf_hooks_EntryType list -> unit [@@js.set "entryTypes"]
  val get_buffered: t -> bool [@@js.get "buffered"]
  val set_buffered: t -> bool -> unit [@@js.set "buffered"]
end
module AnonymousInterface22 : sig
  type t = anonymous_interface_22
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fatal: t -> bool [@@js.get "fatal"]
  val set_fatal: t -> bool -> unit [@@js.set "fatal"]
  val get_ignoreBOM: t -> bool [@@js.get "ignoreBOM"]
  val set_ignoreBOM: t -> bool -> unit [@@js.set "ignoreBOM"]
end
module AnonymousInterface23 : sig
  type t = anonymous_interface_23
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fd: t -> ([`L_n_0[@js 0]] [@js.enum]) [@@js.get "fd"]
  val set_fd: t -> ([`L_n_0] [@js.enum]) -> unit [@@js.set "fd"]
end
module AnonymousInterface24 : sig
  type t = anonymous_interface_24
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fd: t -> ([`L_n_1[@js 1]] [@js.enum]) [@@js.get "fd"]
  val set_fd: t -> ([`L_n_1] [@js.enum]) -> unit [@@js.set "fd"]
end
module AnonymousInterface25 : sig
  type t = anonymous_interface_25
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_fd: t -> ([`L_n_2[@js 2]] [@js.enum]) [@@js.get "fd"]
  val set_fd: t -> ([`L_n_2] [@js.enum]) -> unit [@@js.set "fd"]
end
module AnonymousInterface26 : sig
  type t = anonymous_interface_26
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_flag: t -> string [@@js.get "flag"]
  val set_flag: t -> string -> unit [@@js.set "flag"]
end
module AnonymousInterface27 : sig
  type t = anonymous_interface_27
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_flags: t -> string [@@js.get "flags"]
  val set_flags: t -> string -> unit [@@js.set "flags"]
  val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
  val get_fd: t -> float [@@js.get "fd"]
  val set_fd: t -> float -> unit [@@js.set "fd"]
  val get_mode: t -> float [@@js.get "mode"]
  val set_mode: t -> float -> unit [@@js.set "mode"]
  val get_autoClose: t -> bool [@@js.get "autoClose"]
  val set_autoClose: t -> bool -> unit [@@js.set "autoClose"]
  val get_emitClose: t -> bool [@@js.get "emitClose"]
  val set_emitClose: t -> bool -> unit [@@js.set "emitClose"]
  val get_start: t -> float [@@js.get "start"]
  val set_start: t -> float -> unit [@@js.set "start"]
  val get_highWaterMark: t -> float [@@js.get "highWaterMark"]
  val set_highWaterMark: t -> float -> unit [@@js.set "highWaterMark"]
end
module AnonymousInterface28 : sig
  type t = anonymous_interface_28
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_flags: t -> string [@@js.get "flags"]
  val set_flags: t -> string -> unit [@@js.set "flags"]
  val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
  val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
  val get_fd: t -> float [@@js.get "fd"]
  val set_fd: t -> float -> unit [@@js.set "fd"]
  val get_mode: t -> float [@@js.get "mode"]
  val set_mode: t -> float -> unit [@@js.set "mode"]
  val get_autoClose: t -> bool [@@js.get "autoClose"]
  val set_autoClose: t -> bool -> unit [@@js.set "autoClose"]
  (** default: false *)
  (** default: false *)
  val get_emitClose: t -> bool [@@js.get "emitClose"]
  (** default: false *)
  val set_emitClose: t -> bool -> unit [@@js.set "emitClose"]
  val get_start: t -> float [@@js.get "start"]
  val set_start: t -> float -> unit [@@js.set "start"]
  val get_end: t -> float [@@js.get "end"]
  val set_end: t -> float -> unit [@@js.set "end"]
  val get_highWaterMark: t -> float [@@js.get "highWaterMark"]
  val set_highWaterMark: t -> float -> unit [@@js.set "highWaterMark"]
end
module AnonymousInterface29 : sig
  type t = anonymous_interface_29
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_hostname: t -> string [@@js.get "hostname"]
  val set_hostname: t -> string -> unit [@@js.set "hostname"]
  val get_service: t -> string [@@js.get "service"]
  val set_service: t -> string -> unit [@@js.set "service"]
end
module AnonymousInterface30 : sig
  type t = anonymous_interface_30
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_inspector: t -> bool [@@js.get "inspector"]
  val set_inspector: t -> bool -> unit [@@js.set "inspector"]
  val get_debug: t -> bool [@@js.get "debug"]
  val set_debug: t -> bool -> unit [@@js.set "debug"]
  val get_uv: t -> bool [@@js.get "uv"]
  val set_uv: t -> bool -> unit [@@js.set "uv"]
  val get_ipv6: t -> bool [@@js.get "ipv6"]
  val set_ipv6: t -> bool -> unit [@@js.set "ipv6"]
  val get_tls_alpn: t -> bool [@@js.get "tls_alpn"]
  val set_tls_alpn: t -> bool -> unit [@@js.set "tls_alpn"]
  val get_tls_sni: t -> bool [@@js.get "tls_sni"]
  val set_tls_sni: t -> bool -> unit [@@js.set "tls_sni"]
  val get_tls_ocsp: t -> bool [@@js.get "tls_ocsp"]
  val set_tls_ocsp: t -> bool -> unit [@@js.set "tls_ocsp"]
  val get_tls: t -> bool [@@js.get "tls"]
  val set_tls: t -> bool -> unit [@@js.set "tls"]
end
module AnonymousInterface31 : sig
  type t = anonymous_interface_31
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_jsMemoryEstimate: t -> float [@@js.get "jsMemoryEstimate"]
  val set_jsMemoryEstimate: t -> float -> unit [@@js.set "jsMemoryEstimate"]
  val get_jsMemoryRange: t -> (float * float) [@@js.get "jsMemoryRange"]
  val set_jsMemoryRange: t -> (float * float) -> unit [@@js.set "jsMemoryRange"]
end
module AnonymousInterface32 : sig
  type t = anonymous_interface_32
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_message: t -> any [@@js.get "message"]
  val set_message: t -> any -> unit [@@js.set "message"]
end
module AnonymousInterface33 : sig
  type t = anonymous_interface_33
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_mode: t -> fs_Mode [@@js.get "mode"]
  val set_mode: t -> fs_Mode -> unit [@@js.set "mode"]
  val get_flag: t -> string [@@js.get "flag"]
  val set_flag: t -> string -> unit [@@js.set "flag"]
end
module AnonymousInterface34 : sig
  type t = anonymous_interface_34
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_once: t -> bool [@@js.get "once"]
  val set_once: t -> bool -> unit [@@js.set "once"]
end
module AnonymousInterface35 : sig
  type t = anonymous_interface_35
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_options: t -> InspectOptions.t_0 [@@js.get "options"]
  val set_options: t -> InspectOptions.t_0 -> unit [@@js.set "options"]
end
module AnonymousInterface36 : sig
  type t = anonymous_interface_36
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_origin: t -> string [@@js.get "origin"]
  val set_origin: t -> string -> unit [@@js.set "origin"]
end
module AnonymousInterface37 : sig
  type t = anonymous_interface_37
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_paths: t -> string list [@@js.get "paths"]
  val set_paths: t -> string list -> unit [@@js.set "paths"]
end
module AnonymousInterface38 : sig
  type t = anonymous_interface_38
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_persistent: t -> bool [@@js.get "persistent"]
  val set_persistent: t -> bool -> unit [@@js.set "persistent"]
  val get_interval: t -> float [@@js.get "interval"]
  val set_interval: t -> float -> unit [@@js.set "interval"]
end
module AnonymousInterface39 : sig
  type t = anonymous_interface_39
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_plaintextLength: t -> float [@@js.get "plaintextLength"]
  val set_plaintextLength: t -> float -> unit [@@js.set "plaintextLength"]
end
module AnonymousInterface40 : sig
  type t = anonymous_interface_40
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_privateKey: t -> crypto_KeyObject [@@js.get "privateKey"]
  val set_privateKey: t -> crypto_KeyObject -> unit [@@js.set "privateKey"]
  val get_publicKey: t -> crypto_KeyObject [@@js.get "publicKey"]
  val set_publicKey: t -> crypto_KeyObject -> unit [@@js.set "publicKey"]
end
module AnonymousInterface41 : sig
  type t = anonymous_interface_41
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_publicKey: t -> _Buffer [@@js.get "publicKey"]
  val set_publicKey: t -> _Buffer -> unit [@@js.set "publicKey"]
  val get_privateKey: t -> _Buffer [@@js.get "privateKey"]
  val set_privateKey: t -> _Buffer -> unit [@@js.set "privateKey"]
end
module AnonymousInterface42 : sig
  type t = anonymous_interface_42
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_publicKey: t -> _Buffer [@@js.get "publicKey"]
  val set_publicKey: t -> _Buffer -> unit [@@js.set "publicKey"]
  val get_privateKey: t -> string [@@js.get "privateKey"]
  val set_privateKey: t -> string -> unit [@@js.set "privateKey"]
end
module AnonymousInterface43 : sig
  type t = anonymous_interface_43
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_publicKey: t -> string [@@js.get "publicKey"]
  val set_publicKey: t -> string -> unit [@@js.set "publicKey"]
  val get_privateKey: t -> _Buffer [@@js.get "privateKey"]
  val set_privateKey: t -> _Buffer -> unit [@@js.set "privateKey"]
end
module AnonymousInterface44 : sig
  type t = anonymous_interface_44
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_publicKey: t -> string [@@js.get "publicKey"]
  val set_publicKey: t -> string -> unit [@@js.set "publicKey"]
  val get_privateKey: t -> string [@@js.get "privateKey"]
  val set_privateKey: t -> string -> unit [@@js.set "privateKey"]
end
module AnonymousInterface45 : sig
  type t = anonymous_interface_45
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_recursive: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "recursive"]
  val set_recursive: t -> ([`L_b_false] [@js.enum]) -> unit [@@js.set "recursive"]
end
module AnonymousInterface46 : sig
  type t = anonymous_interface_46
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_recursive: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "recursive"]
  val set_recursive: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "recursive"]
end
module AnonymousInterface47 : sig
  type t = anonymous_interface_47
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_rejectUnauthorized: t -> bool [@@js.get "rejectUnauthorized"]
  val set_rejectUnauthorized: t -> bool -> unit [@@js.set "rejectUnauthorized"]
  val get_requestCert: t -> bool [@@js.get "requestCert"]
  val set_requestCert: t -> bool -> unit [@@js.set "requestCert"]
end
module AnonymousInterface48 : sig
  type t = anonymous_interface_48
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_rejectUnauthorized: t -> bool [@@js.get "rejectUnauthorized"]
  val set_rejectUnauthorized: t -> bool -> unit [@@js.set "rejectUnauthorized"]
  val get_servername: t -> string [@@js.get "servername"]
  val set_servername: t -> string -> unit [@@js.set "servername"]
end
module AnonymousInterface49 : sig
  type t = anonymous_interface_49
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_stdout: t -> _Buffer [@@js.get "stdout"]
  val set_stdout: t -> _Buffer -> unit [@@js.set "stdout"]
  val get_stderr: t -> _Buffer [@@js.get "stderr"]
  val set_stderr: t -> _Buffer -> unit [@@js.set "stderr"]
end
module AnonymousInterface50 : sig
  type t = anonymous_interface_50
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_stdout: t -> string [@@js.get "stdout"]
  val set_stdout: t -> string -> unit [@@js.set "stdout"]
  val get_stderr: t -> string [@@js.get "stderr"]
  val set_stderr: t -> string -> unit [@@js.set "stderr"]
end
module AnonymousInterface51 : sig
  type t = anonymous_interface_51
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_stdout: t -> _Buffer or_string [@@js.get "stdout"]
  val set_stdout: t -> _Buffer or_string -> unit [@@js.set "stdout"]
  val get_stderr: t -> _Buffer or_string [@@js.get "stderr"]
  val set_stderr: t -> _Buffer or_string -> unit [@@js.set "stderr"]
end
module AnonymousInterface52 : sig
  type t = anonymous_interface_52
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_stream: t -> bool [@@js.get "stream"]
  val set_stream: t -> bool -> unit [@@js.set "stream"]
end
module AnonymousInterface53 : sig
  type t = anonymous_interface_53
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_swallowErrors: t -> bool [@@js.get "swallowErrors"]
  val set_swallowErrors: t -> bool -> unit [@@js.set "swallowErrors"]
end
module AnonymousInterface54 : sig
  type t = anonymous_interface_54
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_target_defaults: t -> anonymous_interface_8 [@@js.get "target_defaults"]
  val set_target_defaults: t -> anonymous_interface_8 -> unit [@@js.set "target_defaults"]
  val get_variables: t -> anonymous_interface_10 [@@js.get "variables"]
  val set_variables: t -> anonymous_interface_10 -> unit [@@js.set "variables"]
end
module AnonymousInterface55 : sig
  type t = anonymous_interface_55
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: t -> ([`L_s5_Buffer[@js "Buffer"]] [@js.enum]) [@@js.get "type"]
  val set_type: t -> ([`L_s5_Buffer] [@js.enum]) -> unit [@@js.set "type"]
  val get_data: t -> float list [@@js.get "data"]
  val set_data: t -> float list -> unit [@@js.set "data"]
end
module AnonymousInterface56 : sig
  type t = anonymous_interface_56
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: t -> ([`L_s273_pkcs8[@js "pkcs8"]] [@js.enum]) [@@js.get "type"]
  val set_type: t -> ([`L_s273_pkcs8] [@js.enum]) -> unit [@@js.set "type"]
end
module AnonymousInterface57 : sig
  type t = anonymous_interface_57
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: t -> ([`L_s303_spki[@js "spki"]] [@js.enum]) [@@js.get "type"]
  val set_type: t -> ([`L_s303_spki] [@js.enum]) -> unit [@@js.set "type"]
  val get_format: t -> 'PubF [@@js.get "format"]
  val set_format: t -> 'PubF -> unit [@@js.set "format"]
end
module AnonymousInterface58 : sig
  type t = anonymous_interface_58
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: t -> ([`L_s272_pkcs1[@js "pkcs1"] | `L_s273_pkcs8[@js "pkcs8"]] [@js.enum]) [@@js.get "type"]
  val set_type: t -> ([`L_s272_pkcs1 | `L_s273_pkcs8] [@js.enum]) -> unit [@@js.set "type"]
end
module AnonymousInterface59 : sig
  type t = anonymous_interface_59
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: t -> ([`L_s272_pkcs1[@js "pkcs1"] | `L_s303_spki[@js "spki"]] [@js.enum]) [@@js.get "type"]
  val set_type: t -> ([`L_s272_pkcs1 | `L_s303_spki] [@js.enum]) -> unit [@@js.set "type"]
  val get_format: t -> 'PubF [@@js.get "format"]
  val set_format: t -> 'PubF -> unit [@@js.set "format"]
end
module AnonymousInterface60 : sig
  type t = anonymous_interface_60
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_type: t -> ([`L_s273_pkcs8[@js "pkcs8"] | `L_s293_sec1[@js "sec1"]] [@js.enum]) [@@js.get "type"]
  val set_type: t -> ([`L_s273_pkcs8 | `L_s293_sec1] [@js.enum]) -> unit [@@js.set "type"]
end
module AnonymousInterface61 : sig
  type t = anonymous_interface_61
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_user: t -> float [@@js.get "user"]
  val set_user: t -> float -> unit [@@js.set "user"]
  val get_nice: t -> float [@@js.get "nice"]
  val set_nice: t -> float -> unit [@@js.set "nice"]
  val get_sys: t -> float [@@js.get "sys"]
  val set_sys: t -> float -> unit [@@js.set "sys"]
  val get_idle: t -> float [@@js.get "idle"]
  val set_idle: t -> float -> unit [@@js.set "idle"]
  val get_irq: t -> float [@@js.get "irq"]
  val set_irq: t -> float -> unit [@@js.set "irq"]
end
module AnonymousInterface62 : sig
  type t = anonymous_interface_62
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_withFileTypes: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "withFileTypes"]
  val set_withFileTypes: t -> ([`L_b_false] [@js.enum]) -> unit [@@js.set "withFileTypes"]
end
module AnonymousInterface63 : sig
  type t = anonymous_interface_63
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_withFileTypes: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "withFileTypes"]
  val set_withFileTypes: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "withFileTypes"]
end
module AnonymousInterface64 : sig
  type t = anonymous_interface_64
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val _Symbol_toPrimitive_: t -> hint:([`L_s308_string] [@js.enum]) -> string [@@js.call "[Symbol.toPrimitive]"]
end
module AnonymousInterface65 : sig
  type t = anonymous_interface_65
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val valueOf: t -> 'T [@@js.call "valueOf"]
end
module AnonymousInterface66 : sig
  type t = anonymous_interface_66
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: t -> actual:any -> expected:'T -> ?message:Error.t_0 or_string -> unit -> bool [@@js.apply]
end
module AnonymousInterface67 : sig
  type t = anonymous_interface_67
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: t -> value:any -> ?message:Error.t_0 or_string -> unit -> bool [@@js.apply]
  val get_equal: t -> anonymous_interface_66 [@@js.get "equal"]
  val set_equal: t -> anonymous_interface_66 -> unit [@@js.set "equal"]
  val notEqual: t -> actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.call "notEqual"]
  val get_deepEqual: t -> anonymous_interface_66 [@@js.get "deepEqual"]
  val set_deepEqual: t -> anonymous_interface_66 -> unit [@@js.set "deepEqual"]
  val notDeepEqual: t -> actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.call "notDeepEqual"]
  val ok: t -> value:any -> ?message:Error.t_0 or_string -> unit -> bool [@@js.call "ok"]
  val get_strictEqual: t -> anonymous_interface_66 [@@js.get "strictEqual"]
  val set_strictEqual: t -> anonymous_interface_66 -> unit [@@js.set "strictEqual"]
  val get_deepStrictEqual: t -> anonymous_interface_66 [@@js.get "deepStrictEqual"]
  val set_deepStrictEqual: t -> anonymous_interface_66 -> unit [@@js.set "deepStrictEqual"]
  val ifError: t -> value:any -> bool [@@js.call "ifError"]
  val get_strict: t -> (((value:any -> ?message:Error.t_0 or_string -> unit -> bool), ([`L_s200_deepEqual[@js "deepEqual"] | `L_s201_deepStrictEqual[@js "deepStrictEqual"] | `L_s212_equal[@js "equal"] | `L_s233_ifError[@js "ifError"] | `L_s259_notDeepEqual[@js "notDeepEqual"] | `L_s260_notEqual[@js "notEqual"] | `L_s263_ok[@js "ok"] | `L_s306_strict[@js "strict"] | `L_s307_strictEqual[@js "strictEqual"]] [@js.enum])) Omit.t_2, anonymous_interface_68) intersection2 [@@js.get "strict"]
  val set_strict: t -> (((value:any -> ?message:Error.t_0 or_string -> unit -> bool), ([`L_s200_deepEqual | `L_s201_deepStrictEqual | `L_s212_equal | `L_s233_ifError | `L_s259_notDeepEqual | `L_s260_notEqual | `L_s263_ok | `L_s306_strict | `L_s307_strictEqual] [@js.enum])) Omit.t_2, anonymous_interface_68) intersection2 -> unit [@@js.set "strict"]
end
module AnonymousInterface68 : sig
  type t = anonymous_interface_68
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val apply: t -> value:any -> ?message:Error.t_0 or_string -> unit -> bool [@@js.apply]
  val get_equal: t -> anonymous_interface_66 [@@js.get "equal"]
  val set_equal: t -> anonymous_interface_66 -> unit [@@js.set "equal"]
  val notEqual: t -> actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.call "notEqual"]
  val get_deepEqual: t -> anonymous_interface_66 [@@js.get "deepEqual"]
  val set_deepEqual: t -> anonymous_interface_66 -> unit [@@js.set "deepEqual"]
  val notDeepEqual: t -> actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.call "notDeepEqual"]
  val ok: t -> value:any -> ?message:Error.t_0 or_string -> unit -> bool [@@js.call "ok"]
  val get_strictEqual: t -> anonymous_interface_66 [@@js.get "strictEqual"]
  val set_strictEqual: t -> anonymous_interface_66 -> unit [@@js.set "strictEqual"]
  val get_deepStrictEqual: t -> anonymous_interface_66 [@@js.get "deepStrictEqual"]
  val set_deepStrictEqual: t -> anonymous_interface_66 -> unit [@@js.set "deepStrictEqual"]
  val ifError: t -> value:any -> bool [@@js.call "ifError"]
  val get_strict: t -> (* FIXME: unknown type 'typeof strict' *)any [@@js.get "strict"]
  val set_strict: t -> (* FIXME: unknown type 'typeof strict' *)any -> unit [@@js.set "strict"]
end
module AnonymousInterface69 : sig
  type t = anonymous_interface_69
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get: t -> float -> string or_undefined [@@js.index_get]
  val set: t -> float -> string or_undefined -> unit [@@js.index_set]
  val get': t -> string -> string or_undefined [@@js.index_get]
  val set': t -> string -> string or_undefined -> unit [@@js.index_set]
end
module AnonymousInterface70 : sig
  type t = anonymous_interface_70
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val create: t -> untyped_object [@@js.apply_newable]
end
module AnonymousInterface71 : sig
  type t = anonymous_interface_71
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (** If provided, the error message is set to this value. *)
  (** If provided, the error message is set to this value. *)
  val get_message: t -> string [@@js.get "message"]
  (** If provided, the error message is set to this value. *)
  val set_message: t -> string -> unit [@@js.set "message"]
  (** The `actual` property on the error instance. *)
  (** The `actual` property on the error instance. *)
  val get_actual: t -> any [@@js.get "actual"]
  (** The `actual` property on the error instance. *)
  val set_actual: t -> any -> unit [@@js.set "actual"]
  (** The `expected` property on the error instance. *)
  (** The `expected` property on the error instance. *)
  val get_expected: t -> any [@@js.get "expected"]
  (** The `expected` property on the error instance. *)
  val set_expected: t -> any -> unit [@@js.set "expected"]
  (** The `operator` property on the error instance. *)
  (** The `operator` property on the error instance. *)
  val get_operator: t -> string [@@js.get "operator"]
  (** The `operator` property on the error instance. *)
  val set_operator: t -> string -> unit [@@js.set "operator"]
  (** If provided, the generated stack trace omits frames before this function. *)
  (** If provided, the generated stack trace omits frames before this function. *)
  val get_stackStartFn: t -> untyped_function [@@js.get "stackStartFn"]
  (** If provided, the generated stack trace omits frames before this function. *)
  val set_stackStartFn: t -> untyped_function -> unit [@@js.set "stackStartFn"]
end
module AnonymousInterface72 : sig
  type t = anonymous_interface_72
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (** Each key is a `constants.BROTLI_*` constant. *)
  (** Each key is a `constants.BROTLI_*` constant. *)
  val get: t -> float -> bool or_number [@@js.index_get]
  (** Each key is a `constants.BROTLI_*` constant. *)
  val set: t -> float -> bool or_number -> unit [@@js.index_set]
end
module AnonymousInterface73 : sig
  type t = anonymous_interface_73
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (** @deprecated since v14.9.0 - Use static methods of `crypto.Certificate` instead. *)
  val create: t -> crypto_Certificate [@@js.apply_newable]
  (** @deprecated since v14.9.0 - Use static methods of `crypto.Certificate` instead. *)
  val apply: t -> crypto_Certificate [@@js.apply]
end
module AnonymousInterface74 : sig
  type t = anonymous_interface_74
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (** @deprecated since v6.0.0, use `Buffer.allocUnsafeSlow()` *)
  val create: t -> size:float -> _Buffer [@@js.apply_newable]
  val get_prototype: t -> _Buffer [@@js.get "prototype"]
  val set_prototype: t -> _Buffer -> unit [@@js.set "prototype"]
end
module AnonymousInterface75 : sig
  type t = anonymous_interface_75
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (**
    If set to false any calls to eval or function constructors (Function, GeneratorFunction, etc)
    will throw an EvalError.
    default: true
  *)
  (**
    If set to false any calls to eval or function constructors (Function, GeneratorFunction, etc)
    will throw an EvalError.
    default: true
  *)
  val get_strings: t -> bool [@@js.get "strings"]
  (**
    If set to false any calls to eval or function constructors (Function, GeneratorFunction, etc)
    will throw an EvalError.
    default: true
  *)
  val set_strings: t -> bool -> unit [@@js.set "strings"]
  (**
    If set to false any attempt to compile a WebAssembly module will throw a WebAssembly.CompileError.
    default: true
  *)
  (**
    If set to false any attempt to compile a WebAssembly module will throw a WebAssembly.CompileError.
    default: true
  *)
  val get_wasm: t -> bool [@@js.get "wasm"]
  (**
    If set to false any attempt to compile a WebAssembly module will throw a WebAssembly.CompileError.
    default: true
  *)
  val set_wasm: t -> bool -> unit [@@js.set "wasm"]
end
module Node_assert : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = assert
    clause = NamespaceImport ([object Object])
    loc = line 2, col 5 of node_modules/@types/node/assert.d.ts } *)
  (* CommonJsExport ({ name = [assert]
    fullName = [assert]
    loc = line 3, col 14 of node_modules/@types/node/assert.d.ts }) *)
end
module[@js.scope "assert"] Assert : sig
  (** An alias of `assert.ok()`. *)
  val assert_: value:any -> ?message:Error.t_0 or_string -> unit -> bool [@@js.global "assert"]
  module[@js.scope "assert"] Assert : sig
    module[@js.scope "AssertionError"] AssertionError : sig
      type t = assert_assert_AssertionError
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_actual: t -> any [@@js.get "actual"]
      val set_actual: t -> any -> unit [@@js.set "actual"]
      val get_expected: t -> any [@@js.get "expected"]
      val set_expected: t -> any -> unit [@@js.set "expected"]
      val get_operator: t -> string [@@js.get "operator"]
      val set_operator: t -> string -> unit [@@js.set "operator"]
      val get_generatedMessage: t -> bool [@@js.get "generatedMessage"]
      val set_generatedMessage: t -> bool -> unit [@@js.set "generatedMessage"]
      val get_code: t -> ([`L_s44_ERR_ASSERTION[@js "ERR_ASSERTION"]] [@js.enum]) [@@js.get "code"]
      val set_code: t -> ([`L_s44_ERR_ASSERTION] [@js.enum]) -> unit [@@js.set "code"]
      val create: ?options:anonymous_interface_71 -> unit -> t [@@js.create]
      val cast: t -> Error.t_0 [@@js.cast]
    end
    module[@js.scope "CallTracker"] CallTracker : sig
      type t = assert_assert_CallTracker
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val calls: t -> ?exact:float -> unit -> (unit -> unit [@js.dummy]) [@@js.call "calls"]
      val calls': t -> ?fn:'Func -> ?exact:float -> unit -> 'Func [@@js.call "calls"]
      val report: t -> assert_assert_CallTrackerReportInformation list [@@js.call "report"]
      val verify: t -> unit [@@js.call "verify"]
    end
    module[@js.scope "CallTrackerReportInformation"] CallTrackerReportInformation : sig
      type t = assert_assert_CallTrackerReportInformation
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_message: t -> string [@@js.get "message"]
      val set_message: t -> string -> unit [@@js.set "message"]
      (** The actual number of times the function was called. *)
      (** The actual number of times the function was called. *)
      val get_actual: t -> float [@@js.get "actual"]
      (** The actual number of times the function was called. *)
      val set_actual: t -> float -> unit [@@js.set "actual"]
      (** The number of times the function was expected to be called. *)
      (** The number of times the function was expected to be called. *)
      val get_expected: t -> float [@@js.get "expected"]
      (** The number of times the function was expected to be called. *)
      val set_expected: t -> float -> unit [@@js.set "expected"]
      (** The name of the function that is wrapped. *)
      (** The name of the function that is wrapped. *)
      val get_operator: t -> string [@@js.get "operator"]
      (** The name of the function that is wrapped. *)
      val set_operator: t -> string -> unit [@@js.set "operator"]
      (** A stack trace of the function. *)
      (** A stack trace of the function. *)
      val get_stack: t -> untyped_object [@@js.get "stack"]
      (** A stack trace of the function. *)
      val set_stack: t -> untyped_object -> unit [@@js.set "stack"]
    end
    module AssertPredicate : sig
      type t = assert_assert_AssertPredicate
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    val fail: ?message:Error.t_0 or_string -> unit -> never [@@js.global "fail"]
    (** @deprecated since v10.0.0 - use fail(\[message\]) or other assert functions instead. *)
    val fail: actual:any -> expected:any -> ?message:Error.t_0 or_string -> ?operator:string -> ?stackStartFn:untyped_function -> unit -> never [@@js.global "fail"]
    val ok: value:any -> ?message:Error.t_0 or_string -> unit -> bool [@@js.global "ok"]
    (** @deprecated since v9.9.0 - use strictEqual() instead. *)
    val equal: actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "equal"]
    (** @deprecated since v9.9.0 - use notStrictEqual() instead. *)
    val notEqual: actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "notEqual"]
    (** @deprecated since v9.9.0 - use deepStrictEqual() instead. *)
    val deepEqual: actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "deepEqual"]
    (** @deprecated since v9.9.0 - use notDeepStrictEqual() instead. *)
    val notDeepEqual: actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "notDeepEqual"]
    val strictEqual: actual:any -> expected:'T -> ?message:Error.t_0 or_string -> unit -> bool [@@js.global "strictEqual"]
    val notStrictEqual: actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "notStrictEqual"]
    val deepStrictEqual: actual:any -> expected:'T -> ?message:Error.t_0 or_string -> unit -> bool [@@js.global "deepStrictEqual"]
    val notDeepStrictEqual: actual:any -> expected:any -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "notDeepStrictEqual"]
    val throws: block:(unit -> any) -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "throws"]
    val throws: block:(unit -> any) -> error:assert_assert_AssertPredicate -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "throws"]
    val doesNotThrow: block:(unit -> any) -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "doesNotThrow"]
    val doesNotThrow: block:(unit -> any) -> error:assert_assert_AssertPredicate -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "doesNotThrow"]
    val ifError: value:any -> bool [@@js.global "ifError"]
    val rejects: block:((unit -> any Promise.t_1), any Promise.t_1) union2 -> ?message:Error.t_0 or_string -> unit -> unit Promise.t_1 [@@js.global "rejects"]
    val rejects: block:((unit -> any Promise.t_1), any Promise.t_1) union2 -> error:assert_assert_AssertPredicate -> ?message:Error.t_0 or_string -> unit -> unit Promise.t_1 [@@js.global "rejects"]
    val doesNotReject: block:((unit -> any Promise.t_1), any Promise.t_1) union2 -> ?message:Error.t_0 or_string -> unit -> unit Promise.t_1 [@@js.global "doesNotReject"]
    val doesNotReject: block:((unit -> any Promise.t_1), any Promise.t_1) union2 -> error:assert_assert_AssertPredicate -> ?message:Error.t_0 or_string -> unit -> unit Promise.t_1 [@@js.global "doesNotReject"]
    val match_: value:string -> regExp:regexp -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "match"]
    val doesNotMatch: value:string -> regExp:regexp -> ?message:Error.t_0 or_string -> unit -> unit [@@js.global "doesNotMatch"]
    val strict: (((value:any -> ?message:Error.t_0 or_string -> unit -> bool), ([`L_s200_deepEqual[@js "deepEqual"] | `L_s201_deepStrictEqual[@js "deepStrictEqual"] | `L_s212_equal[@js "equal"] | `L_s233_ifError[@js "ifError"] | `L_s259_notDeepEqual[@js "notDeepEqual"] | `L_s260_notEqual[@js "notEqual"] | `L_s263_ok[@js "ok"] | `L_s306_strict[@js "strict"] | `L_s307_strictEqual[@js "strictEqual"]] [@js.enum])) Omit.t_2, anonymous_interface_67) intersection2 [@@js.global "strict"]
  end
  (* CommonJsExport ({ name = [assert]
    fullName = [assert; assert]
    loc = line 128, col 14 of node_modules/@types/node/assert.d.ts }) *)
end
(** Async Hooks module: https://nodejs.org/api/async_hooks.html *)
module Node_async_hooks : sig
  (* export * from 'async_hooks'; *)
end
(** Async Hooks module: https://nodejs.org/api/async_hooks.html *)
module[@js.scope "async_hooks"] Async_hooks : sig
  (** Returns the asyncId of the current execution context. *)
  val executionAsyncId: unit -> float [@@js.global "executionAsyncId"]
  (**
    The resource representing the current execution.
     Useful to store data within the resource.
    
    Resource objects returned by `executionAsyncResource()` are most often internal
    Node.js handle objects with undocumented APIs. Using any functions or properties
    on the object is likely to crash your application and should be avoided.
    
    Using `executionAsyncResource()` in the top-level execution context will
    return an empty object as there is no handle or request object to use,
    but having an object representing the top-level can be helpful.
  *)
  val executionAsyncResource: unit -> untyped_object [@@js.global "executionAsyncResource"]
  (** Returns the ID of the resource responsible for calling the callback that is currently being executed. *)
  val triggerAsyncId: unit -> float [@@js.global "triggerAsyncId"]
  module[@js.scope "HookCallbacks"] HookCallbacks : sig
    type t = async_hooks_HookCallbacks
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Called when a class is constructed that has the possibility to emit an asynchronous event.
      @param asyncId a unique ID for the async resource
      @param type the type of the async resource
      @param triggerAsyncId the unique ID of the async resource in whose execution context this async resource was created
      @param resource reference to the resource representing the async operation, needs to be released during destroy
    *)
    val init: t -> asyncId:float -> type_:string -> triggerAsyncId:float -> resource:untyped_object -> unit [@@js.call "init"]
    (**
      When an asynchronous operation is initiated or completes a callback is called to notify the user.
      The before callback is called just before said callback is executed.
      @param asyncId the unique identifier assigned to the resource about to execute the callback.
    *)
    val before: t -> asyncId:float -> unit [@@js.call "before"]
    (**
      Called immediately after the callback specified in before is completed.
      @param asyncId the unique identifier assigned to the resource which has executed the callback.
    *)
    val after: t -> asyncId:float -> unit [@@js.call "after"]
    (**
      Called when a promise has resolve() called. This may not be in the same execution id
      as the promise itself.
      @param asyncId the unique id for the promise that was resolve()d.
    *)
    val promiseResolve: t -> asyncId:float -> unit [@@js.call "promiseResolve"]
    (**
      Called after the resource corresponding to asyncId is destroyed
      @param asyncId a unique ID for the async resource
    *)
    val destroy: t -> asyncId:float -> unit [@@js.call "destroy"]
  end
  module[@js.scope "AsyncHook"] AsyncHook : sig
    type t = async_hooks_AsyncHook
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop. *)
    val enable: t -> t [@@js.call "enable"]
    (** Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled. *)
    val disable: t -> t [@@js.call "disable"]
  end
  (**
    Registers functions to be called for different lifetime events of each async operation.
    @param options the callbacks to register
    @return an AsyncHooks instance used for disabling and enabling hooks
  *)
  val createHook: options:async_hooks_HookCallbacks -> async_hooks_AsyncHook [@@js.global "createHook"]
  module[@js.scope "AsyncResourceOptions"] AsyncResourceOptions : sig
    type t = async_hooks_AsyncResourceOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      The ID of the execution context that created this async event.
      Default: `executionAsyncId()`
    *)
    (**
      The ID of the execution context that created this async event.
      Default: `executionAsyncId()`
    *)
    val get_triggerAsyncId: t -> float [@@js.get "triggerAsyncId"]
    (**
      The ID of the execution context that created this async event.
      Default: `executionAsyncId()`
    *)
    val set_triggerAsyncId: t -> float -> unit [@@js.set "triggerAsyncId"]
    (**
      Disables automatic `emitDestroy` when the object is garbage collected.
      This usually does not need to be set (even if `emitDestroy` is called
      manually), unless the resource's `asyncId` is retrieved and the
      sensitive API's `emitDestroy` is called with it.
      Default: `false`
    *)
    (**
      Disables automatic `emitDestroy` when the object is garbage collected.
      This usually does not need to be set (even if `emitDestroy` is called
      manually), unless the resource's `asyncId` is retrieved and the
      sensitive API's `emitDestroy` is called with it.
      Default: `false`
    *)
    val get_requireManualDestroy: t -> bool [@@js.get "requireManualDestroy"]
    (**
      Disables automatic `emitDestroy` when the object is garbage collected.
      This usually does not need to be set (even if `emitDestroy` is called
      manually), unless the resource's `asyncId` is retrieved and the
      sensitive API's `emitDestroy` is called with it.
      Default: `false`
    *)
    val set_requireManualDestroy: t -> bool -> unit [@@js.set "requireManualDestroy"]
  end
  (**
    The class AsyncResource was designed to be extended by the embedder's async resources.
    Using this users can easily trigger the lifetime events of their own resources.
  *)
  module[@js.scope "AsyncResource"] AsyncResource : sig
    type t = async_hooks_AsyncResource
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      AsyncResource() is meant to be extended. Instantiating a
      new AsyncResource() also triggers init. If triggerAsyncId is omitted then
      async_hook.executionAsyncId() is used.
      @param type The type of async event.
      @param triggerAsyncId The ID of the execution context that created
      this async event (default: `executionAsyncId()`), or an
      AsyncResourceOptions object (since 9.3)
    *)
    val create: type_:string -> ?triggerAsyncId:async_hooks_AsyncResourceOptions or_number -> unit -> t [@@js.create]
    (**
      Binds the given function to the current execution context.
      @param fn The function to bind to the current execution context.
      @param type An optional name to associate with the underlying `AsyncResource`.
    *)
    val bind: fn:'Func -> ?type_:string -> unit -> ('Func, anonymous_interface_2) intersection2 [@@js.global "bind"]
    (**
      Binds the given function to execute to this `AsyncResource`'s scope.
      @param fn The function to bind to the current `AsyncResource`.
    *)
    val bind': t -> fn:'Func -> ('Func, anonymous_interface_2) intersection2 [@@js.call "bind"]
    (**
      Call the provided function with the provided arguments in the
      execution context of the async resource. This will establish the
      context, trigger the AsyncHooks before callbacks, call the function,
      trigger the AsyncHooks after callbacks, and then restore the original
      execution context.
      @param fn The function to call in the execution context of this
      async resource.
      @param thisArg The receiver to be used for the function call.
      @param args Optional arguments to pass to the function.
    *)
    val runInAsyncScope: t -> fn:(this:'This -> args:(any list [@js.variadic]) -> 'Result) -> ?thisArg:'This -> args:(any list [@js.variadic]) -> 'Result [@@js.call "runInAsyncScope"]
    (** Call AsyncHooks destroy callbacks. *)
    val emitDestroy: t -> t [@@js.call "emitDestroy"]
    (** @return the unique ID assigned to this AsyncResource instance. *)
    val asyncId: t -> float [@@js.call "asyncId"]
    (** @return the trigger ID for this AsyncResource instance. *)
    val triggerAsyncId: t -> float [@@js.call "triggerAsyncId"]
  end
  (**
    When having multiple instances of `AsyncLocalStorage`, they are independent
    from each other. It is safe to instantiate this class multiple times.
  *)
  module[@js.scope "AsyncLocalStorage"] AsyncLocalStorage : sig
    type 'T t = 'T async_hooks_AsyncLocalStorage
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    (**
      This method disables the instance of `AsyncLocalStorage`. All subsequent calls
      to `asyncLocalStorage.getStore()` will return `undefined` until
      `asyncLocalStorage.run()` is called again.
      
      When calling `asyncLocalStorage.disable()`, all current contexts linked to the
      instance will be exited.
      
      Calling `asyncLocalStorage.disable()` is required before the
      `asyncLocalStorage` can be garbage collected. This does not apply to stores
      provided by the `asyncLocalStorage`, as those objects are garbage collected
      along with the corresponding async resources.
      
      This method is to be used when the `asyncLocalStorage` is not in use anymore
      in the current process.
    *)
    val disable: 'T t -> unit [@@js.call "disable"]
    (**
      This method returns the current store. If this method is called outside of an
      asynchronous context initialized by calling `asyncLocalStorage.run`, it will
      return `undefined`.
    *)
    val getStore: 'T t -> 'T or_undefined [@@js.call "getStore"]
    (**
      This methods runs a function synchronously within a context and return its
      return value. The store is not accessible outside of the callback function or
      the asynchronous operations created within the callback.
      
      Optionally, arguments can be passed to the function. They will be passed to the
      callback function.
      
      I the callback function throws an error, it will be thrown by `run` too. The
      stacktrace will not be impacted by this call and the context will be exited.
    *)
    val run: 'T t -> store:'T -> callback:(args:(any list [@js.variadic]) -> 'R) -> args:(any list [@js.variadic]) -> 'R [@@js.call "run"]
    (**
      This methods runs a function synchronously outside of a context and return its
      return value. The store is not accessible within the callback function or the
      asynchronous operations created within the callback.
      
      Optionally, arguments can be passed to the function. They will be passed to the
      callback function.
      
      If the callback function throws an error, it will be thrown by `exit` too. The
      stacktrace will not be impacted by this call and the context will be
      re-entered.
    *)
    val exit: 'T t -> callback:(args:(any list [@js.variadic]) -> 'R) -> args:(any list [@js.variadic]) -> 'R [@@js.call "exit"]
    (**
      Calling `asyncLocalStorage.enterWith(store)` will transition into the context
      for the remainder of the current synchronous execution and will persist
      through any following asynchronous calls.
    *)
    val enterWith: 'T t -> store:'T -> unit [@@js.call "enterWith"]
  end
end
module Node_buffer : sig
  (* export * from 'buffer'; *)
end
module[@js.scope "buffer"] Buffer : sig
  val inspect_max_bytes: float [@@js.global "INSPECT_MAX_BYTES"]
  val kMaxLength: float [@@js.global "kMaxLength"]
  val kStringMaxLength: float [@@js.global "kStringMaxLength"]
  val constants: anonymous_interface_1 [@@js.global "constants"]
  val buffType: (* FIXME: unknown type 'typeof Buffer' *)any [@@js.global "BuffType"]
  module TranscodeEncoding : sig
    type t = buffer_TranscodeEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  val transcode: source:Uint8Array.t_0 -> fromEnc:buffer_TranscodeEncoding -> toEnc:buffer_TranscodeEncoding -> _Buffer [@@js.global "transcode"]
  val slowBuffer: anonymous_interface_74 [@@js.global "SlowBuffer"]
  (* ES6Export ([[object Object]]) *)
end
module Node_child_process : sig
  (* export * from 'child_process'; *)
end
module[@js.scope "child_process"] Child_process : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:fs
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/child_process.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/child_process.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = NamespaceImport ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/child_process.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = ES6Import ([object Object])
    loc = line 9, col 5 of node_modules/@types/node/child_process.d.ts } *)
  module Serializable : sig
    type t = child_process_Serializable
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module SendHandle : sig
    type t = child_process_SendHandle
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "ChildProcess"] ChildProcess : sig
    type t = child_process_ChildProcess
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_stdin: t -> Writable.t_0 or_null [@@js.get "stdin"]
    val set_stdin: t -> Writable.t_0 or_null -> unit [@@js.set "stdin"]
    val get_stdout: t -> Readable.t_0 or_null [@@js.get "stdout"]
    val set_stdout: t -> Readable.t_0 or_null -> unit [@@js.set "stdout"]
    val get_stderr: t -> Readable.t_0 or_null [@@js.get "stderr"]
    val set_stderr: t -> Readable.t_0 or_null -> unit [@@js.set "stderr"]
    val get_channel: t -> Pipe.t_0 or_null [@@js.get "channel"]
    val get_stdio: t -> (Writable.t_0 or_null * Readable.t_0 or_null * Readable.t_0 or_null * (Readable.t_0, Writable.t_0) union2 or_null_or_undefined * (Readable.t_0, Writable.t_0) union2 or_null_or_undefined) [@@js.get "stdio"]
    val get_killed: t -> bool [@@js.get "killed"]
    val get_pid: t -> float [@@js.get "pid"]
    val get_connected: t -> bool [@@js.get "connected"]
    val get_exitCode: t -> float or_null [@@js.get "exitCode"]
    val get_signalCode: t -> NodeJS.Signals.t_0 or_null [@@js.get "signalCode"]
    val get_spawnargs: t -> string list [@@js.get "spawnargs"]
    val get_spawnfile: t -> string [@@js.get "spawnfile"]
    val kill: t -> ?signal:NodeJS.Signals.t_0 or_number -> unit -> bool [@@js.call "kill"]
    val send: t -> message:child_process_Serializable -> ?callback:(error:Error.t_0 or_null -> unit) -> unit -> bool [@@js.call "send"]
    val send': t -> message:child_process_Serializable -> ?sendHandle:child_process_SendHandle -> ?callback:(error:Error.t_0 or_null -> unit) -> unit -> bool [@@js.call "send"]
    val send'': t -> message:child_process_Serializable -> ?sendHandle:child_process_SendHandle -> ?options:child_process_MessageOptions -> ?callback:(error:Error.t_0 or_null -> unit) -> unit -> bool [@@js.call "send"]
    val disconnect: t -> unit [@@js.call "disconnect"]
    val unref: t -> unit [@@js.call "unref"]
    val ref: t -> unit [@@js.call "ref"]
    (**
      events.EventEmitter
      1. close
      2. disconnect
      3. error
      4. exit
      5. message
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. disconnect
      3. error
      4. exit
      5. message
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. disconnect
      3. error
      4. exit
      5. message
    *)
    val addListener'': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. disconnect
      3. error
      4. exit
      5. message
    *)
    val addListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. disconnect
      3. error
      4. exit
      5. message
    *)
    val addListener'''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. disconnect
      3. error
      4. exit
      5. message
    *)
    val addListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:child_process_Serializable -> sendHandle:child_process_SendHandle -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s205_disconnect] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s214_exit] [@js.enum]) -> code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s251_message] [@js.enum]) -> message:child_process_Serializable -> sendHandle:child_process_SendHandle -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:child_process_Serializable -> sendHandle:child_process_SendHandle -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:child_process_Serializable -> sendHandle:child_process_SendHandle -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:child_process_Serializable -> sendHandle:child_process_SendHandle -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float or_null -> signal:NodeJS.Signals.t_0 or_null -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:child_process_Serializable -> sendHandle:child_process_SendHandle -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> events_EventEmitter [@@js.cast]
  end
  module[@js.scope "ChildProcessWithoutNullStreams"] ChildProcessWithoutNullStreams : sig
    type t = child_process_ChildProcessWithoutNullStreams
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_stdin: t -> Writable.t_0 [@@js.get "stdin"]
    val set_stdin: t -> Writable.t_0 -> unit [@@js.set "stdin"]
    val get_stdout: t -> Readable.t_0 [@@js.get "stdout"]
    val set_stdout: t -> Readable.t_0 -> unit [@@js.set "stdout"]
    val get_stderr: t -> Readable.t_0 [@@js.get "stderr"]
    val set_stderr: t -> Readable.t_0 -> unit [@@js.set "stderr"]
    val get_stdio: t -> (Writable.t_0 * Readable.t_0 * Readable.t_0 * (Readable.t_0, Writable.t_0) union2 or_null_or_undefined * (Readable.t_0, Writable.t_0) union2 or_null_or_undefined) [@@js.get "stdio"]
    val cast: t -> child_process_ChildProcess [@@js.cast]
  end
  module[@js.scope "ChildProcessByStdio"] ChildProcessByStdio : sig
    type ('I, 'O, 'E) t = ('I, 'O, 'E) child_process_ChildProcessByStdio
    val t_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('E -> Ojs.t) -> ('I, 'O, 'E) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> (Ojs.t -> 'E) -> Ojs.t -> ('I, 'O, 'E) t
    type ('I, 'O, 'E) t_3 = ('I, 'O, 'E) t
    val t_3_to_js: ('I -> Ojs.t) -> ('O -> Ojs.t) -> ('E -> Ojs.t) -> ('I, 'O, 'E) t_3 -> Ojs.t
    val t_3_of_js: (Ojs.t -> 'I) -> (Ojs.t -> 'O) -> (Ojs.t -> 'E) -> Ojs.t -> ('I, 'O, 'E) t_3
    val get_stdin: ('I, 'O, 'E) t -> 'I [@@js.get "stdin"]
    val set_stdin: ('I, 'O, 'E) t -> 'I -> unit [@@js.set "stdin"]
    val get_stdout: ('I, 'O, 'E) t -> 'O [@@js.get "stdout"]
    val set_stdout: ('I, 'O, 'E) t -> 'O -> unit [@@js.set "stdout"]
    val get_stderr: ('I, 'O, 'E) t -> 'E [@@js.get "stderr"]
    val set_stderr: ('I, 'O, 'E) t -> 'E -> unit [@@js.set "stderr"]
    val get_stdio: ('I, 'O, 'E) t -> ('I * 'O * 'E * (Readable.t_0, Writable.t_0) union2 or_null_or_undefined * (Readable.t_0, Writable.t_0) union2 or_null_or_undefined) [@@js.get "stdio"]
    val cast: ('I, 'O, 'E) t -> child_process_ChildProcess [@@js.cast]
  end
  module[@js.scope "MessageOptions"] MessageOptions : sig
    type t = child_process_MessageOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_keepOpen: t -> bool [@@js.get "keepOpen"]
    val set_keepOpen: t -> bool -> unit [@@js.set "keepOpen"]
  end
  module StdioOptions : sig
    type t = child_process_StdioOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module SerializationType : sig
    type t = child_process_SerializationType
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "MessagingOptions"] MessagingOptions : sig
    type t = child_process_MessagingOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Specify the kind of serialization used for sending messages between processes.
      default: 'json'
    *)
    (**
      Specify the kind of serialization used for sending messages between processes.
      default: 'json'
    *)
    val get_serialization: t -> child_process_SerializationType [@@js.get "serialization"]
    (**
      Specify the kind of serialization used for sending messages between processes.
      default: 'json'
    *)
    val set_serialization: t -> child_process_SerializationType -> unit [@@js.set "serialization"]
  end
  module[@js.scope "ProcessEnvOptions"] ProcessEnvOptions : sig
    type t = child_process_ProcessEnvOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_uid: t -> float [@@js.get "uid"]
    val set_uid: t -> float -> unit [@@js.set "uid"]
    val get_gid: t -> float [@@js.get "gid"]
    val set_gid: t -> float -> unit [@@js.set "gid"]
    val get_cwd: t -> string [@@js.get "cwd"]
    val set_cwd: t -> string -> unit [@@js.set "cwd"]
    val get_env: t -> NodeJS.ProcessEnv.t_0 [@@js.get "env"]
    val set_env: t -> NodeJS.ProcessEnv.t_0 -> unit [@@js.set "env"]
  end
  module[@js.scope "CommonOptions"] CommonOptions : sig
    type t = child_process_CommonOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** default: true *)
    (** default: true *)
    val get_windowsHide: t -> bool [@@js.get "windowsHide"]
    (** default: true *)
    val set_windowsHide: t -> bool -> unit [@@js.set "windowsHide"]
    (** default: 0 *)
    (** default: 0 *)
    val get_timeout: t -> float [@@js.get "timeout"]
    (** default: 0 *)
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    val cast: t -> child_process_ProcessEnvOptions [@@js.cast]
  end
  module[@js.scope "CommonSpawnOptions"] CommonSpawnOptions : sig
    type t = child_process_CommonSpawnOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_argv0: t -> string [@@js.get "argv0"]
    val set_argv0: t -> string -> unit [@@js.set "argv0"]
    val get_stdio: t -> child_process_StdioOptions [@@js.get "stdio"]
    val set_stdio: t -> child_process_StdioOptions -> unit [@@js.set "stdio"]
    val get_shell: t -> bool or_string [@@js.get "shell"]
    val set_shell: t -> bool or_string -> unit [@@js.set "shell"]
    val get_windowsVerbatimArguments: t -> bool [@@js.get "windowsVerbatimArguments"]
    val set_windowsVerbatimArguments: t -> bool -> unit [@@js.set "windowsVerbatimArguments"]
    val cast: t -> child_process_CommonOptions [@@js.cast]
    val cast': t -> child_process_MessagingOptions [@@js.cast]
  end
  module[@js.scope "SpawnOptions"] SpawnOptions : sig
    type t = child_process_SpawnOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_detached: t -> bool [@@js.get "detached"]
    val set_detached: t -> bool -> unit [@@js.set "detached"]
    val cast: t -> child_process_CommonSpawnOptions [@@js.cast]
  end
  module[@js.scope "SpawnOptionsWithoutStdio"] SpawnOptionsWithoutStdio : sig
    type t = child_process_SpawnOptionsWithoutStdio
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_stdio: t -> (([`L_s271_pipe[@js "pipe"]] [@js.enum]) or_null_or_undefined list, ([`L_s271_pipe[@js "pipe"]] [@js.enum])) or_enum [@@js.get "stdio"]
    val set_stdio: t -> (([`L_s271_pipe] [@js.enum]) or_null_or_undefined list, ([`L_s271_pipe] [@js.enum])) or_enum -> unit [@@js.set "stdio"]
    val cast: t -> child_process_SpawnOptions [@@js.cast]
  end
  module StdioNull : sig
    type t = child_process_StdioNull
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module StdioPipe : sig
    type t = child_process_StdioPipe
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "SpawnOptionsWithStdioTuple"] SpawnOptionsWithStdioTuple : sig
    type ('Stdin, 'Stdout, 'Stderr) t = ('Stdin, 'Stdout, 'Stderr) child_process_SpawnOptionsWithStdioTuple
    val t_to_js: ('Stdin -> Ojs.t) -> ('Stdout -> Ojs.t) -> ('Stderr -> Ojs.t) -> ('Stdin, 'Stdout, 'Stderr) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'Stdin) -> (Ojs.t -> 'Stdout) -> (Ojs.t -> 'Stderr) -> Ojs.t -> ('Stdin, 'Stdout, 'Stderr) t
    type ('Stdin, 'Stdout, 'Stderr) t_3 = ('Stdin, 'Stdout, 'Stderr) t
    val t_3_to_js: ('Stdin -> Ojs.t) -> ('Stdout -> Ojs.t) -> ('Stderr -> Ojs.t) -> ('Stdin, 'Stdout, 'Stderr) t_3 -> Ojs.t
    val t_3_of_js: (Ojs.t -> 'Stdin) -> (Ojs.t -> 'Stdout) -> (Ojs.t -> 'Stderr) -> Ojs.t -> ('Stdin, 'Stdout, 'Stderr) t_3
    val get_stdio: ('Stdin, 'Stdout, 'Stderr) t -> ('Stdin * 'Stdout * 'Stderr) [@@js.get "stdio"]
    val set_stdio: ('Stdin, 'Stdout, 'Stderr) t -> ('Stdin * 'Stdout * 'Stderr) -> unit [@@js.set "stdio"]
    val cast: ('Stdin, 'Stdout, 'Stderr) t -> child_process_SpawnOptions [@@js.cast]
  end
  val spawn: command:string -> ?options:child_process_SpawnOptionsWithoutStdio -> unit -> child_process_ChildProcessWithoutNullStreams [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioPipe, child_process_StdioPipe, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, Readable.t_0, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioPipe, child_process_StdioPipe, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, Readable.t_0, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioPipe, child_process_StdioNull, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, never or_null, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioNull, child_process_StdioPipe, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (never or_null, Readable.t_0, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioPipe, child_process_StdioNull, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, never or_null, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioNull, child_process_StdioPipe, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (never or_null, Readable.t_0, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioNull, child_process_StdioNull, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (never or_null, never or_null, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:(child_process_StdioNull, child_process_StdioNull, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (never or_null, never or_null, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> options:child_process_SpawnOptions -> child_process_ChildProcess [@@js.global "spawn"]
  val spawn: command:string -> ?args:string list -> ?options:child_process_SpawnOptionsWithoutStdio -> unit -> child_process_ChildProcessWithoutNullStreams [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioPipe, child_process_StdioPipe, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, Readable.t_0, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioPipe, child_process_StdioPipe, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, Readable.t_0, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioPipe, child_process_StdioNull, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, never or_null, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioNull, child_process_StdioPipe, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (never or_null, Readable.t_0, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioPipe, child_process_StdioNull, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (Writable.t_0, never or_null, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioNull, child_process_StdioPipe, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (never or_null, Readable.t_0, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioNull, child_process_StdioNull, child_process_StdioPipe) child_process_SpawnOptionsWithStdioTuple -> (never or_null, never or_null, Readable.t_0) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:(child_process_StdioNull, child_process_StdioNull, child_process_StdioNull) child_process_SpawnOptionsWithStdioTuple -> (never or_null, never or_null, never or_null) child_process_ChildProcessByStdio [@@js.global "spawn"]
  val spawn: command:string -> args:string list -> options:child_process_SpawnOptions -> child_process_ChildProcess [@@js.global "spawn"]
  module[@js.scope "ExecOptions"] ExecOptions : sig
    type t = child_process_ExecOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_shell: t -> string [@@js.get "shell"]
    val set_shell: t -> string -> unit [@@js.set "shell"]
    val get_maxBuffer: t -> float [@@js.get "maxBuffer"]
    val set_maxBuffer: t -> float -> unit [@@js.set "maxBuffer"]
    val get_killSignal: t -> NodeJS.Signals.t_0 or_number [@@js.get "killSignal"]
    val set_killSignal: t -> NodeJS.Signals.t_0 or_number -> unit [@@js.set "killSignal"]
    val cast: t -> child_process_CommonOptions [@@js.cast]
  end
  module[@js.scope "ExecOptionsWithStringEncoding"] ExecOptionsWithStringEncoding : sig
    type t = child_process_ExecOptionsWithStringEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecOptions [@@js.cast]
  end
  module[@js.scope "ExecOptionsWithBufferEncoding"] ExecOptionsWithBufferEncoding : sig
    type t = child_process_ExecOptionsWithBufferEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding or_null [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding or_null -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecOptions [@@js.cast]
  end
  module[@js.scope "ExecException"] ExecException : sig
    type t = child_process_ExecException
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_cmd: t -> string [@@js.get "cmd"]
    val set_cmd: t -> string -> unit [@@js.set "cmd"]
    val get_killed: t -> bool [@@js.get "killed"]
    val set_killed: t -> bool -> unit [@@js.set "killed"]
    val get_code: t -> float [@@js.get "code"]
    val set_code: t -> float -> unit [@@js.set "code"]
    val get_signal: t -> NodeJS.Signals.t_0 [@@js.get "signal"]
    val set_signal: t -> NodeJS.Signals.t_0 -> unit [@@js.set "signal"]
    val cast: t -> Error.t_0 [@@js.cast]
  end
  val exec: command:string -> ?callback:(error:child_process_ExecException or_null -> stdout:string -> stderr:string -> unit) -> unit -> child_process_ChildProcess [@@js.global "exec"]
  val exec: command:string -> options:(anonymous_interface_19, child_process_ExecOptions) intersection2 -> ?callback:(error:child_process_ExecException or_null -> stdout:_Buffer -> stderr:_Buffer -> unit) -> unit -> child_process_ChildProcess [@@js.global "exec"]
  val exec: command:string -> options:(anonymous_interface_11, child_process_ExecOptions) intersection2 -> ?callback:(error:child_process_ExecException or_null -> stdout:string -> stderr:string -> unit) -> unit -> child_process_ChildProcess [@@js.global "exec"]
  val exec: command:string -> options:(anonymous_interface_11, child_process_ExecOptions) intersection2 -> ?callback:(error:child_process_ExecException or_null -> stdout:_Buffer or_string -> stderr:_Buffer or_string -> unit) -> unit -> child_process_ChildProcess [@@js.global "exec"]
  val exec: command:string -> options:child_process_ExecOptions -> ?callback:(error:child_process_ExecException or_null -> stdout:string -> stderr:string -> unit) -> unit -> child_process_ChildProcess [@@js.global "exec"]
  val exec: command:string -> options:(BaseEncodingOptions.t_0, child_process_ExecOptions) intersection2 or_null_or_undefined -> ?callback:(error:child_process_ExecException or_null -> stdout:_Buffer or_string -> stderr:_Buffer or_string -> unit) -> unit -> child_process_ChildProcess [@@js.global "exec"]
  module[@js.scope "PromiseWithChild"] PromiseWithChild : sig
    type 'T t = 'T child_process_PromiseWithChild
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get_child: 'T t -> child_process_ChildProcess [@@js.get "child"]
    val set_child: 'T t -> child_process_ChildProcess -> unit [@@js.set "child"]
    val cast: 'T t -> 'T Promise.t_1 [@@js.cast]
  end
  module[@js.scope "exec"] Exec : sig
    val __promisify__: command:string -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: command:string -> options:(anonymous_interface_19, child_process_ExecOptions) intersection2 -> anonymous_interface_49 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: command:string -> options:(anonymous_interface_11, child_process_ExecOptions) intersection2 -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: command:string -> options:child_process_ExecOptions -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: command:string -> ?options:(BaseEncodingOptions.t_0, child_process_ExecOptions) intersection2 or_null -> unit -> anonymous_interface_51 child_process_PromiseWithChild [@@js.global "__promisify__"]
  end
  module[@js.scope "ExecFileOptions"] ExecFileOptions : sig
    type t = child_process_ExecFileOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_maxBuffer: t -> float [@@js.get "maxBuffer"]
    val set_maxBuffer: t -> float -> unit [@@js.set "maxBuffer"]
    val get_killSignal: t -> NodeJS.Signals.t_0 or_number [@@js.get "killSignal"]
    val set_killSignal: t -> NodeJS.Signals.t_0 or_number -> unit [@@js.set "killSignal"]
    val get_windowsVerbatimArguments: t -> bool [@@js.get "windowsVerbatimArguments"]
    val set_windowsVerbatimArguments: t -> bool -> unit [@@js.set "windowsVerbatimArguments"]
    val get_shell: t -> bool or_string [@@js.get "shell"]
    val set_shell: t -> bool or_string -> unit [@@js.set "shell"]
    val cast: t -> child_process_CommonOptions [@@js.cast]
  end
  module[@js.scope "ExecFileOptionsWithStringEncoding"] ExecFileOptionsWithStringEncoding : sig
    type t = child_process_ExecFileOptionsWithStringEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecFileOptions [@@js.cast]
  end
  module[@js.scope "ExecFileOptionsWithBufferEncoding"] ExecFileOptionsWithBufferEncoding : sig
    type t = child_process_ExecFileOptionsWithBufferEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) or_null [@@js.get "encoding"]
    val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) or_null -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecFileOptions [@@js.cast]
  end
  module[@js.scope "ExecFileOptionsWithOtherEncoding"] ExecFileOptionsWithOtherEncoding : sig
    type t = child_process_ExecFileOptionsWithOtherEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecFileOptions [@@js.cast]
  end
  module ExecFileException : sig
    type t = child_process_ExecFileException
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  val execFile: file:string -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> options:(BaseEncodingOptions.t_0, child_process_ExecFileOptions) intersection2 or_null_or_undefined -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> ?args:string list or_null -> unit -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> options:(BaseEncodingOptions.t_0, child_process_ExecFileOptions) intersection2 or_null_or_undefined -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> callback:(error:child_process_ExecFileException or_null -> stdout:string -> stderr:string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> callback:(error:child_process_ExecFileException or_null -> stdout:string -> stderr:string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> options:child_process_ExecFileOptionsWithBufferEncoding -> callback:(error:child_process_ExecFileException or_null -> stdout:_Buffer -> stderr:_Buffer -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptionsWithBufferEncoding -> callback:(error:child_process_ExecFileException or_null -> stdout:_Buffer -> stderr:_Buffer -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> options:child_process_ExecFileOptionsWithStringEncoding -> callback:(error:child_process_ExecFileException or_null -> stdout:string -> stderr:string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptionsWithStringEncoding -> callback:(error:child_process_ExecFileException or_null -> stdout:string -> stderr:string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> options:child_process_ExecFileOptionsWithOtherEncoding -> callback:(error:child_process_ExecFileException or_null -> stdout:_Buffer or_string -> stderr:_Buffer or_string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptionsWithOtherEncoding -> callback:(error:child_process_ExecFileException or_null -> stdout:_Buffer or_string -> stderr:_Buffer or_string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> options:child_process_ExecFileOptions -> callback:(error:child_process_ExecFileException or_null -> stdout:string -> stderr:string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptions -> callback:(error:child_process_ExecFileException or_null -> stdout:string -> stderr:string -> unit) -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> options:(BaseEncodingOptions.t_0, child_process_ExecFileOptions) intersection2 or_null_or_undefined -> callback:(error:child_process_ExecFileException or_null -> stdout:_Buffer or_string -> stderr:_Buffer or_string -> unit) or_null_or_undefined -> child_process_ChildProcess [@@js.global "execFile"]
  val execFile: file:string -> args:string list or_null_or_undefined -> options:(BaseEncodingOptions.t_0, child_process_ExecFileOptions) intersection2 or_null_or_undefined -> callback:(error:child_process_ExecFileException or_null -> stdout:_Buffer or_string -> stderr:_Buffer or_string -> unit) or_null_or_undefined -> child_process_ChildProcess [@@js.global "execFile"]
  module[@js.scope "execFile"] ExecFile : sig
    val __promisify__: file:string -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> args:string list or_null_or_undefined -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> options:child_process_ExecFileOptionsWithBufferEncoding -> anonymous_interface_49 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptionsWithBufferEncoding -> anonymous_interface_49 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> options:child_process_ExecFileOptionsWithStringEncoding -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptionsWithStringEncoding -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> options:child_process_ExecFileOptionsWithOtherEncoding -> anonymous_interface_51 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptionsWithOtherEncoding -> anonymous_interface_51 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> options:child_process_ExecFileOptions -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> args:string list or_null_or_undefined -> options:child_process_ExecFileOptions -> anonymous_interface_50 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> options:(BaseEncodingOptions.t_0, child_process_ExecFileOptions) intersection2 or_null_or_undefined -> anonymous_interface_51 child_process_PromiseWithChild [@@js.global "__promisify__"]
    val __promisify__: file:string -> args:string list or_null_or_undefined -> options:(BaseEncodingOptions.t_0, child_process_ExecFileOptions) intersection2 or_null_or_undefined -> anonymous_interface_51 child_process_PromiseWithChild [@@js.global "__promisify__"]
  end
  module[@js.scope "ForkOptions"] ForkOptions : sig
    type t = child_process_ForkOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_execPath: t -> string [@@js.get "execPath"]
    val set_execPath: t -> string -> unit [@@js.set "execPath"]
    val get_execArgv: t -> string list [@@js.get "execArgv"]
    val set_execArgv: t -> string list -> unit [@@js.set "execArgv"]
    val get_silent: t -> bool [@@js.get "silent"]
    val set_silent: t -> bool -> unit [@@js.set "silent"]
    val get_stdio: t -> child_process_StdioOptions [@@js.get "stdio"]
    val set_stdio: t -> child_process_StdioOptions -> unit [@@js.set "stdio"]
    val get_detached: t -> bool [@@js.get "detached"]
    val set_detached: t -> bool -> unit [@@js.set "detached"]
    val get_windowsVerbatimArguments: t -> bool [@@js.get "windowsVerbatimArguments"]
    val set_windowsVerbatimArguments: t -> bool -> unit [@@js.set "windowsVerbatimArguments"]
    val cast: t -> child_process_ProcessEnvOptions [@@js.cast]
    val cast': t -> child_process_MessagingOptions [@@js.cast]
  end
  val fork: modulePath:string -> ?options:child_process_ForkOptions -> unit -> child_process_ChildProcess [@@js.global "fork"]
  val fork: modulePath:string -> ?args:string list -> ?options:child_process_ForkOptions -> unit -> child_process_ChildProcess [@@js.global "fork"]
  module[@js.scope "SpawnSyncOptions"] SpawnSyncOptions : sig
    type t = child_process_SpawnSyncOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_input: t -> _NodeJS_ArrayBufferView or_string [@@js.get "input"]
    val set_input: t -> _NodeJS_ArrayBufferView or_string -> unit [@@js.set "input"]
    val get_killSignal: t -> NodeJS.Signals.t_0 or_number [@@js.get "killSignal"]
    val set_killSignal: t -> NodeJS.Signals.t_0 or_number -> unit [@@js.set "killSignal"]
    val get_maxBuffer: t -> float [@@js.get "maxBuffer"]
    val set_maxBuffer: t -> float -> unit [@@js.set "maxBuffer"]
    val get_encoding: t -> ([`L_s179_ascii[@js "ascii"] | `L_s181_base64[@js "base64"] | `L_s182_base64url[@js "base64url"] | `L_s185_binary[@js "binary"] | `L_s187_buffer[@js "buffer"] | `L_s226_hex[@js "hex"] | `L_s242_latin1[@js "latin1"] | `L_s315_ucs_2[@js "ucs-2"] | `L_s316_ucs2[@js "ucs2"] | `L_s327_utf_8[@js "utf-8"] | `L_s328_utf16le[@js "utf16le"] | `L_s329_utf8[@js "utf8"]] [@js.enum]) or_null [@@js.get "encoding"]
    val set_encoding: t -> ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s187_buffer | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum]) or_null -> unit [@@js.set "encoding"]
    val cast: t -> child_process_CommonSpawnOptions [@@js.cast]
  end
  module[@js.scope "SpawnSyncOptionsWithStringEncoding"] SpawnSyncOptionsWithStringEncoding : sig
    type t = child_process_SpawnSyncOptionsWithStringEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_SpawnSyncOptions [@@js.cast]
  end
  module[@js.scope "SpawnSyncOptionsWithBufferEncoding"] SpawnSyncOptionsWithBufferEncoding : sig
    type t = child_process_SpawnSyncOptionsWithBufferEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) or_null [@@js.get "encoding"]
    val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) or_null -> unit [@@js.set "encoding"]
    val cast: t -> child_process_SpawnSyncOptions [@@js.cast]
  end
  module[@js.scope "SpawnSyncReturns"] SpawnSyncReturns : sig
    type 'T t = 'T child_process_SpawnSyncReturns
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get_pid: 'T t -> float [@@js.get "pid"]
    val set_pid: 'T t -> float -> unit [@@js.set "pid"]
    val get_output: 'T t -> string list [@@js.get "output"]
    val set_output: 'T t -> string list -> unit [@@js.set "output"]
    val get_stdout: 'T t -> 'T [@@js.get "stdout"]
    val set_stdout: 'T t -> 'T -> unit [@@js.set "stdout"]
    val get_stderr: 'T t -> 'T [@@js.get "stderr"]
    val set_stderr: 'T t -> 'T -> unit [@@js.set "stderr"]
    val get_status: 'T t -> float or_null [@@js.get "status"]
    val set_status: 'T t -> float or_null -> unit [@@js.set "status"]
    val get_signal: 'T t -> NodeJS.Signals.t_0 or_null [@@js.get "signal"]
    val set_signal: 'T t -> NodeJS.Signals.t_0 or_null -> unit [@@js.set "signal"]
    val get_error: 'T t -> Error.t_0 [@@js.get "error"]
    val set_error: 'T t -> Error.t_0 -> unit [@@js.set "error"]
  end
  val spawnSync: command:string -> _Buffer child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  val spawnSync: command:string -> ?options:child_process_SpawnSyncOptionsWithStringEncoding -> unit -> string child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  val spawnSync: command:string -> ?options:child_process_SpawnSyncOptionsWithBufferEncoding -> unit -> _Buffer child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  val spawnSync: command:string -> ?options:child_process_SpawnSyncOptions -> unit -> _Buffer child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  val spawnSync: command:string -> ?args:string list -> ?options:child_process_SpawnSyncOptionsWithStringEncoding -> unit -> string child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  val spawnSync: command:string -> ?args:string list -> ?options:child_process_SpawnSyncOptionsWithBufferEncoding -> unit -> _Buffer child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  val spawnSync: command:string -> ?args:string list -> ?options:child_process_SpawnSyncOptions -> unit -> _Buffer child_process_SpawnSyncReturns [@@js.global "spawnSync"]
  module[@js.scope "ExecSyncOptions"] ExecSyncOptions : sig
    type t = child_process_ExecSyncOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_input: t -> Uint8Array.t_0 or_string [@@js.get "input"]
    val set_input: t -> Uint8Array.t_0 or_string -> unit [@@js.set "input"]
    val get_stdio: t -> child_process_StdioOptions [@@js.get "stdio"]
    val set_stdio: t -> child_process_StdioOptions -> unit [@@js.set "stdio"]
    val get_shell: t -> string [@@js.get "shell"]
    val set_shell: t -> string -> unit [@@js.set "shell"]
    val get_killSignal: t -> NodeJS.Signals.t_0 or_number [@@js.get "killSignal"]
    val set_killSignal: t -> NodeJS.Signals.t_0 or_number -> unit [@@js.set "killSignal"]
    val get_maxBuffer: t -> float [@@js.get "maxBuffer"]
    val set_maxBuffer: t -> float -> unit [@@js.set "maxBuffer"]
    val get_encoding: t -> ([`L_s179_ascii[@js "ascii"] | `L_s181_base64[@js "base64"] | `L_s182_base64url[@js "base64url"] | `L_s185_binary[@js "binary"] | `L_s187_buffer[@js "buffer"] | `L_s226_hex[@js "hex"] | `L_s242_latin1[@js "latin1"] | `L_s315_ucs_2[@js "ucs-2"] | `L_s316_ucs2[@js "ucs2"] | `L_s327_utf_8[@js "utf-8"] | `L_s328_utf16le[@js "utf16le"] | `L_s329_utf8[@js "utf8"]] [@js.enum]) or_null [@@js.get "encoding"]
    val set_encoding: t -> ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s187_buffer | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum]) or_null -> unit [@@js.set "encoding"]
    val cast: t -> child_process_CommonOptions [@@js.cast]
  end
  module[@js.scope "ExecSyncOptionsWithStringEncoding"] ExecSyncOptionsWithStringEncoding : sig
    type t = child_process_ExecSyncOptionsWithStringEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecSyncOptions [@@js.cast]
  end
  module[@js.scope "ExecSyncOptionsWithBufferEncoding"] ExecSyncOptionsWithBufferEncoding : sig
    type t = child_process_ExecSyncOptionsWithBufferEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> ([`L_s187_buffer[@js "buffer"]] [@js.enum]) or_null [@@js.get "encoding"]
    val set_encoding: t -> ([`L_s187_buffer] [@js.enum]) or_null -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecSyncOptions [@@js.cast]
  end
  val execSync: command:string -> _Buffer [@@js.global "execSync"]
  val execSync: command:string -> ?options:child_process_ExecSyncOptionsWithStringEncoding -> unit -> string [@@js.global "execSync"]
  val execSync: command:string -> ?options:child_process_ExecSyncOptionsWithBufferEncoding -> unit -> _Buffer [@@js.global "execSync"]
  val execSync: command:string -> ?options:child_process_ExecSyncOptions -> unit -> _Buffer [@@js.global "execSync"]
  module[@js.scope "ExecFileSyncOptions"] ExecFileSyncOptions : sig
    type t = child_process_ExecFileSyncOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_input: t -> _NodeJS_ArrayBufferView or_string [@@js.get "input"]
    val set_input: t -> _NodeJS_ArrayBufferView or_string -> unit [@@js.set "input"]
    val get_stdio: t -> child_process_StdioOptions [@@js.get "stdio"]
    val set_stdio: t -> child_process_StdioOptions -> unit [@@js.set "stdio"]
    val get_killSignal: t -> NodeJS.Signals.t_0 or_number [@@js.get "killSignal"]
    val set_killSignal: t -> NodeJS.Signals.t_0 or_number -> unit [@@js.set "killSignal"]
    val get_maxBuffer: t -> float [@@js.get "maxBuffer"]
    val set_maxBuffer: t -> float -> unit [@@js.set "maxBuffer"]
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val get_shell: t -> bool or_string [@@js.get "shell"]
    val set_shell: t -> bool or_string -> unit [@@js.set "shell"]
    val cast: t -> child_process_CommonOptions [@@js.cast]
  end
  module[@js.scope "ExecFileSyncOptionsWithStringEncoding"] ExecFileSyncOptionsWithStringEncoding : sig
    type t = child_process_ExecFileSyncOptionsWithStringEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecFileSyncOptions [@@js.cast]
  end
  module[@js.scope "ExecFileSyncOptionsWithBufferEncoding"] ExecFileSyncOptionsWithBufferEncoding : sig
    type t = child_process_ExecFileSyncOptionsWithBufferEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    val cast: t -> child_process_ExecFileSyncOptions [@@js.cast]
  end
  val execFileSync: command:string -> _Buffer [@@js.global "execFileSync"]
  val execFileSync: command:string -> ?options:child_process_ExecFileSyncOptionsWithStringEncoding -> unit -> string [@@js.global "execFileSync"]
  val execFileSync: command:string -> ?options:child_process_ExecFileSyncOptionsWithBufferEncoding -> unit -> _Buffer [@@js.global "execFileSync"]
  val execFileSync: command:string -> ?options:child_process_ExecFileSyncOptions -> unit -> _Buffer [@@js.global "execFileSync"]
  val execFileSync: command:string -> ?args:string list -> ?options:child_process_ExecFileSyncOptionsWithStringEncoding -> unit -> string [@@js.global "execFileSync"]
  val execFileSync: command:string -> ?args:string list -> ?options:child_process_ExecFileSyncOptionsWithBufferEncoding -> unit -> _Buffer [@@js.global "execFileSync"]
  val execFileSync: command:string -> ?args:string list -> ?options:child_process_ExecFileSyncOptions -> unit -> _Buffer [@@js.global "execFileSync"]
end
module Node_cluster : sig
  (* export * from 'cluster'; *)
end
module[@js.scope "cluster"] Cluster : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:child_process
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/cluster.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/cluster.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = NamespaceImport ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/cluster.d.ts } *)
  module[@js.scope "ClusterSettings"] ClusterSettings : sig
    type t = cluster_ClusterSettings
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_execArgv: t -> string list [@@js.get "execArgv"]
    val set_execArgv: t -> string list -> unit [@@js.set "execArgv"]
    val get_exec: t -> string [@@js.get "exec"]
    val set_exec: t -> string -> unit [@@js.set "exec"]
    val get_args: t -> string list [@@js.get "args"]
    val set_args: t -> string list -> unit [@@js.set "args"]
    val get_silent: t -> bool [@@js.get "silent"]
    val set_silent: t -> bool -> unit [@@js.set "silent"]
    val get_stdio: t -> any list [@@js.get "stdio"]
    val set_stdio: t -> any list -> unit [@@js.set "stdio"]
    val get_uid: t -> float [@@js.get "uid"]
    val set_uid: t -> float -> unit [@@js.set "uid"]
    val get_gid: t -> float [@@js.get "gid"]
    val set_gid: t -> float -> unit [@@js.set "gid"]
    val get_inspectPort: t -> (unit -> float) or_number [@@js.get "inspectPort"]
    val set_inspectPort: t -> (unit -> float) or_number -> unit [@@js.set "inspectPort"]
  end
  module[@js.scope "Address"] Address : sig
    type t = cluster_Address
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_addressType: t -> ([`L_s317_udp4[@js "udp4"] | `L_s318_udp6[@js "udp6"]] [@js.enum]) or_number [@@js.get "addressType"]
    val set_addressType: t -> ([`L_s317_udp4 | `L_s318_udp6] [@js.enum]) or_number -> unit [@@js.set "addressType"]
  end
  module[@js.scope "Worker"] Worker : sig
    type t = cluster_Worker
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_id: t -> float [@@js.get "id"]
    val set_id: t -> float -> unit [@@js.set "id"]
    val get_process: t -> Child.ChildProcess.t_0 [@@js.get "process"]
    val set_process: t -> Child.ChildProcess.t_0 -> unit [@@js.set "process"]
    val send: t -> message:Child.Serializable.t_0 -> ?sendHandle:Child.SendHandle.t_0 -> ?callback:(error:Error.t_0 or_null -> unit) -> unit -> bool [@@js.call "send"]
    val kill: t -> ?signal:string -> unit -> unit [@@js.call "kill"]
    val destroy: t -> ?signal:string -> unit -> unit [@@js.call "destroy"]
    val disconnect: t -> unit [@@js.call "disconnect"]
    val isConnected: t -> bool [@@js.call "isConnected"]
    val isDead: t -> bool [@@js.call "isDead"]
    val get_exitedAfterDisconnect: t -> bool [@@js.get "exitedAfterDisconnect"]
    val set_exitedAfterDisconnect: t -> bool -> unit [@@js.set "exitedAfterDisconnect"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float -> signal:string -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(address:cluster_Address -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. error
        3. exit
        4. listening
        5. message
        6. online
    *)
    val addListener'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s205_disconnect] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s213_error] [@js.enum]) -> error:Error.t_0 -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s214_exit] [@js.enum]) -> code:float -> signal:string -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s246_listening] [@js.enum]) -> address:cluster_Address -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s251_message] [@js.enum]) -> message:any -> handle:(net_Server, net_Socket) union2 -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s264_online] [@js.enum]) -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float -> signal:string -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(address:cluster_Address -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float -> signal:string -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(address:cluster_Address -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float -> signal:string -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(address:cluster_Address -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(code:float -> signal:string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(address:cluster_Address -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "Cluster"] Cluster : sig
    type t = cluster_Cluster
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_Worker: t -> cluster_Worker [@@js.get "Worker"]
    val set_Worker: t -> cluster_Worker -> unit [@@js.set "Worker"]
    val disconnect: t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "disconnect"]
    val fork: t -> ?env:any -> unit -> cluster_Worker [@@js.call "fork"]
    val get_isMaster: t -> bool [@@js.get "isMaster"]
    val set_isMaster: t -> bool -> unit [@@js.set "isMaster"]
    val get_isWorker: t -> bool [@@js.get "isWorker"]
    val set_isWorker: t -> bool -> unit [@@js.set "isWorker"]
    val get_schedulingPolicy: t -> float [@@js.get "schedulingPolicy"]
    val set_schedulingPolicy: t -> float -> unit [@@js.set "schedulingPolicy"]
    val get_settings: t -> cluster_ClusterSettings [@@js.get "settings"]
    val set_settings: t -> cluster_ClusterSettings -> unit [@@js.set "settings"]
    val setupMaster: t -> ?settings:cluster_ClusterSettings -> unit -> unit [@@js.call "setupMaster"]
    val get_worker: t -> cluster_Worker [@@js.get "worker"]
    val set_worker: t -> cluster_Worker -> unit [@@js.set "worker"]
    val get_workers: t -> cluster_Worker _NodeJS_Dict [@@js.get "workers"]
    val set_workers: t -> cluster_Worker _NodeJS_Dict -> unit [@@js.set "workers"]
    val get_SCHED_NONE: t -> float [@@js.get "SCHED_NONE"]
    val get_SCHED_RR: t -> float [@@js.get "SCHED_RR"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener''': t -> event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. disconnect
        2. exit
        3. fork
        4. listening
        5. message
        6. online
        7. setup
    *)
    val addListener''''''': t -> event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s205_disconnect] [@js.enum]) -> worker:cluster_Worker -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s214_exit] [@js.enum]) -> worker:cluster_Worker -> code:float -> signal:string -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s218_fork] [@js.enum]) -> worker:cluster_Worker -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s246_listening] [@js.enum]) -> worker:cluster_Worker -> address:cluster_Address -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s251_message] [@js.enum]) -> worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s264_online] [@js.enum]) -> worker:cluster_Worker -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s300_setup] [@js.enum]) -> settings:cluster_ClusterSettings -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  val sched_none: float [@@js.global "SCHED_NONE"]
  val sched_rr: float [@@js.global "SCHED_RR"]
  val disconnect: ?callback:(unit -> unit) -> unit -> unit [@@js.global "disconnect"]
  val fork: ?env:any -> unit -> cluster_Worker [@@js.global "fork"]
  val isMaster: bool [@@js.global "isMaster"]
  val isWorker: bool [@@js.global "isWorker"]
  val schedulingPolicy: float [@@js.global "schedulingPolicy"]
  val settings: cluster_ClusterSettings [@@js.global "settings"]
  val setupMaster: ?settings:cluster_ClusterSettings -> unit -> unit [@@js.global "setupMaster"]
  val worker: cluster_Worker [@@js.global "worker"]
  val workers: cluster_Worker _NodeJS_Dict [@@js.global "workers"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "addListener"]
  (**
    events.EventEmitter
      1. disconnect
      2. exit
      3. fork
      4. listening
      5. message
      6. online
      7. setup
  *)
  val addListener: event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> cluster_Cluster [@@js.global "addListener"]
  val emit: event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.global "emit"]
  val emit: event:([`L_s205_disconnect] [@js.enum]) -> worker:cluster_Worker -> bool [@@js.global "emit"]
  val emit: event:([`L_s214_exit] [@js.enum]) -> worker:cluster_Worker -> code:float -> signal:string -> bool [@@js.global "emit"]
  val emit: event:([`L_s218_fork] [@js.enum]) -> worker:cluster_Worker -> bool [@@js.global "emit"]
  val emit: event:([`L_s246_listening] [@js.enum]) -> worker:cluster_Worker -> address:cluster_Address -> bool [@@js.global "emit"]
  val emit: event:([`L_s251_message] [@js.enum]) -> worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> bool [@@js.global "emit"]
  val emit: event:([`L_s264_online] [@js.enum]) -> worker:cluster_Worker -> bool [@@js.global "emit"]
  val emit: event:([`L_s300_setup] [@js.enum]) -> settings:cluster_ClusterSettings -> bool [@@js.global "emit"]
  val on: event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "on"]
  val on: event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> cluster_Cluster [@@js.global "on"]
  val once: event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "once"]
  val once: event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> cluster_Cluster [@@js.global "once"]
  val removeListener: event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> cluster_Cluster [@@js.global "removeListener"]
  val removeAllListeners: ?event:string -> unit -> cluster_Cluster [@@js.global "removeAllListeners"]
  val setMaxListeners: n:float -> cluster_Cluster [@@js.global "setMaxListeners"]
  val getMaxListeners: unit -> float [@@js.global "getMaxListeners"]
  val listeners: event:string -> untyped_function list [@@js.global "listeners"]
  val listenerCount: type_:string -> float [@@js.global "listenerCount"]
  val prependListener: event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependListener: event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> cluster_Cluster [@@js.global "prependListener"]
  val prependOnceListener: event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s205_disconnect] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s214_exit] [@js.enum]) -> listener:(worker:cluster_Worker -> code:float -> signal:string -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s218_fork] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s246_listening] [@js.enum]) -> listener:(worker:cluster_Worker -> address:cluster_Address -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s251_message] [@js.enum]) -> listener:(worker:cluster_Worker -> message:any -> handle:(net_Server, net_Socket) union2 -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s264_online] [@js.enum]) -> listener:(worker:cluster_Worker -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val prependOnceListener: event:([`L_s300_setup] [@js.enum]) -> listener:(settings:cluster_ClusterSettings -> unit) -> cluster_Cluster [@@js.global "prependOnceListener"]
  val eventNames: unit -> string list [@@js.global "eventNames"]
end
module Node_console : sig
  (* CommonJsExport ({ name = [console]
    fullName = [console]
    loc = line 2, col 14 of node_modules/@types/node/console.d.ts }) *)
end
module[@js.scope "console"] Console : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:util
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/console.d.ts } *)
  module[@js.scope "global"] Global : sig
    module[@js.scope "Console"] Console : sig
      type t = console_global_Console
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_Console: t -> console_global_NodeJS_ConsoleConstructor [@@js.get "Console"]
      val set_Console: t -> console_global_NodeJS_ConsoleConstructor -> unit [@@js.set "Console"]
      (**
        A simple assertion test that verifies whether `value` is truthy.
        If it is not, an `AssertionError` is thrown.
        If provided, the error `message` is formatted using `util.format()` and used as the error message.
      *)
      val assert_: t -> value:any -> ?message:string -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "assert"]
      (**
        When `stdout` is a TTY, calling `console.clear()` will attempt to clear the TTY.
        When `stdout` is not a TTY, this method does nothing.
      *)
      val clear: t -> unit [@@js.call "clear"]
      (** Maintains an internal counter specific to `label` and outputs to `stdout` the number of times `console.count()` has been called with the given `label`. *)
      val count: t -> ?label:string -> unit -> unit [@@js.call "count"]
      (** Resets the internal counter specific to `label`. *)
      val countReset: t -> ?label:string -> unit -> unit [@@js.call "countReset"]
      (** The `console.debug()` function is an alias for \{\@link console.log()\}. *)
      val debug: t -> ?message:any -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "debug"]
      (**
        Uses \{\@link util.inspect()\} on `obj` and prints the resulting string to `stdout`.
        This function bypasses any custom `inspect()` function defined on `obj`.
      *)
      val dir: t -> obj:any -> ?options:InspectOptions.t_0 -> unit -> unit [@@js.call "dir"]
      (** This method calls \{\@link console.log()\} passing it the arguments received. Please note that this method does not produce any XML formatting *)
      val dirxml: t -> data:(any list [@js.variadic]) -> unit [@@js.call "dirxml"]
      (** Prints to `stderr` with newline. *)
      val error: t -> ?message:any -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "error"]
      (**
        Increases indentation of subsequent lines by two spaces.
        If one or more `label`s are provided, those are printed first without the additional indentation.
      *)
      val group: t -> label:(any list [@js.variadic]) -> unit [@@js.call "group"]
      (** The `console.groupCollapsed()` function is an alias for \{\@link console.group()\}. *)
      val groupCollapsed: t -> label:(any list [@js.variadic]) -> unit [@@js.call "groupCollapsed"]
      (** Decreases indentation of subsequent lines by two spaces. *)
      val groupEnd: t -> unit [@@js.call "groupEnd"]
      (** The \{\@link console.info()\} function is an alias for \{\@link console.log()\}. *)
      val info: t -> ?message:any -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "info"]
      (** Prints to `stdout` with newline. *)
      val log: t -> ?message:any -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "log"]
      (**
        This method does not display anything unless used in the inspector.
         Prints to `stdout` the array `array` formatted as a table.
      *)
      val table: t -> tabularData:any -> ?properties:string list -> unit -> unit [@@js.call "table"]
      (** Starts a timer that can be used to compute the duration of an operation. Timers are identified by a unique `label`. *)
      val time: t -> ?label:string -> unit -> unit [@@js.call "time"]
      (** Stops a timer that was previously started by calling \{\@link console.time()\} and prints the result to `stdout`. *)
      val timeEnd: t -> ?label:string -> unit -> unit [@@js.call "timeEnd"]
      (** For a timer that was previously started by calling \{\@link console.time()\}, prints the elapsed time and other `data` arguments to `stdout`. *)
      val timeLog: t -> ?label:string -> data:(any list [@js.variadic]) -> unit [@@js.call "timeLog"]
      (** Prints to `stderr` the string 'Trace :', followed by the \{\@link util.format()\} formatted message and stack trace to the current position in the code. *)
      val trace: t -> ?message:any -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "trace"]
      (** The \{\@link console.warn()\} function is an alias for \{\@link console.error()\}. *)
      val warn: t -> ?message:any -> optionalParams:(any list [@js.variadic]) -> unit [@@js.call "warn"]
      (**
        This method does not display anything unless used in the inspector.
         Starts a JavaScript CPU profile with an optional label.
      *)
      val profile: t -> ?label:string -> unit -> unit [@@js.call "profile"]
      (**
        This method does not display anything unless used in the inspector.
         Stops the current JavaScript CPU profiling session if one has been started and prints the report to the Profiles panel of the inspector.
      *)
      val profileEnd: t -> ?label:string -> unit -> unit [@@js.call "profileEnd"]
      (**
        This method does not display anything unless used in the inspector.
         Adds an event with the label `label` to the Timeline panel of the inspector.
      *)
      val timeStamp: t -> ?label:string -> unit -> unit [@@js.call "timeStamp"]
    end
    val console: console_global_Console [@@js.global "console"]
    module[@js.scope "NodeJS"] NodeJS : sig
      module[@js.scope "ConsoleConstructorOptions"] ConsoleConstructorOptions : sig
        type t = console_global_NodeJS_ConsoleConstructorOptions
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_stdout: t -> WritableStream.t_0 [@@js.get "stdout"]
        val set_stdout: t -> WritableStream.t_0 -> unit [@@js.set "stdout"]
        val get_stderr: t -> WritableStream.t_0 [@@js.get "stderr"]
        val set_stderr: t -> WritableStream.t_0 -> unit [@@js.set "stderr"]
        val get_ignoreErrors: t -> bool [@@js.get "ignoreErrors"]
        val set_ignoreErrors: t -> bool -> unit [@@js.set "ignoreErrors"]
        val get_colorMode: t -> ([`L_s180_auto[@js "auto"]] [@js.enum]) or_boolean [@@js.get "colorMode"]
        val set_colorMode: t -> ([`L_s180_auto] [@js.enum]) or_boolean -> unit [@@js.set "colorMode"]
        val get_inspectOptions: t -> InspectOptions.t_0 [@@js.get "inspectOptions"]
        val set_inspectOptions: t -> InspectOptions.t_0 -> unit [@@js.set "inspectOptions"]
      end
      module[@js.scope "ConsoleConstructor"] ConsoleConstructor : sig
        type t = console_global_NodeJS_ConsoleConstructor
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_prototype: t -> console_global_Console [@@js.get "prototype"]
        val set_prototype: t -> console_global_Console -> unit [@@js.set "prototype"]
        val create: t -> stdout:WritableStream.t_0 -> ?stderr:WritableStream.t_0 -> ?ignoreErrors:bool -> unit -> console_global_Console [@@js.apply_newable]
        val create': t -> options:console_global_NodeJS_ConsoleConstructorOptions -> console_global_Console [@@js.apply_newable]
      end
      module[@js.scope "Global"] Global : sig
        type t = console_global_NodeJS_Global
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_console: t -> console_global_Console [@@js.get "console"]
        val set_console: t -> console_global_Console -> unit [@@js.set "console"]
      end
    end
  end
  (* CommonJsExport ({ name = [console]
    fullName = [console]
    loc = line 136, col 14 of node_modules/@types/node/console.d.ts }) *)
end
(** @deprecated since v6.3.0 - use constants property exposed by the relevant module instead. *)
module Node_constants : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = constants
    clause = NamespaceImport ([object Object])
    loc = line 3, col 5 of node_modules/@types/node/constants.d.ts } *)
  (* CommonJsExport ({ name = [exp]
    fullName = undefined
    loc = line 4, col 14 of node_modules/@types/node/constants.d.ts }) *)
end
(** @deprecated since v6.3.0 - use constants property exposed by the relevant module instead. *)
module[@js.scope "constants"] Constants : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:os
    clause = ES6Import ([object Object])
    loc = line 9, col 5 of node_modules/@types/node/constants.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:crypto
    clause = ES6Import ([object Object])
    loc = line 10, col 5 of node_modules/@types/node/constants.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:fs
    clause = ES6Import ([object Object])
    loc = line 11, col 5 of node_modules/@types/node/constants.d.ts } *)
  val exp: ((* FIXME: unknown type 'typeof osConstants.errno' *)any, (* FIXME: unknown type 'typeof osConstants.priority' *)any, SignalConstants.t_0, (* FIXME: unknown type 'typeof cryptoConstants' *)any, (* FIXME: unknown type 'typeof fsConstants' *)any) intersection5 [@@js.global "exp"]
  (* CommonJsExport ({ name = [exp]
    fullName = [constants; exp]
    loc = line 18, col 14 of node_modules/@types/node/constants.d.ts }) *)
end
module Node_crypto : sig
  (* export * from 'crypto'; *)
end
module[@js.scope "crypto"] Crypto : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/crypto.d.ts } *)
  module[@js.scope "Certificate"] Certificate : sig
    type t = crypto_Certificate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      @param spkac 
      @return The challenge component of the `spkac` data structure,
      which includes a public key and a challenge.
    *)
    val exportChallenge: t -> spkac:crypto_BinaryLike -> _Buffer [@@js.call "exportChallenge"]
    (**
      @param spkac 
      @param encoding The encoding of the spkac string.
      @return The public key component of the `spkac` data structure,
      which includes a public key and a challenge.
    *)
    val exportPublicKey: t -> spkac:crypto_BinaryLike -> ?encoding:string -> unit -> _Buffer [@@js.call "exportPublicKey"]
    (**
      @param spkac 
      @return `true` if the given `spkac` data structure is valid,
      `false` otherwise.
    *)
    val verifySpkac: t -> spkac:_NodeJS_ArrayBufferView -> bool [@@js.call "verifySpkac"]
  end
  val certificate: (crypto_Certificate, anonymous_interface_73) intersection2 [@@js.global "Certificate"]
  module[@js.scope "constants"] Constants : sig
    val openssl_version_number: float [@@js.global "OPENSSL_VERSION_NUMBER"]
    (** Applies multiple bug workarounds within OpenSSL. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html for detail. *)
    val ssl_op_all: float [@@js.global "SSL_OP_ALL"]
    (** Allows legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. *)
    val ssl_op_allow_unsafe_legacy_renegotiation: float [@@js.global "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION"]
    (** Attempts to use the server's preferences instead of the client's when selecting a cipher. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. *)
    val ssl_op_cipher_server_preference: float [@@js.global "SSL_OP_CIPHER_SERVER_PREFERENCE"]
    (** Instructs OpenSSL to use Cisco's "speshul" version of DTLS_BAD_VER. *)
    val ssl_op_cisco_anyconnect: float [@@js.global "SSL_OP_CISCO_ANYCONNECT"]
    (** Instructs OpenSSL to turn on cookie exchange. *)
    val ssl_op_cookie_exchange: float [@@js.global "SSL_OP_COOKIE_EXCHANGE"]
    (** Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft. *)
    val ssl_op_cryptopro_tlsext_bug: float [@@js.global "SSL_OP_CRYPTOPRO_TLSEXT_BUG"]
    (** Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d. *)
    val ssl_op_dont_insert_empty_fragments: float [@@js.global "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS"]
    (** Instructs OpenSSL to always use the tmp_rsa key when performing RSA operations. *)
    val ssl_op_ephemeral_rsa: float [@@js.global "SSL_OP_EPHEMERAL_RSA"]
    (** Allows initial connection to servers that do not support RI. *)
    val ssl_op_legacy_server_connect: float [@@js.global "SSL_OP_LEGACY_SERVER_CONNECT"]
    val ssl_op_microsoft_big_sslv3_buffer: float [@@js.global "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER"]
    val ssl_op_microsoft_sess_id_bug: float [@@js.global "SSL_OP_MICROSOFT_SESS_ID_BUG"]
    (** Instructs OpenSSL to disable the workaround for a man-in-the-middle protocol-version vulnerability in the SSL 2.0 server implementation. *)
    val ssl_op_msie_sslv2_rsa_padding: float [@@js.global "SSL_OP_MSIE_SSLV2_RSA_PADDING"]
    val ssl_op_netscape_ca_dn_bug: float [@@js.global "SSL_OP_NETSCAPE_CA_DN_BUG"]
    val ssl_op_netscape_challenge_bug: float [@@js.global "SSL_OP_NETSCAPE_CHALLENGE_BUG"]
    val ssl_op_netscape_demo_cipher_change_bug: float [@@js.global "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG"]
    val ssl_op_netscape_reuse_cipher_change_bug: float [@@js.global "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG"]
    (** Instructs OpenSSL to disable support for SSL/TLS compression. *)
    val ssl_op_no_compression: float [@@js.global "SSL_OP_NO_COMPRESSION"]
    val ssl_op_no_query_mtu: float [@@js.global "SSL_OP_NO_QUERY_MTU"]
    (** Instructs OpenSSL to always start a new session when performing renegotiation. *)
    val ssl_op_no_session_resumption_on_renegotiation: float [@@js.global "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION"]
    val sSL_OP_NO_SSLv2: float [@@js.global "SSL_OP_NO_SSLv2"]
    val sSL_OP_NO_SSLv3: float [@@js.global "SSL_OP_NO_SSLv3"]
    val ssl_op_no_ticket: float [@@js.global "SSL_OP_NO_TICKET"]
    val sSL_OP_NO_TLSv1: float [@@js.global "SSL_OP_NO_TLSv1"]
    val sSL_OP_NO_TLSv1_1: float [@@js.global "SSL_OP_NO_TLSv1_1"]
    val sSL_OP_NO_TLSv1_2: float [@@js.global "SSL_OP_NO_TLSv1_2"]
    val ssl_op_pkcs1_check_1: float [@@js.global "SSL_OP_PKCS1_CHECK_1"]
    val ssl_op_pkcs1_check_2: float [@@js.global "SSL_OP_PKCS1_CHECK_2"]
    (** Instructs OpenSSL to always create a new key when using temporary/ephemeral DH parameters. *)
    val ssl_op_single_dh_use: float [@@js.global "SSL_OP_SINGLE_DH_USE"]
    (** Instructs OpenSSL to always create a new key when using temporary/ephemeral ECDH parameters. *)
    val ssl_op_single_ecdh_use: float [@@js.global "SSL_OP_SINGLE_ECDH_USE"]
    val ssl_op_ssleay_080_client_dh_bug: float [@@js.global "SSL_OP_SSLEAY_080_CLIENT_DH_BUG"]
    val ssl_op_sslref2_reuse_cert_type_bug: float [@@js.global "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG"]
    val ssl_op_tls_block_padding_bug: float [@@js.global "SSL_OP_TLS_BLOCK_PADDING_BUG"]
    val ssl_op_tls_d5_bug: float [@@js.global "SSL_OP_TLS_D5_BUG"]
    (** Instructs OpenSSL to disable version rollback attack detection. *)
    val ssl_op_tls_rollback_bug: float [@@js.global "SSL_OP_TLS_ROLLBACK_BUG"]
    val engine_method_rsa: float [@@js.global "ENGINE_METHOD_RSA"]
    val engine_method_dsa: float [@@js.global "ENGINE_METHOD_DSA"]
    val engine_method_dh: float [@@js.global "ENGINE_METHOD_DH"]
    val engine_method_rand: float [@@js.global "ENGINE_METHOD_RAND"]
    val engine_method_ec: float [@@js.global "ENGINE_METHOD_EC"]
    val engine_method_ciphers: float [@@js.global "ENGINE_METHOD_CIPHERS"]
    val engine_method_digests: float [@@js.global "ENGINE_METHOD_DIGESTS"]
    val engine_method_pkey_meths: float [@@js.global "ENGINE_METHOD_PKEY_METHS"]
    val engine_method_pkey_asn1_meths: float [@@js.global "ENGINE_METHOD_PKEY_ASN1_METHS"]
    val engine_method_all: float [@@js.global "ENGINE_METHOD_ALL"]
    val engine_method_none: float [@@js.global "ENGINE_METHOD_NONE"]
    val dh_check_p_not_safe_prime: float [@@js.global "DH_CHECK_P_NOT_SAFE_PRIME"]
    val dh_check_p_not_prime: float [@@js.global "DH_CHECK_P_NOT_PRIME"]
    val dh_unable_to_check_generator: float [@@js.global "DH_UNABLE_TO_CHECK_GENERATOR"]
    val dh_not_suitable_generator: float [@@js.global "DH_NOT_SUITABLE_GENERATOR"]
    val alpn_enabled: float [@@js.global "ALPN_ENABLED"]
    val rsa_pkcs1_padding: float [@@js.global "RSA_PKCS1_PADDING"]
    val rsa_sslv23_padding: float [@@js.global "RSA_SSLV23_PADDING"]
    val rsa_no_padding: float [@@js.global "RSA_NO_PADDING"]
    val rsa_pkcs1_oaep_padding: float [@@js.global "RSA_PKCS1_OAEP_PADDING"]
    val rsa_x931_padding: float [@@js.global "RSA_X931_PADDING"]
    val rsa_pkcs1_pss_padding: float [@@js.global "RSA_PKCS1_PSS_PADDING"]
    (** Sets the salt length for RSA_PKCS1_PSS_PADDING to the digest size when signing or verifying. *)
    val rsa_pss_saltlen_digest: float [@@js.global "RSA_PSS_SALTLEN_DIGEST"]
    (** Sets the salt length for RSA_PKCS1_PSS_PADDING to the maximum permissible value when signing data. *)
    val rsa_pss_saltlen_max_sign: float [@@js.global "RSA_PSS_SALTLEN_MAX_SIGN"]
    (** Causes the salt length for RSA_PKCS1_PSS_PADDING to be determined automatically when verifying a signature. *)
    val rsa_pss_saltlen_auto: float [@@js.global "RSA_PSS_SALTLEN_AUTO"]
    val point_conversion_compressed: float [@@js.global "POINT_CONVERSION_COMPRESSED"]
    val point_conversion_uncompressed: float [@@js.global "POINT_CONVERSION_UNCOMPRESSED"]
    val point_conversion_hybrid: float [@@js.global "POINT_CONVERSION_HYBRID"]
    (** Specifies the built-in default cipher list used by Node.js (colon-separated values). *)
    val defaultCoreCipherList: string [@@js.global "defaultCoreCipherList"]
    (** Specifies the active default cipher list used by the current Node.js process  (colon-separated values). *)
    val defaultCipherList: string [@@js.global "defaultCipherList"]
  end
  module[@js.scope "HashOptions"] HashOptions : sig
    type t = crypto_HashOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      For XOF hash functions such as `shake256`, the
      outputLength option can be used to specify the desired output length in bytes.
    *)
    (**
      For XOF hash functions such as `shake256`, the
      outputLength option can be used to specify the desired output length in bytes.
    *)
    val get_outputLength: t -> float [@@js.get "outputLength"]
    (**
      For XOF hash functions such as `shake256`, the
      outputLength option can be used to specify the desired output length in bytes.
    *)
    val set_outputLength: t -> float -> unit [@@js.set "outputLength"]
    val cast: t -> Stream.TransformOptions.t_0 [@@js.cast]
  end
  (** @deprecated since v10.0.0 *)
  val fips: bool [@@js.global "fips"]
  val createHash: algorithm:string -> ?options:crypto_HashOptions -> unit -> crypto_Hash [@@js.global "createHash"]
  val createHmac: algorithm:string -> key:(crypto_BinaryLike, crypto_KeyObject) union2 -> ?options:Stream.TransformOptions.t_0 -> unit -> crypto_Hmac [@@js.global "createHmac"]
  module BinaryToTextEncoding : sig
    type t = crypto_BinaryToTextEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module CharacterEncoding : sig
    type t = crypto_CharacterEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module LegacyCharacterEncoding : sig
    type t = crypto_LegacyCharacterEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module Encoding : sig
    type t = crypto_Encoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module ECDHKeyFormat : sig
    type t = crypto_ECDHKeyFormat
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "Hash"] Hash : sig
    type t = crypto_Hash
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val copy: t -> t [@@js.call "copy"]
    val update: t -> data:crypto_BinaryLike -> t [@@js.call "update"]
    val update': t -> data:string -> input_encoding:crypto_Encoding -> t [@@js.call "update"]
    val digest: t -> _Buffer [@@js.call "digest"]
    val digest': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "digest"]
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
  end
  module[@js.scope "Hmac"] Hmac : sig
    type t = crypto_Hmac
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val update: t -> data:crypto_BinaryLike -> t [@@js.call "update"]
    val update': t -> data:string -> input_encoding:crypto_Encoding -> t [@@js.call "update"]
    val digest: t -> _Buffer [@@js.call "digest"]
    val digest': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "digest"]
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
  end
  module KeyObjectType : sig
    type t = crypto_KeyObjectType
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "KeyExportOptions"] KeyExportOptions : sig
    type 'T t = 'T crypto_KeyExportOptions
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get_type: 'T t -> ([`L_s272_pkcs1[@js "pkcs1"] | `L_s273_pkcs8[@js "pkcs8"] | `L_s293_sec1[@js "sec1"] | `L_s303_spki[@js "spki"]] [@js.enum]) [@@js.get "type"]
    val set_type: 'T t -> ([`L_s272_pkcs1 | `L_s273_pkcs8 | `L_s293_sec1 | `L_s303_spki] [@js.enum]) -> unit [@@js.set "type"]
    val get_format: 'T t -> 'T [@@js.get "format"]
    val set_format: 'T t -> 'T -> unit [@@js.set "format"]
    val get_cipher: 'T t -> string [@@js.get "cipher"]
    val set_cipher: 'T t -> string -> unit [@@js.set "cipher"]
    val get_passphrase: 'T t -> _Buffer or_string [@@js.get "passphrase"]
    val set_passphrase: 'T t -> _Buffer or_string -> unit [@@js.set "passphrase"]
  end
  module[@js.scope "KeyObject"] KeyObject : sig
    type t = crypto_KeyObject
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val get_asymmetricKeyType: t -> crypto_KeyType [@@js.get "asymmetricKeyType"]
    val set_asymmetricKeyType: t -> crypto_KeyType -> unit [@@js.set "asymmetricKeyType"]
    (**
      For asymmetric keys, this property represents the size of the embedded key in
      bytes. This property is `undefined` for symmetric keys.
    *)
    (**
      For asymmetric keys, this property represents the size of the embedded key in
      bytes. This property is `undefined` for symmetric keys.
    *)
    val get_asymmetricKeySize: t -> float [@@js.get "asymmetricKeySize"]
    (**
      For asymmetric keys, this property represents the size of the embedded key in
      bytes. This property is `undefined` for symmetric keys.
    *)
    val set_asymmetricKeySize: t -> float -> unit [@@js.set "asymmetricKeySize"]
    val export: t -> options:([`L_s269_pem] [@js.enum]) crypto_KeyExportOptions -> _Buffer or_string [@@js.call "export"]
    val export': t -> ?options:([`L_s202_der] [@js.enum]) crypto_KeyExportOptions -> unit -> _Buffer [@@js.call "export"]
    val get_symmetricKeySize: t -> float [@@js.get "symmetricKeySize"]
    val set_symmetricKeySize: t -> float -> unit [@@js.set "symmetricKeySize"]
    val get_type: t -> crypto_KeyObjectType [@@js.get "type"]
    val set_type: t -> crypto_KeyObjectType -> unit [@@js.set "type"]
  end
  module CipherCCMTypes : sig
    type t = crypto_CipherCCMTypes
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module CipherGCMTypes : sig
    type t = crypto_CipherGCMTypes
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module BinaryLike : sig
    type t = crypto_BinaryLike
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module CipherKey : sig
    type t = crypto_CipherKey
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "CipherCCMOptions"] CipherCCMOptions : sig
    type t = crypto_CipherCCMOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_authTagLength: t -> float [@@js.get "authTagLength"]
    val set_authTagLength: t -> float -> unit [@@js.set "authTagLength"]
    val cast: t -> Stream.TransformOptions.t_0 [@@js.cast]
  end
  module[@js.scope "CipherGCMOptions"] CipherGCMOptions : sig
    type t = crypto_CipherGCMOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_authTagLength: t -> float [@@js.get "authTagLength"]
    val set_authTagLength: t -> float -> unit [@@js.set "authTagLength"]
    val cast: t -> Stream.TransformOptions.t_0 [@@js.cast]
  end
  (** @deprecated since v10.0.0 use `createCipheriv()` *)
  val createCipher: algorithm:crypto_CipherCCMTypes -> password:crypto_BinaryLike -> options:crypto_CipherCCMOptions -> crypto_CipherCCM [@@js.global "createCipher"]
  (** @deprecated since v10.0.0 use `createCipheriv()` *)
  val createCipher: algorithm:crypto_CipherGCMTypes -> password:crypto_BinaryLike -> ?options:crypto_CipherGCMOptions -> unit -> crypto_CipherGCM [@@js.global "createCipher"]
  (** @deprecated since v10.0.0 use `createCipheriv()` *)
  val createCipher: algorithm:string -> password:crypto_BinaryLike -> ?options:Stream.TransformOptions.t_0 -> unit -> crypto_Cipher [@@js.global "createCipher"]
  val createCipheriv: algorithm:crypto_CipherCCMTypes -> key:crypto_CipherKey -> iv:crypto_BinaryLike or_null -> options:crypto_CipherCCMOptions -> crypto_CipherCCM [@@js.global "createCipheriv"]
  val createCipheriv: algorithm:crypto_CipherGCMTypes -> key:crypto_CipherKey -> iv:crypto_BinaryLike or_null -> ?options:crypto_CipherGCMOptions -> unit -> crypto_CipherGCM [@@js.global "createCipheriv"]
  val createCipheriv: algorithm:string -> key:crypto_CipherKey -> iv:crypto_BinaryLike or_null -> ?options:Stream.TransformOptions.t_0 -> unit -> crypto_Cipher [@@js.global "createCipheriv"]
  module[@js.scope "Cipher"] Cipher : sig
    type t = crypto_Cipher
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val update: t -> data:crypto_BinaryLike -> _Buffer [@@js.call "update"]
    val update': t -> data:string -> input_encoding:crypto_Encoding -> _Buffer [@@js.call "update"]
    val update'': t -> data:_NodeJS_ArrayBufferView -> input_encoding:never or_undefined -> output_encoding:crypto_Encoding -> string [@@js.call "update"]
    val update''': t -> data:string -> input_encoding:crypto_Encoding or_undefined -> output_encoding:crypto_Encoding -> string [@@js.call "update"]
    val final: t -> _Buffer [@@js.call "final"]
    val final': t -> output_encoding:_BufferEncoding -> string [@@js.call "final"]
    val setAutoPadding: t -> ?auto_padding:bool -> unit -> t [@@js.call "setAutoPadding"]
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
  end
  module[@js.scope "CipherCCM"] CipherCCM : sig
    type t = crypto_CipherCCM
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val setAAD: t -> buffer:_NodeJS_ArrayBufferView -> options:anonymous_interface_39 -> t [@@js.call "setAAD"]
    val getAuthTag: t -> _Buffer [@@js.call "getAuthTag"]
    val cast: t -> crypto_Cipher [@@js.cast]
  end
  module[@js.scope "CipherGCM"] CipherGCM : sig
    type t = crypto_CipherGCM
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val setAAD: t -> buffer:_NodeJS_ArrayBufferView -> ?options:anonymous_interface_39 -> unit -> t [@@js.call "setAAD"]
    val getAuthTag: t -> _Buffer [@@js.call "getAuthTag"]
    val cast: t -> crypto_Cipher [@@js.cast]
  end
  (** @deprecated since v10.0.0 use `createDecipheriv()` *)
  val createDecipher: algorithm:crypto_CipherCCMTypes -> password:crypto_BinaryLike -> options:crypto_CipherCCMOptions -> crypto_DecipherCCM [@@js.global "createDecipher"]
  (** @deprecated since v10.0.0 use `createDecipheriv()` *)
  val createDecipher: algorithm:crypto_CipherGCMTypes -> password:crypto_BinaryLike -> ?options:crypto_CipherGCMOptions -> unit -> crypto_DecipherGCM [@@js.global "createDecipher"]
  (** @deprecated since v10.0.0 use `createDecipheriv()` *)
  val createDecipher: algorithm:string -> password:crypto_BinaryLike -> ?options:Stream.TransformOptions.t_0 -> unit -> crypto_Decipher [@@js.global "createDecipher"]
  val createDecipheriv: algorithm:crypto_CipherCCMTypes -> key:crypto_CipherKey -> iv:crypto_BinaryLike or_null -> options:crypto_CipherCCMOptions -> crypto_DecipherCCM [@@js.global "createDecipheriv"]
  val createDecipheriv: algorithm:crypto_CipherGCMTypes -> key:crypto_CipherKey -> iv:crypto_BinaryLike or_null -> ?options:crypto_CipherGCMOptions -> unit -> crypto_DecipherGCM [@@js.global "createDecipheriv"]
  val createDecipheriv: algorithm:string -> key:crypto_CipherKey -> iv:crypto_BinaryLike or_null -> ?options:Stream.TransformOptions.t_0 -> unit -> crypto_Decipher [@@js.global "createDecipheriv"]
  module[@js.scope "Decipher"] Decipher : sig
    type t = crypto_Decipher
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val update: t -> data:_NodeJS_ArrayBufferView -> _Buffer [@@js.call "update"]
    val update': t -> data:string -> input_encoding:crypto_Encoding -> _Buffer [@@js.call "update"]
    val update'': t -> data:_NodeJS_ArrayBufferView -> input_encoding:never or_undefined -> output_encoding:crypto_Encoding -> string [@@js.call "update"]
    val update''': t -> data:string -> input_encoding:crypto_Encoding or_undefined -> output_encoding:crypto_Encoding -> string [@@js.call "update"]
    val final: t -> _Buffer [@@js.call "final"]
    val final': t -> output_encoding:_BufferEncoding -> string [@@js.call "final"]
    val setAutoPadding: t -> ?auto_padding:bool -> unit -> t [@@js.call "setAutoPadding"]
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
  end
  module[@js.scope "DecipherCCM"] DecipherCCM : sig
    type t = crypto_DecipherCCM
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val setAuthTag: t -> buffer:_NodeJS_ArrayBufferView -> t [@@js.call "setAuthTag"]
    val setAAD: t -> buffer:_NodeJS_ArrayBufferView -> options:anonymous_interface_39 -> t [@@js.call "setAAD"]
    val cast: t -> crypto_Decipher [@@js.cast]
  end
  module[@js.scope "DecipherGCM"] DecipherGCM : sig
    type t = crypto_DecipherGCM
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val setAuthTag: t -> buffer:_NodeJS_ArrayBufferView -> t [@@js.call "setAuthTag"]
    val setAAD: t -> buffer:_NodeJS_ArrayBufferView -> ?options:anonymous_interface_39 -> unit -> t [@@js.call "setAAD"]
    val cast: t -> crypto_Decipher [@@js.cast]
  end
  module[@js.scope "PrivateKeyInput"] PrivateKeyInput : sig
    type t = crypto_PrivateKeyInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_key: t -> _Buffer or_string [@@js.get "key"]
    val set_key: t -> _Buffer or_string -> unit [@@js.set "key"]
    val get_format: t -> crypto_KeyFormat [@@js.get "format"]
    val set_format: t -> crypto_KeyFormat -> unit [@@js.set "format"]
    val get_type: t -> ([`L_s272_pkcs1[@js "pkcs1"] | `L_s273_pkcs8[@js "pkcs8"] | `L_s293_sec1[@js "sec1"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s272_pkcs1 | `L_s273_pkcs8 | `L_s293_sec1] [@js.enum]) -> unit [@@js.set "type"]
    val get_passphrase: t -> _Buffer or_string [@@js.get "passphrase"]
    val set_passphrase: t -> _Buffer or_string -> unit [@@js.set "passphrase"]
  end
  module[@js.scope "PublicKeyInput"] PublicKeyInput : sig
    type t = crypto_PublicKeyInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_key: t -> _Buffer or_string [@@js.get "key"]
    val set_key: t -> _Buffer or_string -> unit [@@js.set "key"]
    val get_format: t -> crypto_KeyFormat [@@js.get "format"]
    val set_format: t -> crypto_KeyFormat -> unit [@@js.set "format"]
    val get_type: t -> ([`L_s272_pkcs1[@js "pkcs1"] | `L_s303_spki[@js "spki"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s272_pkcs1 | `L_s303_spki] [@js.enum]) -> unit [@@js.set "type"]
  end
  val createPrivateKey: key:(_Buffer, crypto_PrivateKeyInput) union2 or_string -> crypto_KeyObject [@@js.global "createPrivateKey"]
  val createPublicKey: key:(([`U_s272_pkcs1 of crypto_PublicKeyInput  | `U_s274_private of crypto_KeyObject  | `U_s275_public of crypto_KeyObject  | `U_s294_secret of crypto_KeyObject  | `U_s303_spki of crypto_PublicKeyInput ] [@js.union on_field "type"]), _Buffer) or_ or_string -> crypto_KeyObject [@@js.global "createPublicKey"]
  val createSecretKey: key:_NodeJS_ArrayBufferView -> crypto_KeyObject [@@js.global "createSecretKey"]
  val createSign: algorithm:string -> ?options:Stream.WritableOptions.t_0 -> unit -> crypto_Signer [@@js.global "createSign"]
  module DSAEncoding : sig
    type t = crypto_DSAEncoding
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "SigningOptions"] SigningOptions : sig
    type t = crypto_SigningOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** See: crypto.constants.RSA_PKCS1_PADDING *)
    (** See: crypto.constants.RSA_PKCS1_PADDING *)
    val get_padding: t -> float [@@js.get "padding"]
    (** See: crypto.constants.RSA_PKCS1_PADDING *)
    val set_padding: t -> float -> unit [@@js.set "padding"]
    val get_saltLength: t -> float [@@js.get "saltLength"]
    val set_saltLength: t -> float -> unit [@@js.set "saltLength"]
    val get_dsaEncoding: t -> crypto_DSAEncoding [@@js.get "dsaEncoding"]
    val set_dsaEncoding: t -> crypto_DSAEncoding -> unit [@@js.set "dsaEncoding"]
  end
  module[@js.scope "SignPrivateKeyInput"] SignPrivateKeyInput : sig
    type t = crypto_SignPrivateKeyInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> crypto_PrivateKeyInput [@@js.cast]
    val cast': t -> crypto_SigningOptions [@@js.cast]
  end
  module[@js.scope "SignKeyObjectInput"] SignKeyObjectInput : sig
    type t = crypto_SignKeyObjectInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_key: t -> crypto_KeyObject [@@js.get "key"]
    val set_key: t -> crypto_KeyObject -> unit [@@js.set "key"]
    val cast: t -> crypto_SigningOptions [@@js.cast]
  end
  module[@js.scope "VerifyPublicKeyInput"] VerifyPublicKeyInput : sig
    type t = crypto_VerifyPublicKeyInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> crypto_PublicKeyInput [@@js.cast]
    val cast': t -> crypto_SigningOptions [@@js.cast]
  end
  module[@js.scope "VerifyKeyObjectInput"] VerifyKeyObjectInput : sig
    type t = crypto_VerifyKeyObjectInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_key: t -> crypto_KeyObject [@@js.get "key"]
    val set_key: t -> crypto_KeyObject -> unit [@@js.set "key"]
    val cast: t -> crypto_SigningOptions [@@js.cast]
  end
  module KeyLike : sig
    type t = crypto_KeyLike
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "Signer"] Signer : sig
    type t = crypto_Signer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val update: t -> data:crypto_BinaryLike -> t [@@js.call "update"]
    val update': t -> data:string -> input_encoding:crypto_Encoding -> t [@@js.call "update"]
    val sign: t -> private_key:(([`U_s202_der of crypto_SignKeyObjectInput  | `U_s232_ieee_p1363 of crypto_SignKeyObjectInput ] [@js.union on_field "dsaEncoding"]), ([`U_s272_pkcs1 of crypto_SignPrivateKeyInput  | `U_s273_pkcs8 of crypto_SignPrivateKeyInput  | `U_s274_private of crypto_KeyLike  | `U_s275_public of crypto_KeyLike  | `U_s293_sec1 of crypto_SignPrivateKeyInput  | `U_s294_secret of crypto_KeyLike ] [@js.union on_field "type"])) union2 -> _Buffer [@@js.call "sign"]
    val sign': t -> private_key:(([`U_s202_der of crypto_SignKeyObjectInput  | `U_s232_ieee_p1363 of crypto_SignKeyObjectInput ] [@js.union on_field "dsaEncoding"]), ([`U_s272_pkcs1 of crypto_SignPrivateKeyInput  | `U_s273_pkcs8 of crypto_SignPrivateKeyInput  | `U_s274_private of crypto_KeyLike  | `U_s275_public of crypto_KeyLike  | `U_s293_sec1 of crypto_SignPrivateKeyInput  | `U_s294_secret of crypto_KeyLike ] [@js.union on_field "type"])) union2 -> output_format:crypto_BinaryToTextEncoding -> string [@@js.call "sign"]
    val cast: t -> Stream.Writable.t_0 [@@js.cast]
  end
  val createVerify: algorithm:string -> ?options:Stream.WritableOptions.t_0 -> unit -> crypto_Verify [@@js.global "createVerify"]
  module[@js.scope "Verify"] Verify : sig
    type t = crypto_Verify
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val update: t -> data:crypto_BinaryLike -> t [@@js.call "update"]
    val update': t -> data:string -> input_encoding:crypto_Encoding -> t [@@js.call "update"]
    val verify: t -> object_:(([`U_s202_der of crypto_VerifyKeyObjectInput  | `U_s232_ieee_p1363 of crypto_VerifyKeyObjectInput ] [@js.union on_field "dsaEncoding"]), ([`U_s272_pkcs1 of crypto_VerifyPublicKeyInput  | `U_s274_private of crypto_KeyLike  | `U_s275_public of crypto_KeyLike  | `U_s294_secret of crypto_KeyLike  | `U_s303_spki of crypto_VerifyPublicKeyInput ] [@js.union on_field "type"])) union2 -> signature:_NodeJS_ArrayBufferView -> bool [@@js.call "verify"]
    val verify': t -> object_:(([`U_s202_der of crypto_VerifyKeyObjectInput  | `U_s232_ieee_p1363 of crypto_VerifyKeyObjectInput ] [@js.union on_field "dsaEncoding"]), ([`U_s272_pkcs1 of crypto_VerifyPublicKeyInput  | `U_s274_private of crypto_KeyLike  | `U_s275_public of crypto_KeyLike  | `U_s294_secret of crypto_KeyLike  | `U_s303_spki of crypto_VerifyPublicKeyInput ] [@js.union on_field "type"])) union2 -> signature:string -> ?signature_format:crypto_BinaryToTextEncoding -> unit -> bool [@@js.call "verify"]
    val cast: t -> Stream.Writable.t_0 [@@js.cast]
  end
  val createDiffieHellman: prime_length:float -> ?generator:_NodeJS_ArrayBufferView or_number -> unit -> crypto_DiffieHellman [@@js.global "createDiffieHellman"]
  val createDiffieHellman: prime:_NodeJS_ArrayBufferView -> crypto_DiffieHellman [@@js.global "createDiffieHellman"]
  val createDiffieHellman: prime:string -> prime_encoding:crypto_BinaryToTextEncoding -> crypto_DiffieHellman [@@js.global "createDiffieHellman"]
  val createDiffieHellman: prime:string -> prime_encoding:crypto_BinaryToTextEncoding -> generator:_NodeJS_ArrayBufferView or_number -> crypto_DiffieHellman [@@js.global "createDiffieHellman"]
  val createDiffieHellman: prime:string -> prime_encoding:crypto_BinaryToTextEncoding -> generator:string -> generator_encoding:crypto_BinaryToTextEncoding -> crypto_DiffieHellman [@@js.global "createDiffieHellman"]
  module[@js.scope "DiffieHellman"] DiffieHellman : sig
    type t = crypto_DiffieHellman
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val generateKeys: t -> _Buffer [@@js.call "generateKeys"]
    val generateKeys': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "generateKeys"]
    val computeSecret: t -> other_public_key:_NodeJS_ArrayBufferView -> _Buffer [@@js.call "computeSecret"]
    val computeSecret': t -> other_public_key:string -> input_encoding:crypto_BinaryToTextEncoding -> _Buffer [@@js.call "computeSecret"]
    val computeSecret'': t -> other_public_key:_NodeJS_ArrayBufferView -> output_encoding:crypto_BinaryToTextEncoding -> string [@@js.call "computeSecret"]
    val computeSecret''': t -> other_public_key:string -> input_encoding:crypto_BinaryToTextEncoding -> output_encoding:crypto_BinaryToTextEncoding -> string [@@js.call "computeSecret"]
    val getPrime: t -> _Buffer [@@js.call "getPrime"]
    val getPrime': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "getPrime"]
    val getGenerator: t -> _Buffer [@@js.call "getGenerator"]
    val getGenerator': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "getGenerator"]
    val getPublicKey: t -> _Buffer [@@js.call "getPublicKey"]
    val getPublicKey': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "getPublicKey"]
    val getPrivateKey: t -> _Buffer [@@js.call "getPrivateKey"]
    val getPrivateKey': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "getPrivateKey"]
    val setPublicKey: t -> public_key:_NodeJS_ArrayBufferView -> unit [@@js.call "setPublicKey"]
    val setPublicKey': t -> public_key:string -> encoding:_BufferEncoding -> unit [@@js.call "setPublicKey"]
    val setPrivateKey: t -> private_key:_NodeJS_ArrayBufferView -> unit [@@js.call "setPrivateKey"]
    val setPrivateKey': t -> private_key:string -> encoding:_BufferEncoding -> unit [@@js.call "setPrivateKey"]
    val get_verifyError: t -> float [@@js.get "verifyError"]
    val set_verifyError: t -> float -> unit [@@js.set "verifyError"]
  end
  val getDiffieHellman: group_name:string -> crypto_DiffieHellman [@@js.global "getDiffieHellman"]
  val pbkdf2: password:crypto_BinaryLike -> salt:crypto_BinaryLike -> iterations:float -> keylen:float -> digest:string -> callback:(err:Error.t_0 or_null -> derivedKey:_Buffer -> any) -> unit [@@js.global "pbkdf2"]
  val pbkdf2Sync: password:crypto_BinaryLike -> salt:crypto_BinaryLike -> iterations:float -> keylen:float -> digest:string -> _Buffer [@@js.global "pbkdf2Sync"]
  val randomBytes: size:float -> _Buffer [@@js.global "randomBytes"]
  val randomBytes: size:float -> callback:(err:Error.t_0 or_null -> buf:_Buffer -> unit) -> unit [@@js.global "randomBytes"]
  val pseudoRandomBytes: size:float -> _Buffer [@@js.global "pseudoRandomBytes"]
  val pseudoRandomBytes: size:float -> callback:(err:Error.t_0 or_null -> buf:_Buffer -> unit) -> unit [@@js.global "pseudoRandomBytes"]
  val randomInt: max:float -> float [@@js.global "randomInt"]
  val randomInt: min:float -> max:float -> float [@@js.global "randomInt"]
  val randomInt: max:float -> callback:(err:Error.t_0 or_null -> value:float -> unit) -> unit [@@js.global "randomInt"]
  val randomInt: min:float -> max:float -> callback:(err:Error.t_0 or_null -> value:float -> unit) -> unit [@@js.global "randomInt"]
  val randomFillSync: buffer:'T -> ?offset:float -> ?size:float -> unit -> 'T [@@js.global "randomFillSync"]
  val randomFill: buffer:'T -> callback:(err:Error.t_0 or_null -> buf:'T -> unit) -> unit [@@js.global "randomFill"]
  val randomFill: buffer:'T -> offset:float -> callback:(err:Error.t_0 or_null -> buf:'T -> unit) -> unit [@@js.global "randomFill"]
  val randomFill: buffer:'T -> offset:float -> size:float -> callback:(err:Error.t_0 or_null -> buf:'T -> unit) -> unit [@@js.global "randomFill"]
  module[@js.scope "ScryptOptions"] ScryptOptions : sig
    type t = crypto_ScryptOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_cost: t -> float [@@js.get "cost"]
    val set_cost: t -> float -> unit [@@js.set "cost"]
    val get_blockSize: t -> float [@@js.get "blockSize"]
    val set_blockSize: t -> float -> unit [@@js.set "blockSize"]
    val get_parallelization: t -> float [@@js.get "parallelization"]
    val set_parallelization: t -> float -> unit [@@js.set "parallelization"]
    val get_N: t -> float [@@js.get "N"]
    val set_N: t -> float -> unit [@@js.set "N"]
    val get_r: t -> float [@@js.get "r"]
    val set_r: t -> float -> unit [@@js.set "r"]
    val get_p: t -> float [@@js.get "p"]
    val set_p: t -> float -> unit [@@js.set "p"]
    val get_maxmem: t -> float [@@js.get "maxmem"]
    val set_maxmem: t -> float -> unit [@@js.set "maxmem"]
  end
  val scrypt: password:crypto_BinaryLike -> salt:crypto_BinaryLike -> keylen:float -> callback:(err:Error.t_0 or_null -> derivedKey:_Buffer -> unit) -> unit [@@js.global "scrypt"]
  val scrypt: password:crypto_BinaryLike -> salt:crypto_BinaryLike -> keylen:float -> options:crypto_ScryptOptions -> callback:(err:Error.t_0 or_null -> derivedKey:_Buffer -> unit) -> unit [@@js.global "scrypt"]
  val scryptSync: password:crypto_BinaryLike -> salt:crypto_BinaryLike -> keylen:float -> ?options:crypto_ScryptOptions -> unit -> _Buffer [@@js.global "scryptSync"]
  module[@js.scope "RsaPublicKey"] RsaPublicKey : sig
    type t = crypto_RsaPublicKey
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_key: t -> crypto_KeyLike [@@js.get "key"]
    val set_key: t -> crypto_KeyLike -> unit [@@js.set "key"]
    val get_padding: t -> float [@@js.get "padding"]
    val set_padding: t -> float -> unit [@@js.set "padding"]
  end
  module[@js.scope "RsaPrivateKey"] RsaPrivateKey : sig
    type t = crypto_RsaPrivateKey
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_key: t -> crypto_KeyLike [@@js.get "key"]
    val set_key: t -> crypto_KeyLike -> unit [@@js.set "key"]
    val get_passphrase: t -> string [@@js.get "passphrase"]
    val set_passphrase: t -> string -> unit [@@js.set "passphrase"]
    (** default: 'sha1' *)
    (** default: 'sha1' *)
    val get_oaepHash: t -> string [@@js.get "oaepHash"]
    (** default: 'sha1' *)
    val set_oaepHash: t -> string -> unit [@@js.set "oaepHash"]
    val get_oaepLabel: t -> _NodeJS_TypedArray [@@js.get "oaepLabel"]
    val set_oaepLabel: t -> _NodeJS_TypedArray -> unit [@@js.set "oaepLabel"]
    val get_padding: t -> float [@@js.get "padding"]
    val set_padding: t -> float -> unit [@@js.set "padding"]
  end
  val publicEncrypt: key:(crypto_KeyLike, crypto_RsaPrivateKey, crypto_RsaPublicKey) union3 -> buffer:_NodeJS_ArrayBufferView -> _Buffer [@@js.global "publicEncrypt"]
  val publicDecrypt: key:(crypto_KeyLike, crypto_RsaPrivateKey, crypto_RsaPublicKey) union3 -> buffer:_NodeJS_ArrayBufferView -> _Buffer [@@js.global "publicDecrypt"]
  val privateDecrypt: private_key:(crypto_KeyLike, crypto_RsaPrivateKey) union2 -> buffer:_NodeJS_ArrayBufferView -> _Buffer [@@js.global "privateDecrypt"]
  val privateEncrypt: private_key:(crypto_KeyLike, crypto_RsaPrivateKey) union2 -> buffer:_NodeJS_ArrayBufferView -> _Buffer [@@js.global "privateEncrypt"]
  val getCiphers: unit -> string list [@@js.global "getCiphers"]
  val getCurves: unit -> string list [@@js.global "getCurves"]
  val getFips: unit -> ([`L_n_0[@js 0] | `L_n_1[@js 1]] [@js.enum]) [@@js.global "getFips"]
  val getHashes: unit -> string list [@@js.global "getHashes"]
  module[@js.scope "ECDH"] ECDH : sig
    type t = crypto_ECDH
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: unit -> t [@@js.create]
    val convertKey: key:crypto_BinaryLike -> curve:string -> ?inputEncoding:crypto_BinaryToTextEncoding -> ?outputEncoding:([`L_s181_base64 | `L_s226_hex | `L_s242_latin1] [@js.enum]) -> ?format:([`L_s192_compressed | `L_s231_hybrid | `L_s321_uncompressed] [@js.enum]) -> unit -> _Buffer or_string [@@js.global "convertKey"]
    val generateKeys: t -> _Buffer [@@js.call "generateKeys"]
    val generateKeys': t -> encoding:crypto_BinaryToTextEncoding -> ?format:crypto_ECDHKeyFormat -> unit -> string [@@js.call "generateKeys"]
    val computeSecret: t -> other_public_key:_NodeJS_ArrayBufferView -> _Buffer [@@js.call "computeSecret"]
    val computeSecret': t -> other_public_key:string -> input_encoding:crypto_BinaryToTextEncoding -> _Buffer [@@js.call "computeSecret"]
    val computeSecret'': t -> other_public_key:_NodeJS_ArrayBufferView -> output_encoding:crypto_BinaryToTextEncoding -> string [@@js.call "computeSecret"]
    val computeSecret''': t -> other_public_key:string -> input_encoding:crypto_BinaryToTextEncoding -> output_encoding:crypto_BinaryToTextEncoding -> string [@@js.call "computeSecret"]
    val getPrivateKey: t -> _Buffer [@@js.call "getPrivateKey"]
    val getPrivateKey': t -> encoding:crypto_BinaryToTextEncoding -> string [@@js.call "getPrivateKey"]
    val getPublicKey: t -> _Buffer [@@js.call "getPublicKey"]
    val getPublicKey': t -> encoding:crypto_BinaryToTextEncoding -> ?format:crypto_ECDHKeyFormat -> unit -> string [@@js.call "getPublicKey"]
    val setPrivateKey: t -> private_key:_NodeJS_ArrayBufferView -> unit [@@js.call "setPrivateKey"]
    val setPrivateKey': t -> private_key:string -> encoding:crypto_BinaryToTextEncoding -> unit [@@js.call "setPrivateKey"]
  end
  val createECDH: curve_name:string -> crypto_ECDH [@@js.global "createECDH"]
  val timingSafeEqual: a:_NodeJS_ArrayBufferView -> b:_NodeJS_ArrayBufferView -> bool [@@js.global "timingSafeEqual"]
  (** @deprecated since v10.0.0 *)
  val default_encoding: _BufferEncoding [@@js.global "DEFAULT_ENCODING"]
  module KeyType : sig
    type t = crypto_KeyType
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module KeyFormat : sig
    type t = crypto_KeyFormat
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "BasePrivateKeyEncodingOptions"] BasePrivateKeyEncodingOptions : sig
    type 'T t = 'T crypto_BasePrivateKeyEncodingOptions
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get_format: 'T t -> 'T [@@js.get "format"]
    val set_format: 'T t -> 'T -> unit [@@js.set "format"]
    val get_cipher: 'T t -> string [@@js.get "cipher"]
    val set_cipher: 'T t -> string -> unit [@@js.set "cipher"]
    val get_passphrase: 'T t -> string [@@js.get "passphrase"]
    val set_passphrase: 'T t -> string -> unit [@@js.set "passphrase"]
  end
  module[@js.scope "KeyPairKeyObjectResult"] KeyPairKeyObjectResult : sig
    type t = crypto_KeyPairKeyObjectResult
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_publicKey: t -> crypto_KeyObject [@@js.get "publicKey"]
    val set_publicKey: t -> crypto_KeyObject -> unit [@@js.set "publicKey"]
    val get_privateKey: t -> crypto_KeyObject [@@js.get "privateKey"]
    val set_privateKey: t -> crypto_KeyObject -> unit [@@js.set "privateKey"]
  end
  module ED25519KeyPairKeyObjectOptions : sig
    type t = crypto_ED25519KeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module ED448KeyPairKeyObjectOptions : sig
    type t = crypto_ED448KeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module X25519KeyPairKeyObjectOptions : sig
    type t = crypto_X25519KeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module X448KeyPairKeyObjectOptions : sig
    type t = crypto_X448KeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "ECKeyPairKeyObjectOptions"] ECKeyPairKeyObjectOptions : sig
    type t = crypto_ECKeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Name of the curve to use. *)
    (** Name of the curve to use. *)
    val get_namedCurve: t -> string [@@js.get "namedCurve"]
    (** Name of the curve to use. *)
    val set_namedCurve: t -> string -> unit [@@js.set "namedCurve"]
  end
  module[@js.scope "RSAKeyPairKeyObjectOptions"] RSAKeyPairKeyObjectOptions : sig
    type t = crypto_RSAKeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Key size in bits *)
    (** Key size in bits *)
    val get_modulusLength: t -> float [@@js.get "modulusLength"]
    (** Key size in bits *)
    val set_modulusLength: t -> float -> unit [@@js.set "modulusLength"]
    (** default: 0x10001 *)
    (** default: 0x10001 *)
    val get_publicExponent: t -> float [@@js.get "publicExponent"]
    (** default: 0x10001 *)
    val set_publicExponent: t -> float -> unit [@@js.set "publicExponent"]
  end
  module[@js.scope "DSAKeyPairKeyObjectOptions"] DSAKeyPairKeyObjectOptions : sig
    type t = crypto_DSAKeyPairKeyObjectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Key size in bits *)
    (** Key size in bits *)
    val get_modulusLength: t -> float [@@js.get "modulusLength"]
    (** Key size in bits *)
    val set_modulusLength: t -> float -> unit [@@js.set "modulusLength"]
    (** Size of q in bits *)
    (** Size of q in bits *)
    val get_divisorLength: t -> float [@@js.get "divisorLength"]
    (** Size of q in bits *)
    val set_divisorLength: t -> float -> unit [@@js.set "divisorLength"]
  end
  module[@js.scope "RSAKeyPairOptions"] RSAKeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_RSAKeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    (** Key size in bits *)
    (** Key size in bits *)
    val get_modulusLength: ('PubF, 'PrivF) t -> float [@@js.get "modulusLength"]
    (** Key size in bits *)
    val set_modulusLength: ('PubF, 'PrivF) t -> float -> unit [@@js.set "modulusLength"]
    (** default: 0x10001 *)
    (** default: 0x10001 *)
    val get_publicExponent: ('PubF, 'PrivF) t -> float [@@js.get "publicExponent"]
    (** default: 0x10001 *)
    val set_publicExponent: ('PubF, 'PrivF) t -> float -> unit [@@js.set "publicExponent"]
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_59 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_59 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_58) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_58) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "DSAKeyPairOptions"] DSAKeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_DSAKeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    (** Key size in bits *)
    (** Key size in bits *)
    val get_modulusLength: ('PubF, 'PrivF) t -> float [@@js.get "modulusLength"]
    (** Key size in bits *)
    val set_modulusLength: ('PubF, 'PrivF) t -> float -> unit [@@js.set "modulusLength"]
    (** Size of q in bits *)
    (** Size of q in bits *)
    val get_divisorLength: ('PubF, 'PrivF) t -> float [@@js.get "divisorLength"]
    (** Size of q in bits *)
    val set_divisorLength: ('PubF, 'PrivF) t -> float -> unit [@@js.set "divisorLength"]
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "ECKeyPairOptions"] ECKeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_ECKeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    (** Name of the curve to use. *)
    (** Name of the curve to use. *)
    val get_namedCurve: ('PubF, 'PrivF) t -> string [@@js.get "namedCurve"]
    (** Name of the curve to use. *)
    val set_namedCurve: ('PubF, 'PrivF) t -> string -> unit [@@js.set "namedCurve"]
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_59 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_59 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_60) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_60) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "ED25519KeyPairOptions"] ED25519KeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_ED25519KeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "ED448KeyPairOptions"] ED448KeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_ED448KeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "X25519KeyPairOptions"] X25519KeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_X25519KeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "X448KeyPairOptions"] X448KeyPairOptions : sig
    type ('PubF, 'PrivF) t = ('PubF, 'PrivF) crypto_X448KeyPairOptions
    val t_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t
    type ('PubF, 'PrivF) t_2 = ('PubF, 'PrivF) t
    val t_2_to_js: ('PubF -> Ojs.t) -> ('PrivF -> Ojs.t) -> ('PubF, 'PrivF) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'PubF) -> (Ojs.t -> 'PrivF) -> Ojs.t -> ('PubF, 'PrivF) t_2
    val get_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 [@@js.get "publicKeyEncoding"]
    val set_publicKeyEncoding: ('PubF, 'PrivF) t -> anonymous_interface_57 -> unit [@@js.set "publicKeyEncoding"]
    val get_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 [@@js.get "privateKeyEncoding"]
    val set_privateKeyEncoding: ('PubF, 'PrivF) t -> ('PrivF crypto_BasePrivateKeyEncodingOptions, anonymous_interface_56) intersection2 -> unit [@@js.set "privateKeyEncoding"]
  end
  module[@js.scope "KeyPairSyncResult"] KeyPairSyncResult : sig
    type ('T1, 'T2) t = ('T1, 'T2) crypto_KeyPairSyncResult
    val t_to_js: ('T1 -> Ojs.t) -> ('T2 -> Ojs.t) -> ('T1, 'T2) t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T1) -> (Ojs.t -> 'T2) -> Ojs.t -> ('T1, 'T2) t
    type ('T1, 'T2) t_2 = ('T1, 'T2) t
    val t_2_to_js: ('T1 -> Ojs.t) -> ('T2 -> Ojs.t) -> ('T1, 'T2) t_2 -> Ojs.t
    val t_2_of_js: (Ojs.t -> 'T1) -> (Ojs.t -> 'T2) -> Ojs.t -> ('T1, 'T2) t_2
    val get_publicKey: ('T1, 'T2) t -> 'T1 [@@js.get "publicKey"]
    val set_publicKey: ('T1, 'T2) t -> 'T1 -> unit [@@js.set "publicKey"]
    val get_privateKey: ('T1, 'T2) t -> 'T2 [@@js.get "privateKey"]
    val set_privateKey: ('T1, 'T2) t -> 'T2 -> unit [@@js.set "privateKey"]
  end
  val generateKeyPairSync: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_RSAKeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_RSAKeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_RSAKeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_RSAKeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s292_rsa] [@js.enum]) -> options:crypto_RSAKeyPairKeyObjectOptions -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_DSAKeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_DSAKeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_DSAKeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_DSAKeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s207_dsa] [@js.enum]) -> options:crypto_DSAKeyPairKeyObjectOptions -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ECKeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ECKeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ECKeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ECKeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s208_ec] [@js.enum]) -> options:crypto_ECKeyPairKeyObjectOptions -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED25519KeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED25519KeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED25519KeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED25519KeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s209_ed25519] [@js.enum]) -> ?options:crypto_ED25519KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED448KeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED448KeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED448KeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED448KeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s210_ed448] [@js.enum]) -> ?options:crypto_ED448KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X25519KeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X25519KeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X25519KeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X25519KeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s333_x25519] [@js.enum]) -> ?options:crypto_X25519KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X448KeyPairOptions -> (string, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X448KeyPairOptions -> (string, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X448KeyPairOptions -> (_Buffer, string) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X448KeyPairOptions -> (_Buffer, _Buffer) crypto_KeyPairSyncResult [@@js.global "generateKeyPairSync"]
  val generateKeyPairSync: type_:([`L_s334_x448] [@js.enum]) -> ?options:crypto_X448KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult [@@js.global "generateKeyPairSync"]
  val generateKeyPair: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_RSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_RSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_RSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_RSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s292_rsa] [@js.enum]) -> options:crypto_RSAKeyPairKeyObjectOptions -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_DSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_DSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_DSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_DSAKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s207_dsa] [@js.enum]) -> options:crypto_DSAKeyPairKeyObjectOptions -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ECKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ECKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ECKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ECKeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s208_ec] [@js.enum]) -> options:crypto_ECKeyPairKeyObjectOptions -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s209_ed25519] [@js.enum]) -> options:crypto_ED25519KeyPairKeyObjectOptions or_undefined -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s210_ed448] [@js.enum]) -> options:crypto_ED448KeyPairKeyObjectOptions or_undefined -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X25519KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s333_x25519] [@js.enum]) -> options:crypto_X25519KeyPairKeyObjectOptions or_undefined -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:string -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:string -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X448KeyPairOptions -> callback:(err:Error.t_0 or_null -> publicKey:_Buffer -> privateKey:_Buffer -> unit) -> unit [@@js.global "generateKeyPair"]
  val generateKeyPair: type_:([`L_s334_x448] [@js.enum]) -> options:crypto_X448KeyPairKeyObjectOptions or_undefined -> callback:(err:Error.t_0 or_null -> publicKey:crypto_KeyObject -> privateKey:crypto_KeyObject -> unit) -> unit [@@js.global "generateKeyPair"]
  module[@js.scope "generateKeyPair"] GenerateKeyPair : sig
    val __promisify__: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_RSAKeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_RSAKeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_RSAKeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s292_rsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_RSAKeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s292_rsa] [@js.enum]) -> options:crypto_RSAKeyPairKeyObjectOptions -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_DSAKeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_DSAKeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_DSAKeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s207_dsa] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_DSAKeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s207_dsa] [@js.enum]) -> options:crypto_DSAKeyPairKeyObjectOptions -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ECKeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ECKeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ECKeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s208_ec] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ECKeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s208_ec] [@js.enum]) -> options:crypto_ECKeyPairKeyObjectOptions -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED25519KeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED25519KeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED25519KeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s209_ed25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED25519KeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s209_ed25519] [@js.enum]) -> ?options:crypto_ED25519KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED448KeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED448KeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_ED448KeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s210_ed448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_ED448KeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s210_ed448] [@js.enum]) -> ?options:crypto_ED448KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X25519KeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X25519KeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X25519KeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s333_x25519] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X25519KeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s333_x25519] [@js.enum]) -> ?options:crypto_X25519KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X448KeyPairOptions -> anonymous_interface_44 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s269_pem] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X448KeyPairOptions -> anonymous_interface_43 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s269_pem] [@js.enum])) crypto_X448KeyPairOptions -> anonymous_interface_42 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s334_x448] [@js.enum]) -> options:(([`L_s202_der] [@js.enum]), ([`L_s202_der] [@js.enum])) crypto_X448KeyPairOptions -> anonymous_interface_41 Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: type_:([`L_s334_x448] [@js.enum]) -> ?options:crypto_X448KeyPairKeyObjectOptions -> unit -> crypto_KeyPairKeyObjectResult Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Calculates and returns the signature for `data` using the given private key and
    algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is
    dependent upon the key type (especially Ed25519 and Ed448).
    
    If `key` is not a \[`KeyObject`\]\[\], this function behaves as if `key` had been
    passed to \[`crypto.createPrivateKey()`\]\[\].
  *)
  val sign: algorithm:string or_null_or_undefined -> data:_NodeJS_ArrayBufferView -> key:(([`U_s202_der of crypto_SignKeyObjectInput  | `U_s232_ieee_p1363 of crypto_SignKeyObjectInput ] [@js.union on_field "dsaEncoding"]), ([`U_s272_pkcs1 of crypto_SignPrivateKeyInput  | `U_s273_pkcs8 of crypto_SignPrivateKeyInput  | `U_s274_private of crypto_KeyLike  | `U_s275_public of crypto_KeyLike  | `U_s293_sec1 of crypto_SignPrivateKeyInput  | `U_s294_secret of crypto_KeyLike ] [@js.union on_field "type"])) union2 -> _Buffer [@@js.global "sign"]
  (**
    Calculates and returns the signature for `data` using the given private key and
    algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is
    dependent upon the key type (especially Ed25519 and Ed448).
    
    If `key` is not a \[`KeyObject`\]\[\], this function behaves as if `key` had been
    passed to \[`crypto.createPublicKey()`\]\[\].
  *)
  val verify: algorithm:string or_null_or_undefined -> data:_NodeJS_ArrayBufferView -> key:(([`U_s202_der of crypto_VerifyKeyObjectInput  | `U_s232_ieee_p1363 of crypto_VerifyKeyObjectInput ] [@js.union on_field "dsaEncoding"]), ([`U_s272_pkcs1 of crypto_VerifyPublicKeyInput  | `U_s274_private of crypto_KeyLike  | `U_s275_public of crypto_KeyLike  | `U_s294_secret of crypto_KeyLike  | `U_s303_spki of crypto_VerifyPublicKeyInput ] [@js.union on_field "type"])) union2 -> signature:_NodeJS_ArrayBufferView -> bool [@@js.global "verify"]
  (**
    Computes the Diffie-Hellman secret based on a privateKey and a publicKey.
    Both keys must have the same asymmetricKeyType, which must be one of
    'dh' (for Diffie-Hellman), 'ec' (for ECDH), 'x448', or 'x25519' (for ECDH-ES).
  *)
  val diffieHellman: options:anonymous_interface_40 -> _Buffer [@@js.global "diffieHellman"]
end
module Node_dgram : sig
  (* export * from 'dgram'; *)
end
module[@js.scope "dgram"] Dgram : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/dgram.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:dns
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/dgram.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/dgram.d.ts } *)
  module[@js.scope "RemoteInfo"] RemoteInfo : sig
    type t = dgram_RemoteInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_family: t -> ([`L_s62_IPv4[@js "IPv4"] | `L_s63_IPv6[@js "IPv6"]] [@js.enum]) [@@js.get "family"]
    val set_family: t -> ([`L_s62_IPv4 | `L_s63_IPv6] [@js.enum]) -> unit [@@js.set "family"]
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_size: t -> float [@@js.get "size"]
    val set_size: t -> float -> unit [@@js.set "size"]
  end
  module[@js.scope "BindOptions"] BindOptions : sig
    type t = dgram_BindOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_exclusive: t -> bool [@@js.get "exclusive"]
    val set_exclusive: t -> bool -> unit [@@js.set "exclusive"]
    val get_fd: t -> float [@@js.get "fd"]
    val set_fd: t -> float -> unit [@@js.set "fd"]
  end
  module SocketType : sig
    type t = dgram_SocketType
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "SocketOptions"] SocketOptions : sig
    type t = dgram_SocketOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> dgram_SocketType [@@js.get "type"]
    val set_type: t -> dgram_SocketType -> unit [@@js.set "type"]
    val get_reuseAddr: t -> bool [@@js.get "reuseAddr"]
    val set_reuseAddr: t -> bool -> unit [@@js.set "reuseAddr"]
    (** default: false *)
    (** default: false *)
    val get_ipv6Only: t -> bool [@@js.get "ipv6Only"]
    (** default: false *)
    val set_ipv6Only: t -> bool -> unit [@@js.set "ipv6Only"]
    val get_recvBufferSize: t -> float [@@js.get "recvBufferSize"]
    val set_recvBufferSize: t -> float -> unit [@@js.set "recvBufferSize"]
    val get_sendBufferSize: t -> float [@@js.get "sendBufferSize"]
    val set_sendBufferSize: t -> float -> unit [@@js.set "sendBufferSize"]
    val lookup: t -> hostname:string -> options:dns_LookupOneOptions -> callback:(err:_NodeJS_ErrnoException or_null -> address:string -> family:float -> unit) -> unit [@@js.call "lookup"]
  end
  val createSocket: type_:dgram_SocketType -> ?callback:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> unit -> dgram_Socket [@@js.global "createSocket"]
  val createSocket: options:dgram_SocketOptions -> ?callback:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> unit -> dgram_Socket [@@js.global "createSocket"]
  module[@js.scope "Socket"] Socket : sig
    type t = dgram_Socket
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val addMembership: t -> multicastAddress:string -> ?multicastInterface:string -> unit -> unit [@@js.call "addMembership"]
    val address: t -> AddressInfo.t_0 [@@js.call "address"]
    val bind: t -> ?port:float -> ?address:string -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "bind"]
    val bind': t -> ?port:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "bind"]
    val bind'': t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "bind"]
    val bind''': t -> options:dgram_BindOptions -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "bind"]
    val close: t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "close"]
    val connect: t -> port:float -> ?address:string -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "connect"]
    val connect': t -> port:float -> callback:(unit -> unit) -> unit [@@js.call "connect"]
    val disconnect: t -> unit [@@js.call "disconnect"]
    val dropMembership: t -> multicastAddress:string -> ?multicastInterface:string -> unit -> unit [@@js.call "dropMembership"]
    val getRecvBufferSize: t -> float [@@js.call "getRecvBufferSize"]
    val getSendBufferSize: t -> float [@@js.call "getSendBufferSize"]
    val ref: t -> t [@@js.call "ref"]
    val remoteAddress: t -> AddressInfo.t_0 [@@js.call "remoteAddress"]
    val send: t -> msg:(Uint8Array.t_0, any list) union2 or_string -> ?port:float -> ?address:string -> ?callback:(error:Error.t_0 or_null -> bytes:float -> unit) -> unit -> unit [@@js.call "send"]
    val send': t -> msg:(Uint8Array.t_0, any list) union2 or_string -> ?port:float -> ?callback:(error:Error.t_0 or_null -> bytes:float -> unit) -> unit -> unit [@@js.call "send"]
    val send'': t -> msg:(Uint8Array.t_0, any list) union2 or_string -> ?callback:(error:Error.t_0 or_null -> bytes:float -> unit) -> unit -> unit [@@js.call "send"]
    val send''': t -> msg:Uint8Array.t_0 or_string -> offset:float -> length:float -> ?port:float -> ?address:string -> ?callback:(error:Error.t_0 or_null -> bytes:float -> unit) -> unit -> unit [@@js.call "send"]
    val send'''': t -> msg:Uint8Array.t_0 or_string -> offset:float -> length:float -> ?port:float -> ?callback:(error:Error.t_0 or_null -> bytes:float -> unit) -> unit -> unit [@@js.call "send"]
    val send''''': t -> msg:Uint8Array.t_0 or_string -> offset:float -> length:float -> ?callback:(error:Error.t_0 or_null -> bytes:float -> unit) -> unit -> unit [@@js.call "send"]
    val setBroadcast: t -> flag:bool -> unit [@@js.call "setBroadcast"]
    val setMulticastInterface: t -> multicastInterface:string -> unit [@@js.call "setMulticastInterface"]
    val setMulticastLoopback: t -> flag:bool -> unit [@@js.call "setMulticastLoopback"]
    val setMulticastTTL: t -> ttl:float -> unit [@@js.call "setMulticastTTL"]
    val setRecvBufferSize: t -> size:float -> unit [@@js.call "setRecvBufferSize"]
    val setSendBufferSize: t -> size:float -> unit [@@js.call "setSendBufferSize"]
    val setTTL: t -> ttl:float -> unit [@@js.call "setTTL"]
    val unref: t -> t [@@js.call "unref"]
    (**
      Tells the kernel to join a source-specific multicast channel at the given
      `sourceAddress` and `groupAddress`, using the `multicastInterface` with the
      `IP_ADD_SOURCE_MEMBERSHIP` socket option.
      If the `multicastInterface` argument
      is not specified, the operating system will choose one interface and will add
      membership to it.
      To add membership to every available interface, call
      `socket.addSourceSpecificMembership()` multiple times, once per interface.
    *)
    val addSourceSpecificMembership: t -> sourceAddress:string -> groupAddress:string -> ?multicastInterface:string -> unit -> unit [@@js.call "addSourceSpecificMembership"]
    (**
      Instructs the kernel to leave a source-specific multicast channel at the given
      `sourceAddress` and `groupAddress` using the `IP_DROP_SOURCE_MEMBERSHIP`
      socket option. This method is automatically called by the kernel when the
      socket is closed or the process terminates, so most apps will never have
      reason to call this.
      
      If `multicastInterface` is not specified, the operating system will attempt to
      drop membership on all valid interfaces.
    *)
    val dropSourceSpecificMembership: t -> sourceAddress:string -> groupAddress:string -> ?multicastInterface:string -> unit -> unit [@@js.call "dropSourceSpecificMembership"]
    (**
      events.EventEmitter
      1. close
      2. connect
      3. error
      4. listening
      5. message
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. connect
      3. error
      4. listening
      5. message
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. connect
      3. error
      4. listening
      5. message
    *)
    val addListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. connect
      3. error
      4. listening
      5. message
    *)
    val addListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. connect
      3. error
      4. listening
      5. message
    *)
    val addListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. connect
      3. error
      4. listening
      5. message
    *)
    val addListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s193_connect] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s246_listening] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s251_message] [@js.enum]) -> msg:_Buffer -> rinfo:dgram_RemoteInfo -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:(msg:_Buffer -> rinfo:dgram_RemoteInfo -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
end
module Node_dns : sig
  (* export * from 'dns'; *)
end
module[@js.scope "dns"] Dns : sig
  val addrconfig: float [@@js.global "ADDRCONFIG"]
  val v4mapped: float [@@js.global "V4MAPPED"]
  (**
    If `dns.V4MAPPED` is specified, return resolved IPv6 addresses as
    well as IPv4 mapped IPv6 addresses.
  *)
  val all: float [@@js.global "ALL"]
  module[@js.scope "LookupOptions"] LookupOptions : sig
    type t = dns_LookupOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_family: t -> float [@@js.get "family"]
    val set_family: t -> float -> unit [@@js.set "family"]
    val get_hints: t -> float [@@js.get "hints"]
    val set_hints: t -> float -> unit [@@js.set "hints"]
    val get_all: t -> bool [@@js.get "all"]
    val set_all: t -> bool -> unit [@@js.set "all"]
    val get_verbatim: t -> bool [@@js.get "verbatim"]
    val set_verbatim: t -> bool -> unit [@@js.set "verbatim"]
  end
  module[@js.scope "LookupOneOptions"] LookupOneOptions : sig
    type t = dns_LookupOneOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_all: t -> ([`L_b_false[@js false]] [@js.enum]) [@@js.get "all"]
    val set_all: t -> ([`L_b_false] [@js.enum]) -> unit [@@js.set "all"]
    val cast: t -> dns_LookupOptions [@@js.cast]
  end
  module[@js.scope "LookupAllOptions"] LookupAllOptions : sig
    type t = dns_LookupAllOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_all: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "all"]
    val set_all: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "all"]
    val cast: t -> dns_LookupOptions [@@js.cast]
  end
  module[@js.scope "LookupAddress"] LookupAddress : sig
    type t = dns_LookupAddress
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_family: t -> float [@@js.get "family"]
    val set_family: t -> float -> unit [@@js.set "family"]
  end
  val lookup: hostname:string -> family:float -> callback:(err:_NodeJS_ErrnoException or_null -> address:string -> family:float -> unit) -> unit [@@js.global "lookup"]
  val lookup: hostname:string -> options:dns_LookupOneOptions -> callback:(err:_NodeJS_ErrnoException or_null -> address:string -> family:float -> unit) -> unit [@@js.global "lookup"]
  val lookup: hostname:string -> options:dns_LookupAllOptions -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_LookupAddress list -> unit) -> unit [@@js.global "lookup"]
  val lookup: hostname:string -> options:dns_LookupOptions -> callback:(err:_NodeJS_ErrnoException or_null -> address:dns_LookupAddress list or_string -> family:float -> unit) -> unit [@@js.global "lookup"]
  val lookup: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> address:string -> family:float -> unit) -> unit [@@js.global "lookup"]
  module[@js.scope "lookup"] Lookup : sig
    val __promisify__: hostname:string -> options:dns_LookupAllOptions -> dns_LookupAddress list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> ?options:dns_LookupOneOptions or_number -> unit -> dns_LookupAddress Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> options:dns_LookupOptions -> (dns_LookupAddress, dns_LookupAddress) or_array Promise.t_1 [@@js.global "__promisify__"]
  end
  val lookupService: address:string -> port:float -> callback:(err:_NodeJS_ErrnoException or_null -> hostname:string -> service:string -> unit) -> unit [@@js.global "lookupService"]
  module[@js.scope "lookupService"] LookupService : sig
    val __promisify__: address:string -> port:float -> anonymous_interface_29 Promise.t_1 [@@js.global "__promisify__"]
  end
  module[@js.scope "ResolveOptions"] ResolveOptions : sig
    type t = dns_ResolveOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_ttl: t -> bool [@@js.get "ttl"]
    val set_ttl: t -> bool -> unit [@@js.set "ttl"]
  end
  module[@js.scope "ResolveWithTtlOptions"] ResolveWithTtlOptions : sig
    type t = dns_ResolveWithTtlOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_ttl: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "ttl"]
    val set_ttl: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "ttl"]
    val cast: t -> dns_ResolveOptions [@@js.cast]
  end
  module[@js.scope "RecordWithTtl"] RecordWithTtl : sig
    type t = dns_RecordWithTtl
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_ttl: t -> float [@@js.get "ttl"]
    val set_ttl: t -> float -> unit [@@js.set "ttl"]
  end
  (** @deprecated Use `AnyARecord` or `AnyAaaaRecord` instead. *)
  module AnyRecordWithTtl : sig
    type t = dns_AnyRecordWithTtl
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "AnyARecord"] AnyARecord : sig
    type t = dns_AnyARecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s1_A[@js "A"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s1_A] [@js.enum]) -> unit [@@js.set "type"]
    val cast: t -> dns_RecordWithTtl [@@js.cast]
  end
  module[@js.scope "AnyAaaaRecord"] AnyAaaaRecord : sig
    type t = dns_AnyAaaaRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s2_AAAA[@js "AAAA"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s2_AAAA] [@js.enum]) -> unit [@@js.set "type"]
    val cast: t -> dns_RecordWithTtl [@@js.cast]
  end
  module[@js.scope "MxRecord"] MxRecord : sig
    type t = dns_MxRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_priority: t -> float [@@js.get "priority"]
    val set_priority: t -> float -> unit [@@js.set "priority"]
    val get_exchange: t -> string [@@js.get "exchange"]
    val set_exchange: t -> string -> unit [@@js.set "exchange"]
  end
  module[@js.scope "AnyMxRecord"] AnyMxRecord : sig
    type t = dns_AnyMxRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s65_MX[@js "MX"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s65_MX] [@js.enum]) -> unit [@@js.set "type"]
    val cast: t -> dns_MxRecord [@@js.cast]
  end
  module[@js.scope "NaptrRecord"] NaptrRecord : sig
    type t = dns_NaptrRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_flags: t -> string [@@js.get "flags"]
    val set_flags: t -> string -> unit [@@js.set "flags"]
    val get_service: t -> string [@@js.get "service"]
    val set_service: t -> string -> unit [@@js.set "service"]
    val get_regexp: t -> string [@@js.get "regexp"]
    val set_regexp: t -> string -> unit [@@js.set "regexp"]
    val get_replacement: t -> string [@@js.get "replacement"]
    val set_replacement: t -> string -> unit [@@js.set "replacement"]
    val get_order: t -> float [@@js.get "order"]
    val set_order: t -> float -> unit [@@js.set "order"]
    val get_preference: t -> float [@@js.get "preference"]
    val set_preference: t -> float -> unit [@@js.set "preference"]
  end
  module[@js.scope "AnyNaptrRecord"] AnyNaptrRecord : sig
    type t = dns_AnyNaptrRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s66_NAPTR[@js "NAPTR"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s66_NAPTR] [@js.enum]) -> unit [@@js.set "type"]
    val cast: t -> dns_NaptrRecord [@@js.cast]
  end
  module[@js.scope "SoaRecord"] SoaRecord : sig
    type t = dns_SoaRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_nsname: t -> string [@@js.get "nsname"]
    val set_nsname: t -> string -> unit [@@js.set "nsname"]
    val get_hostmaster: t -> string [@@js.get "hostmaster"]
    val set_hostmaster: t -> string -> unit [@@js.set "hostmaster"]
    val get_serial: t -> float [@@js.get "serial"]
    val set_serial: t -> float -> unit [@@js.set "serial"]
    val get_refresh: t -> float [@@js.get "refresh"]
    val set_refresh: t -> float -> unit [@@js.set "refresh"]
    val get_retry: t -> float [@@js.get "retry"]
    val set_retry: t -> float -> unit [@@js.set "retry"]
    val get_expire: t -> float [@@js.get "expire"]
    val set_expire: t -> float -> unit [@@js.set "expire"]
    val get_minttl: t -> float [@@js.get "minttl"]
    val set_minttl: t -> float -> unit [@@js.set "minttl"]
  end
  module[@js.scope "AnySoaRecord"] AnySoaRecord : sig
    type t = dns_AnySoaRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s158_SOA[@js "SOA"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s158_SOA] [@js.enum]) -> unit [@@js.set "type"]
    val cast: t -> dns_SoaRecord [@@js.cast]
  end
  module[@js.scope "SrvRecord"] SrvRecord : sig
    type t = dns_SrvRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_priority: t -> float [@@js.get "priority"]
    val set_priority: t -> float -> unit [@@js.set "priority"]
    val get_weight: t -> float [@@js.get "weight"]
    val set_weight: t -> float -> unit [@@js.set "weight"]
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_name: t -> string [@@js.get "name"]
    val set_name: t -> string -> unit [@@js.set "name"]
  end
  module[@js.scope "AnySrvRecord"] AnySrvRecord : sig
    type t = dns_AnySrvRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s159_SRV[@js "SRV"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s159_SRV] [@js.enum]) -> unit [@@js.set "type"]
    val cast: t -> dns_SrvRecord [@@js.cast]
  end
  module[@js.scope "AnyTxtRecord"] AnyTxtRecord : sig
    type t = dns_AnyTxtRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s165_TXT[@js "TXT"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s165_TXT] [@js.enum]) -> unit [@@js.set "type"]
    val get_entries: t -> string list [@@js.get "entries"]
    val set_entries: t -> string list -> unit [@@js.set "entries"]
  end
  module[@js.scope "AnyNsRecord"] AnyNsRecord : sig
    type t = dns_AnyNsRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s67_NS[@js "NS"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s67_NS] [@js.enum]) -> unit [@@js.set "type"]
    val get_value: t -> string [@@js.get "value"]
    val set_value: t -> string -> unit [@@js.set "value"]
  end
  module[@js.scope "AnyPtrRecord"] AnyPtrRecord : sig
    type t = dns_AnyPtrRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s84_PTR[@js "PTR"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s84_PTR] [@js.enum]) -> unit [@@js.set "type"]
    val get_value: t -> string [@@js.get "value"]
    val set_value: t -> string -> unit [@@js.set "value"]
  end
  module[@js.scope "AnyCnameRecord"] AnyCnameRecord : sig
    type t = dns_AnyCnameRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_type: t -> ([`L_s6_CNAME[@js "CNAME"]] [@js.enum]) [@@js.get "type"]
    val set_type: t -> ([`L_s6_CNAME] [@js.enum]) -> unit [@@js.set "type"]
    val get_value: t -> string [@@js.get "value"]
    val set_value: t -> string -> unit [@@js.set "value"]
  end
  module AnyRecord : sig
    type t = dns_AnyRecord
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  val resolve: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s1_A] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s2_AAAA] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s3_ANY] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_AnyRecord list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s6_CNAME] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s65_MX] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_MxRecord list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s66_NAPTR] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_NaptrRecord list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s67_NS] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s84_PTR] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s158_SOA] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_SoaRecord -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s159_SRV] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_SrvRecord list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:([`L_s165_TXT] [@js.enum]) -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list list -> unit) -> unit [@@js.global "resolve"]
  val resolve: hostname:string -> rrtype:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:(dns_SoaRecord, ((dns_AnyRecord, dns_MxRecord, dns_NaptrRecord, dns_SrvRecord) union4, string) or_array or_string) or_array -> unit) -> unit [@@js.global "resolve"]
  module[@js.scope "resolve"] Resolve : sig
    val __promisify__: hostname:string -> ?rrtype:([`L_s1_A | `L_s2_AAAA | `L_s6_CNAME | `L_s67_NS | `L_s84_PTR] [@js.enum]) -> unit -> string list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:([`L_s3_ANY] [@js.enum]) -> dns_AnyRecord list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:([`L_s65_MX] [@js.enum]) -> dns_MxRecord list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:([`L_s66_NAPTR] [@js.enum]) -> dns_NaptrRecord list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:([`L_s158_SOA] [@js.enum]) -> dns_SoaRecord Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:([`L_s159_SRV] [@js.enum]) -> dns_SrvRecord list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:([`L_s165_TXT] [@js.enum]) -> string list list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> rrtype:string -> (dns_SoaRecord, ((dns_AnyRecord, dns_MxRecord, dns_NaptrRecord, dns_SrvRecord) union4, string) or_array or_string) or_array Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolve4: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve4"]
  val resolve4: hostname:string -> options:dns_ResolveWithTtlOptions -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_RecordWithTtl list -> unit) -> unit [@@js.global "resolve4"]
  val resolve4: hostname:string -> options:dns_ResolveOptions -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_RecordWithTtl or_string list -> unit) -> unit [@@js.global "resolve4"]
  module[@js.scope "resolve4"] Resolve4 : sig
    val __promisify__: hostname:string -> string list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> options:dns_ResolveWithTtlOptions -> dns_RecordWithTtl list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> ?options:dns_ResolveOptions -> unit -> dns_RecordWithTtl or_string list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolve6: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolve6"]
  val resolve6: hostname:string -> options:dns_ResolveWithTtlOptions -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_RecordWithTtl list -> unit) -> unit [@@js.global "resolve6"]
  val resolve6: hostname:string -> options:dns_ResolveOptions -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_RecordWithTtl or_string list -> unit) -> unit [@@js.global "resolve6"]
  module[@js.scope "resolve6"] Resolve6 : sig
    val __promisify__: hostname:string -> string list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> options:dns_ResolveWithTtlOptions -> dns_RecordWithTtl list Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: hostname:string -> ?options:dns_ResolveOptions -> unit -> dns_RecordWithTtl or_string list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveCname: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolveCname"]
  module[@js.scope "resolveCname"] ResolveCname : sig
    val __promisify__: hostname:string -> string list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveMx: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_MxRecord list -> unit) -> unit [@@js.global "resolveMx"]
  module[@js.scope "resolveMx"] ResolveMx : sig
    val __promisify__: hostname:string -> dns_MxRecord list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveNaptr: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_NaptrRecord list -> unit) -> unit [@@js.global "resolveNaptr"]
  module[@js.scope "resolveNaptr"] ResolveNaptr : sig
    val __promisify__: hostname:string -> dns_NaptrRecord list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveNs: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolveNs"]
  module[@js.scope "resolveNs"] ResolveNs : sig
    val __promisify__: hostname:string -> string list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolvePtr: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.global "resolvePtr"]
  module[@js.scope "resolvePtr"] ResolvePtr : sig
    val __promisify__: hostname:string -> string list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveSoa: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> address:dns_SoaRecord -> unit) -> unit [@@js.global "resolveSoa"]
  module[@js.scope "resolveSoa"] ResolveSoa : sig
    val __promisify__: hostname:string -> dns_SoaRecord Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveSrv: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_SrvRecord list -> unit) -> unit [@@js.global "resolveSrv"]
  module[@js.scope "resolveSrv"] ResolveSrv : sig
    val __promisify__: hostname:string -> dns_SrvRecord list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveTxt: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list list -> unit) -> unit [@@js.global "resolveTxt"]
  module[@js.scope "resolveTxt"] ResolveTxt : sig
    val __promisify__: hostname:string -> string list list Promise.t_1 [@@js.global "__promisify__"]
  end
  val resolveAny: hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_AnyRecord list -> unit) -> unit [@@js.global "resolveAny"]
  module[@js.scope "resolveAny"] ResolveAny : sig
    val __promisify__: hostname:string -> dns_AnyRecord list Promise.t_1 [@@js.global "__promisify__"]
  end
  val reverse: ip:string -> callback:(err:_NodeJS_ErrnoException or_null -> hostnames:string list -> unit) -> unit [@@js.global "reverse"]
  val setServers: servers:string list -> unit [@@js.global "setServers"]
  val getServers: unit -> string list [@@js.global "getServers"]
  val nodata: string [@@js.global "NODATA"]
  val formerr: string [@@js.global "FORMERR"]
  val servfail: string [@@js.global "SERVFAIL"]
  val notfound: string [@@js.global "NOTFOUND"]
  val notimp: string [@@js.global "NOTIMP"]
  val refused: string [@@js.global "REFUSED"]
  val badquery: string [@@js.global "BADQUERY"]
  val badname: string [@@js.global "BADNAME"]
  val badfamily: string [@@js.global "BADFAMILY"]
  val badresp: string [@@js.global "BADRESP"]
  val connrefused: string [@@js.global "CONNREFUSED"]
  val timeout: string [@@js.global "TIMEOUT"]
  val eof: string [@@js.global "EOF"]
  val file: string [@@js.global "FILE"]
  val nomem: string [@@js.global "NOMEM"]
  val destruction: string [@@js.global "DESTRUCTION"]
  val badstr: string [@@js.global "BADSTR"]
  val badflags: string [@@js.global "BADFLAGS"]
  val noname: string [@@js.global "NONAME"]
  val badhints: string [@@js.global "BADHINTS"]
  val notinitialized: string [@@js.global "NOTINITIALIZED"]
  val loadiphlpapi: string [@@js.global "LOADIPHLPAPI"]
  val addrgetnetworkparams: string [@@js.global "ADDRGETNETWORKPARAMS"]
  val cancelled: string [@@js.global "CANCELLED"]
  module[@js.scope "ResolverOptions"] ResolverOptions : sig
    type t = dns_ResolverOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
  end
  module[@js.scope "Resolver"] Resolver : sig
    type t = dns_Resolver
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?options:dns_ResolverOptions -> unit -> t [@@js.create]
    val cancel: t -> unit [@@js.call "cancel"]
    val getServers: t -> string list [@@js.call "getServers"]
    val resolve: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.call "resolve"]
    val resolve4: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.call "resolve4"]
    val resolve6: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.call "resolve6"]
    val resolveAny: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_AnyRecord list -> unit) -> unit [@@js.call "resolveAny"]
    val resolveCname: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.call "resolveCname"]
    val resolveMx: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_MxRecord list -> unit) -> unit [@@js.call "resolveMx"]
    val resolveNaptr: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_NaptrRecord list -> unit) -> unit [@@js.call "resolveNaptr"]
    val resolveNs: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.call "resolveNs"]
    val resolvePtr: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list -> unit) -> unit [@@js.call "resolvePtr"]
    val resolveSoa: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> address:dns_SoaRecord -> unit) -> unit [@@js.call "resolveSoa"]
    val resolveSrv: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:dns_SrvRecord list -> unit) -> unit [@@js.call "resolveSrv"]
    val resolveTxt: t -> hostname:string -> callback:(err:_NodeJS_ErrnoException or_null -> addresses:string list list -> unit) -> unit [@@js.call "resolveTxt"]
    val reverse: t -> ip:string -> callback:(err:_NodeJS_ErrnoException or_null -> hostnames:string list -> unit) -> unit [@@js.call "reverse"]
    val setLocalAddress: t -> ?ipv4:string -> ?ipv6:string -> unit -> unit [@@js.call "setLocalAddress"]
    val setServers: t -> servers:string list -> unit [@@js.call "setServers"]
  end
  module[@js.scope "promises"] Promises : sig
    val getServers: unit -> string list [@@js.global "getServers"]
    val lookup: hostname:string -> family:float -> dns_LookupAddress Promise.t_1 [@@js.global "lookup"]
    val lookup: hostname:string -> options:dns_LookupOneOptions -> dns_LookupAddress Promise.t_1 [@@js.global "lookup"]
    val lookup: hostname:string -> options:dns_LookupAllOptions -> dns_LookupAddress list Promise.t_1 [@@js.global "lookup"]
    val lookup: hostname:string -> options:dns_LookupOptions -> (dns_LookupAddress, dns_LookupAddress) or_array Promise.t_1 [@@js.global "lookup"]
    val lookup: hostname:string -> dns_LookupAddress Promise.t_1 [@@js.global "lookup"]
    val lookupService: address:string -> port:float -> anonymous_interface_29 Promise.t_1 [@@js.global "lookupService"]
    val resolve: hostname:string -> string list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s1_A] [@js.enum]) -> string list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s2_AAAA] [@js.enum]) -> string list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s3_ANY] [@js.enum]) -> dns_AnyRecord list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s6_CNAME] [@js.enum]) -> string list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s65_MX] [@js.enum]) -> dns_MxRecord list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s66_NAPTR] [@js.enum]) -> dns_NaptrRecord list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s67_NS] [@js.enum]) -> string list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s84_PTR] [@js.enum]) -> string list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s158_SOA] [@js.enum]) -> dns_SoaRecord Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s159_SRV] [@js.enum]) -> dns_SrvRecord list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:([`L_s165_TXT] [@js.enum]) -> string list list Promise.t_1 [@@js.global "resolve"]
    val resolve: hostname:string -> rrtype:string -> (dns_SoaRecord, ((dns_AnyRecord, dns_MxRecord, dns_NaptrRecord, dns_SrvRecord) union4, string) or_array or_string) or_array Promise.t_1 [@@js.global "resolve"]
    val resolve4: hostname:string -> string list Promise.t_1 [@@js.global "resolve4"]
    val resolve4: hostname:string -> options:dns_ResolveWithTtlOptions -> dns_RecordWithTtl list Promise.t_1 [@@js.global "resolve4"]
    val resolve4: hostname:string -> options:dns_ResolveOptions -> dns_RecordWithTtl or_string list Promise.t_1 [@@js.global "resolve4"]
    val resolve6: hostname:string -> string list Promise.t_1 [@@js.global "resolve6"]
    val resolve6: hostname:string -> options:dns_ResolveWithTtlOptions -> dns_RecordWithTtl list Promise.t_1 [@@js.global "resolve6"]
    val resolve6: hostname:string -> options:dns_ResolveOptions -> dns_RecordWithTtl or_string list Promise.t_1 [@@js.global "resolve6"]
    val resolveAny: hostname:string -> dns_AnyRecord list Promise.t_1 [@@js.global "resolveAny"]
    val resolveCname: hostname:string -> string list Promise.t_1 [@@js.global "resolveCname"]
    val resolveMx: hostname:string -> dns_MxRecord list Promise.t_1 [@@js.global "resolveMx"]
    val resolveNaptr: hostname:string -> dns_NaptrRecord list Promise.t_1 [@@js.global "resolveNaptr"]
    val resolveNs: hostname:string -> string list Promise.t_1 [@@js.global "resolveNs"]
    val resolvePtr: hostname:string -> string list Promise.t_1 [@@js.global "resolvePtr"]
    val resolveSoa: hostname:string -> dns_SoaRecord Promise.t_1 [@@js.global "resolveSoa"]
    val resolveSrv: hostname:string -> dns_SrvRecord list Promise.t_1 [@@js.global "resolveSrv"]
    val resolveTxt: hostname:string -> string list list Promise.t_1 [@@js.global "resolveTxt"]
    val reverse: ip:string -> string list Promise.t_1 [@@js.global "reverse"]
    val setServers: servers:string list -> unit [@@js.global "setServers"]
    module[@js.scope "Resolver"] Resolver : sig
      type t = dns_promises_Resolver
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val create: ?options:dns_ResolverOptions -> unit -> t [@@js.create]
      val cancel: t -> unit [@@js.call "cancel"]
      val getServers: t -> string list [@@js.call "getServers"]
      val resolve: t -> hostname:string -> string list Promise.t_1 [@@js.call "resolve"]
      val resolve4: t -> hostname:string -> string list Promise.t_1 [@@js.call "resolve4"]
      val resolve6: t -> hostname:string -> string list Promise.t_1 [@@js.call "resolve6"]
      val resolveAny: t -> hostname:string -> dns_AnyRecord list Promise.t_1 [@@js.call "resolveAny"]
      val resolveCname: t -> hostname:string -> string list Promise.t_1 [@@js.call "resolveCname"]
      val resolveMx: t -> hostname:string -> dns_MxRecord list Promise.t_1 [@@js.call "resolveMx"]
      val resolveNaptr: t -> hostname:string -> dns_NaptrRecord list Promise.t_1 [@@js.call "resolveNaptr"]
      val resolveNs: t -> hostname:string -> string list Promise.t_1 [@@js.call "resolveNs"]
      val resolvePtr: t -> hostname:string -> string list Promise.t_1 [@@js.call "resolvePtr"]
      val resolveSoa: t -> hostname:string -> dns_SoaRecord Promise.t_1 [@@js.call "resolveSoa"]
      val resolveSrv: t -> hostname:string -> dns_SrvRecord list Promise.t_1 [@@js.call "resolveSrv"]
      val resolveTxt: t -> hostname:string -> string list list Promise.t_1 [@@js.call "resolveTxt"]
      val reverse: t -> ip:string -> string list Promise.t_1 [@@js.call "reverse"]
      val setLocalAddress: t -> ?ipv4:string -> ?ipv6:string -> unit -> unit [@@js.call "setLocalAddress"]
      val setServers: t -> servers:string list -> unit [@@js.call "setServers"]
    end
  end
end
module Node_domain : sig
  (* export * from 'domain'; *)
end
module[@js.scope "domain"] Domain : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/domain.d.ts } *)
  module[@js.scope "global"] Global : sig
    module[@js.scope "NodeJS"] NodeJS : sig
      module[@js.scope "Domain"] Domain : sig
        type t = domain_global_NodeJS_Domain
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val run: t -> fn:(args:(any list [@js.variadic]) -> 'T) -> args:(any list [@js.variadic]) -> 'T [@@js.call "run"]
        val add: t -> emitter:(EventEmitter.t_0, Timer.t_0) union2 -> unit [@@js.call "add"]
        val remove: t -> emitter:(EventEmitter.t_0, Timer.t_0) union2 -> unit [@@js.call "remove"]
        val bind: t -> cb:'T -> 'T [@@js.call "bind"]
        val intercept: t -> cb:'T -> 'T [@@js.call "intercept"]
        val cast: t -> EventEmitter.t_0 [@@js.cast]
      end
    end
  end
  module[@js.scope "Domain"] Domain : sig
    type t = domain_Domain
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_members: t -> (EventEmitter.t_0, _NodeJS_Timer) union2 list [@@js.get "members"]
    val set_members: t -> (EventEmitter.t_0, _NodeJS_Timer) union2 list -> unit [@@js.set "members"]
    val enter: t -> unit [@@js.call "enter"]
    val exit: t -> unit [@@js.call "exit"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
    val cast': t -> NodeJS.Domain.t_0 [@@js.cast]
  end
  val create_: unit -> domain_Domain [@@js.global "create"]
end
module Node_events : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = events
    clause = NamespaceImport ([object Object])
    loc = line 2, col 5 of node_modules/@types/node/events.d.ts } *)
  (* CommonJsExport ({ name = [EventEmitter]
    fullName = undefined
    loc = line 3, col 14 of node_modules/@types/node/events.d.ts }) *)
end
module[@js.scope "events"] Events : sig
  module[@js.scope "EventEmitterOptions"] EventEmitterOptions : sig
    type t = events_EventEmitterOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Enables automatic capturing of promise rejection. *)
    (** Enables automatic capturing of promise rejection. *)
    val get_captureRejections: t -> bool [@@js.get "captureRejections"]
    (** Enables automatic capturing of promise rejection. *)
    val set_captureRejections: t -> bool -> unit [@@js.set "captureRejections"]
  end
  module[@js.scope "NodeEventTarget"] NodeEventTarget : sig
    type t = events_NodeEventTarget
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val once: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
  end
  module[@js.scope "DOMEventTarget"] DOMEventTarget : sig
    type t = events_DOMEventTarget
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val addEventListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> ?opts:anonymous_interface_34 -> unit -> any [@@js.call "addEventListener"]
  end
  module[@js.scope "EventEmitter"] EventEmitter : sig
    type t = events_EventEmitter
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?options:events_EventEmitterOptions -> unit -> t [@@js.create]
    val once: emitter:events_NodeEventTarget -> event:symbol or_string -> any list Promise.t_1 [@@js.global "once"]
    val once': emitter:events_DOMEventTarget -> event:string -> any list Promise.t_1 [@@js.global "once"]
    val on: emitter:NodeJS.EventEmitter.t_0 -> event:string -> any AsyncIterableIterator.t_1 [@@js.global "on"]
    (** @deprecated since v4.0.0 *)
    val listenerCount: emitter:NodeJS.EventEmitter.t_0 -> event:symbol or_string -> float [@@js.global "listenerCount"]
    (**
      This symbol shall be used to install a listener for only monitoring `'error'`
      events. Listeners installed using this symbol are called before the regular
      `'error'` listeners are called.
      
      Installing a listener using this symbol does not change the behavior once an
      `'error'` event is emitted, therefore the process will still crash if no
      regular `'error'` listener is installed.
    *)
    val get_errorMonitor: unit -> (* FIXME: unknown type 'unique symbol' *)any [@@js.get "errorMonitor"]
    val get_captureRejectionSymbol: unit -> (* FIXME: unknown type 'unique symbol' *)any [@@js.get "captureRejectionSymbol"]
    (** Sets or gets the default captureRejection value for all emitters. *)
    (** Sets or gets the default captureRejection value for all emitters. *)
    val get_captureRejections: unit -> bool [@@js.get "captureRejections"]
    (** Sets or gets the default captureRejection value for all emitters. *)
    val set_captureRejections: bool -> unit [@@js.set "captureRejections"]
    val get_defaultMaxListeners: unit -> float [@@js.get "defaultMaxListeners"]
    val set_defaultMaxListeners: float -> unit [@@js.set "defaultMaxListeners"]
    val cast: t -> NodeJS.EventEmitter.t_0 [@@js.cast]
  end
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = events
    clause = NamespaceImport ([object Object])
    loc = line 53, col 5 of node_modules/@types/node/events.d.ts } *)
  module EventEmitter : sig
    (**
      // Should just be `export \{ EventEmitter \}`, but that doesn't work in TypeScript 3.4
      
    *)
    (* ES6Export ([[object Object]]) *)
  end
  module[@js.scope "global"] Global : sig
    module[@js.scope "NodeJS"] NodeJS : sig
      module[@js.scope "EventEmitter"] EventEmitter : sig
        type t = events_global_NodeJS_EventEmitter
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val addListener: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
        val on: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
        val once: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
        val removeListener: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "removeListener"]
        val off: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "off"]
        val removeAllListeners: t -> ?event:symbol or_string -> unit -> t [@@js.call "removeAllListeners"]
        val setMaxListeners: t -> n:float -> t [@@js.call "setMaxListeners"]
        val getMaxListeners: t -> float [@@js.call "getMaxListeners"]
        val listeners: t -> event:symbol or_string -> untyped_function list [@@js.call "listeners"]
        val rawListeners: t -> event:symbol or_string -> untyped_function list [@@js.call "rawListeners"]
        val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
        val listenerCount: t -> event:symbol or_string -> float [@@js.call "listenerCount"]
        val prependListener: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
        val prependOnceListener: t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
        val eventNames: t -> symbol or_string list [@@js.call "eventNames"]
      end
    end
  end
  (* CommonJsExport ({ name = [EventEmitter]
    fullName = [events; EventEmitter]
    loc = line 82, col 14 of node_modules/@types/node/events.d.ts }) *)
end
module Node_fs : sig
  (* export * from 'fs'; *)
end
module[@js.scope "fs"] Fs : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/fs.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/fs.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:url
    clause = ES6Import ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/fs.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:fs/promises
    clause = NamespaceImport ([object Object])
    loc = line 9, col 5 of node_modules/@types/node/fs.d.ts } *)
  (* ES6Export ([[object Object]]) *)
  (** Valid types for path values in "fs". *)
  module PathLike : sig
    type t = fs_PathLike
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "NoParamCallback"] NoParamCallback : sig
    type t = fs_NoParamCallback
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> err:_NodeJS_ErrnoException or_null -> unit [@@js.apply]
  end
  module BufferEncodingOption : sig
    type t = fs_BufferEncodingOption
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "BaseEncodingOptions"] BaseEncodingOptions : sig
    type t = fs_BaseEncodingOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding or_null [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding or_null -> unit [@@js.set "encoding"]
  end
  module OpenMode : sig
    type t = fs_OpenMode
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module Mode : sig
    type t = fs_Mode
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "StatsBase"] StatsBase : sig
    type 'T t = 'T fs_StatsBase
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val isFile: 'T t -> bool [@@js.call "isFile"]
    val isDirectory: 'T t -> bool [@@js.call "isDirectory"]
    val isBlockDevice: 'T t -> bool [@@js.call "isBlockDevice"]
    val isCharacterDevice: 'T t -> bool [@@js.call "isCharacterDevice"]
    val isSymbolicLink: 'T t -> bool [@@js.call "isSymbolicLink"]
    val isFIFO: 'T t -> bool [@@js.call "isFIFO"]
    val isSocket: 'T t -> bool [@@js.call "isSocket"]
    val get_dev: 'T t -> 'T [@@js.get "dev"]
    val set_dev: 'T t -> 'T -> unit [@@js.set "dev"]
    val get_ino: 'T t -> 'T [@@js.get "ino"]
    val set_ino: 'T t -> 'T -> unit [@@js.set "ino"]
    val get_mode: 'T t -> 'T [@@js.get "mode"]
    val set_mode: 'T t -> 'T -> unit [@@js.set "mode"]
    val get_nlink: 'T t -> 'T [@@js.get "nlink"]
    val set_nlink: 'T t -> 'T -> unit [@@js.set "nlink"]
    val get_uid: 'T t -> 'T [@@js.get "uid"]
    val set_uid: 'T t -> 'T -> unit [@@js.set "uid"]
    val get_gid: 'T t -> 'T [@@js.get "gid"]
    val set_gid: 'T t -> 'T -> unit [@@js.set "gid"]
    val get_rdev: 'T t -> 'T [@@js.get "rdev"]
    val set_rdev: 'T t -> 'T -> unit [@@js.set "rdev"]
    val get_size: 'T t -> 'T [@@js.get "size"]
    val set_size: 'T t -> 'T -> unit [@@js.set "size"]
    val get_blksize: 'T t -> 'T [@@js.get "blksize"]
    val set_blksize: 'T t -> 'T -> unit [@@js.set "blksize"]
    val get_blocks: 'T t -> 'T [@@js.get "blocks"]
    val set_blocks: 'T t -> 'T -> unit [@@js.set "blocks"]
    val get_atimeMs: 'T t -> 'T [@@js.get "atimeMs"]
    val set_atimeMs: 'T t -> 'T -> unit [@@js.set "atimeMs"]
    val get_mtimeMs: 'T t -> 'T [@@js.get "mtimeMs"]
    val set_mtimeMs: 'T t -> 'T -> unit [@@js.set "mtimeMs"]
    val get_ctimeMs: 'T t -> 'T [@@js.get "ctimeMs"]
    val set_ctimeMs: 'T t -> 'T -> unit [@@js.set "ctimeMs"]
    val get_birthtimeMs: 'T t -> 'T [@@js.get "birthtimeMs"]
    val set_birthtimeMs: 'T t -> 'T -> unit [@@js.set "birthtimeMs"]
    val get_atime: 'T t -> Date.t_0 [@@js.get "atime"]
    val set_atime: 'T t -> Date.t_0 -> unit [@@js.set "atime"]
    val get_mtime: 'T t -> Date.t_0 [@@js.get "mtime"]
    val set_mtime: 'T t -> Date.t_0 -> unit [@@js.set "mtime"]
    val get_ctime: 'T t -> Date.t_0 [@@js.get "ctime"]
    val set_ctime: 'T t -> Date.t_0 -> unit [@@js.set "ctime"]
    val get_birthtime: 'T t -> Date.t_0 [@@js.get "birthtime"]
    val set_birthtime: 'T t -> Date.t_0 -> unit [@@js.set "birthtime"]
  end
  module[@js.scope "Stats"] Stats : sig
    type t = fs_Stats
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> float fs_StatsBase [@@js.cast]
  end
  module[@js.scope "Dirent"] Dirent : sig
    type t = fs_Dirent
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val isFile: t -> bool [@@js.call "isFile"]
    val isDirectory: t -> bool [@@js.call "isDirectory"]
    val isBlockDevice: t -> bool [@@js.call "isBlockDevice"]
    val isCharacterDevice: t -> bool [@@js.call "isCharacterDevice"]
    val isSymbolicLink: t -> bool [@@js.call "isSymbolicLink"]
    val isFIFO: t -> bool [@@js.call "isFIFO"]
    val isSocket: t -> bool [@@js.call "isSocket"]
    val get_name: t -> string [@@js.get "name"]
    val set_name: t -> string -> unit [@@js.set "name"]
  end
  (** A class representing a directory stream. *)
  module[@js.scope "Dir"] Dir : sig
    type t = fs_Dir
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_path: t -> string [@@js.get "path"]
    (** Asynchronously iterates over the directory via `readdir(3)` until all entries have been read. *)
    val _Symbol_asyncIterator_: t -> fs_Dirent AsyncIterableIterator.t_1 [@@js.call "[Symbol.asyncIterator]"]
    (**
      Asynchronously close the directory's underlying resource handle.
      Subsequent reads will result in errors.
    *)
    val close: t -> unit Promise.t_1 [@@js.call "close"]
    (**
      Asynchronously close the directory's underlying resource handle.
      Subsequent reads will result in errors.
    *)
    val close': t -> cb:fs_NoParamCallback -> unit [@@js.call "close"]
    (**
      Synchronously close the directory's underlying resource handle.
      Subsequent reads will result in errors.
    *)
    val closeSync: t -> unit [@@js.call "closeSync"]
    (**
      Asynchronously read the next directory entry via `readdir(3)` as an `Dirent`.
      After the read is completed, a value is returned that will be resolved with an `Dirent`, or `null` if there are no more directory entries to read.
      Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
    *)
    val read: t -> fs_Dirent or_null Promise.t_1 [@@js.call "read"]
    (**
      Asynchronously read the next directory entry via `readdir(3)` as an `Dirent`.
      After the read is completed, a value is returned that will be resolved with an `Dirent`, or `null` if there are no more directory entries to read.
      Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
    *)
    val read': t -> cb:(err:_NodeJS_ErrnoException or_null -> dirEnt:fs_Dirent or_null -> unit) -> unit [@@js.call "read"]
    (**
      Synchronously read the next directory entry via `readdir(3)` as a `Dirent`.
      If there are no more directory entries to read, null will be returned.
      Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
    *)
    val readSync: t -> fs_Dirent or_null [@@js.call "readSync"]
  end
  module[@js.scope "FSWatcher"] FSWatcher : sig
    type t = fs_FSWatcher
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val close: t -> unit [@@js.call "close"]
    (**
      events.EventEmitter
        1. change
        2. error
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. change
        2. error
    *)
    val addListener': t -> event:([`L_s189_change] [@js.enum]) -> listener:(eventType:string -> filename:_Buffer or_string -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. change
        2. error
    *)
    val addListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. change
        2. error
    *)
    val addListener''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s189_change] [@js.enum]) -> listener:(eventType:string -> filename:_Buffer or_string -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s189_change] [@js.enum]) -> listener:(eventType:string -> filename:_Buffer or_string -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s189_change] [@js.enum]) -> listener:(eventType:string -> filename:_Buffer or_string -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s189_change] [@js.enum]) -> listener:(eventType:string -> filename:_Buffer or_string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "ReadStream"] ReadStream : sig
    type t = fs_ReadStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val close: t -> unit [@@js.call "close"]
    val get_bytesRead: t -> float [@@js.get "bytesRead"]
    val set_bytesRead: t -> float -> unit [@@js.set "bytesRead"]
    val get_path: t -> _Buffer or_string [@@js.get "path"]
    val set_path: t -> _Buffer or_string -> unit [@@js.set "path"]
    val get_pending: t -> bool [@@js.get "pending"]
    val set_pending: t -> bool -> unit [@@js.set "pending"]
    (**
      events.EventEmitter
        1. open
        2. close
        3. ready
    *)
    val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Stream.Readable.t_0 [@@js.cast]
  end
  module[@js.scope "WriteStream"] WriteStream : sig
    type t = fs_WriteStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val close: t -> unit [@@js.call "close"]
    val get_bytesWritten: t -> float [@@js.get "bytesWritten"]
    val set_bytesWritten: t -> float -> unit [@@js.set "bytesWritten"]
    val get_path: t -> _Buffer or_string [@@js.get "path"]
    val set_path: t -> _Buffer or_string -> unit [@@js.set "path"]
    val get_pending: t -> bool [@@js.get "pending"]
    val set_pending: t -> bool -> unit [@@js.set "pending"]
    (**
      events.EventEmitter
        1. open
        2. close
        3. ready
    *)
    val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s265_open] [@js.enum]) -> listener:(fd:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s278_ready] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Stream.Writable.t_0 [@@js.cast]
  end
  (**
    Asynchronous rename(2) - Change the name or location of a file or directory.
    @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val rename: oldPath:fs_PathLike -> newPath:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "rename"]
  module[@js.scope "rename"] Rename : sig
    (**
      Asynchronous rename(2) - Change the name or location of a file or directory.
      @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
      @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
    *)
    val __promisify__: oldPath:fs_PathLike -> newPath:fs_PathLike -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous rename(2) - Change the name or location of a file or directory.
    @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val renameSync: oldPath:fs_PathLike -> newPath:fs_PathLike -> unit [@@js.global "renameSync"]
  (**
    Asynchronous truncate(2) - Truncate a file to a specified length.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param len If not specified, defaults to `0`.
  *)
  val truncate: path:fs_PathLike -> len:float or_null_or_undefined -> callback:fs_NoParamCallback -> unit [@@js.global "truncate"]
  (**
    Asynchronous truncate(2) - Truncate a file to a specified length.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val truncate: path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "truncate"]
  module[@js.scope "truncate"] Truncate : sig
    (**
      Asynchronous truncate(2) - Truncate a file to a specified length.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param len If not specified, defaults to `0`.
    *)
    val __promisify__: path:fs_PathLike -> ?len:float or_null -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous truncate(2) - Truncate a file to a specified length.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param len If not specified, defaults to `0`.
  *)
  val truncateSync: path:fs_PathLike -> ?len:float or_null -> unit -> unit [@@js.global "truncateSync"]
  (**
    Asynchronous ftruncate(2) - Truncate a file to a specified length.
    @param fd A file descriptor.
    @param len If not specified, defaults to `0`.
  *)
  val ftruncate: fd:float -> len:float or_null_or_undefined -> callback:fs_NoParamCallback -> unit [@@js.global "ftruncate"]
  (**
    Asynchronous ftruncate(2) - Truncate a file to a specified length.
    @param fd A file descriptor.
  *)
  val ftruncate: fd:float -> callback:fs_NoParamCallback -> unit [@@js.global "ftruncate"]
  module[@js.scope "ftruncate"] Ftruncate : sig
    (**
      Asynchronous ftruncate(2) - Truncate a file to a specified length.
      @param fd A file descriptor.
      @param len If not specified, defaults to `0`.
    *)
    val __promisify__: fd:float -> ?len:float or_null -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous ftruncate(2) - Truncate a file to a specified length.
    @param fd A file descriptor.
    @param len If not specified, defaults to `0`.
  *)
  val ftruncateSync: fd:float -> ?len:float or_null -> unit -> unit [@@js.global "ftruncateSync"]
  (**
    Asynchronous chown(2) - Change ownership of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val chown: path:fs_PathLike -> uid:float -> gid:float -> callback:fs_NoParamCallback -> unit [@@js.global "chown"]
  module[@js.scope "chown"] Chown : sig
    (**
      Asynchronous chown(2) - Change ownership of a file.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: path:fs_PathLike -> uid:float -> gid:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous chown(2) - Change ownership of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val chownSync: path:fs_PathLike -> uid:float -> gid:float -> unit [@@js.global "chownSync"]
  (**
    Asynchronous fchown(2) - Change ownership of a file.
    @param fd A file descriptor.
  *)
  val fchown: fd:float -> uid:float -> gid:float -> callback:fs_NoParamCallback -> unit [@@js.global "fchown"]
  module[@js.scope "fchown"] Fchown : sig
    (**
      Asynchronous fchown(2) - Change ownership of a file.
      @param fd A file descriptor.
    *)
    val __promisify__: fd:float -> uid:float -> gid:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous fchown(2) - Change ownership of a file.
    @param fd A file descriptor.
  *)
  val fchownSync: fd:float -> uid:float -> gid:float -> unit [@@js.global "fchownSync"]
  (**
    Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val lchown: path:fs_PathLike -> uid:float -> gid:float -> callback:fs_NoParamCallback -> unit [@@js.global "lchown"]
  module[@js.scope "lchown"] Lchown : sig
    (**
      Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: path:fs_PathLike -> uid:float -> gid:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val lchownSync: path:fs_PathLike -> uid:float -> gid:float -> unit [@@js.global "lchownSync"]
  (**
    Changes the access and modification times of a file in the same way as `fs.utimes()`,
    with the difference that if the path refers to a symbolic link, then the link is not
    dereferenced: instead, the timestamps of the symbolic link itself are changed.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param atime The last access time. If a string is provided, it will be coerced to number.
    @param mtime The last modified time. If a string is provided, it will be coerced to number.
  *)
  val lutimes: path:fs_PathLike -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> callback:fs_NoParamCallback -> unit [@@js.global "lutimes"]
  module[@js.scope "lutimes"] Lutimes : sig
    (**
      Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
      with the difference that if the path refers to a symbolic link, then the link is not
      dereferenced: instead, the timestamps of the symbolic link itself are changed.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param atime The last access time. If a string is provided, it will be coerced to number.
      @param mtime The last modified time. If a string is provided, it will be coerced to number.
    *)
    val __promisify__: path:fs_PathLike -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Change the file system timestamps of the symbolic link referenced by `path`. Returns `undefined`,
    or throws an exception when parameters are incorrect or the operation fails.
    This is the synchronous version of `fs.lutimes()`.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param atime The last access time. If a string is provided, it will be coerced to number.
    @param mtime The last modified time. If a string is provided, it will be coerced to number.
  *)
  val lutimesSync: path:fs_PathLike -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> unit [@@js.global "lutimesSync"]
  (**
    Asynchronous chmod(2) - Change permissions of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer.
  *)
  val chmod: path:fs_PathLike -> mode:fs_Mode -> callback:fs_NoParamCallback -> unit [@@js.global "chmod"]
  module[@js.scope "chmod"] Chmod : sig
    (**
      Asynchronous chmod(2) - Change permissions of a file.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param mode A file mode. If a string is passed, it is parsed as an octal integer.
    *)
    val __promisify__: path:fs_PathLike -> mode:fs_Mode -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous chmod(2) - Change permissions of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer.
  *)
  val chmodSync: path:fs_PathLike -> mode:fs_Mode -> unit [@@js.global "chmodSync"]
  (**
    Asynchronous fchmod(2) - Change permissions of a file.
    @param fd A file descriptor.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer.
  *)
  val fchmod: fd:float -> mode:fs_Mode -> callback:fs_NoParamCallback -> unit [@@js.global "fchmod"]
  module[@js.scope "fchmod"] Fchmod : sig
    (**
      Asynchronous fchmod(2) - Change permissions of a file.
      @param fd A file descriptor.
      @param mode A file mode. If a string is passed, it is parsed as an octal integer.
    *)
    val __promisify__: fd:float -> mode:fs_Mode -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous fchmod(2) - Change permissions of a file.
    @param fd A file descriptor.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer.
  *)
  val fchmodSync: fd:float -> mode:fs_Mode -> unit [@@js.global "fchmodSync"]
  (**
    Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer.
  *)
  val lchmod: path:fs_PathLike -> mode:fs_Mode -> callback:fs_NoParamCallback -> unit [@@js.global "lchmod"]
  module[@js.scope "lchmod"] Lchmod : sig
    (**
      Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param mode A file mode. If a string is passed, it is parsed as an octal integer.
    *)
    val __promisify__: path:fs_PathLike -> mode:fs_Mode -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer.
  *)
  val lchmodSync: path:fs_PathLike -> mode:fs_Mode -> unit [@@js.global "lchmodSync"]
  (**
    Asynchronous stat(2) - Get file status.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val stat: path:fs_PathLike -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_Stats -> unit) -> unit [@@js.global "stat"]
  (** Asynchronous stat(2) - Get file status. *)
  val stat: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_3) intersection2 or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_Stats -> unit) -> unit [@@js.global "stat"]
  (** Asynchronous stat(2) - Get file status. *)
  val stat: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_BigIntStats -> unit) -> unit [@@js.global "stat"]
  (** Asynchronous stat(2) - Get file status. *)
  val stat: path:fs_PathLike -> options:fs_StatOptions or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> stats:(fs_BigIntStats, fs_Stats) union2 -> unit) -> unit [@@js.global "stat"]
  module[@js.scope "stat"] Stat : sig
    (**
      Asynchronous stat(2) - Get file status.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: path:fs_PathLike -> ?options:(fs_StatOptions, anonymous_interface_3) intersection2 -> unit -> fs_Stats Promise.t_1 [@@js.global "__promisify__"]
    (** Asynchronous stat(2) - Get file status. *)
    val __promisify__: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> fs_BigIntStats Promise.t_1 [@@js.global "__promisify__"]
    (** Asynchronous stat(2) - Get file status. *)
    val __promisify__: path:fs_PathLike -> ?options:fs_StatOptions -> unit -> (fs_BigIntStats, fs_Stats) union2 Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous stat(2) - Get file status.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val statSync: path:fs_PathLike -> ?options:(fs_StatOptions, anonymous_interface_3) intersection2 -> unit -> fs_Stats [@@js.global "statSync"]
  (** Synchronous stat(2) - Get file status. *)
  val statSync: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> fs_BigIntStats [@@js.global "statSync"]
  (** Synchronous stat(2) - Get file status. *)
  val statSync: path:fs_PathLike -> ?options:fs_StatOptions -> unit -> (fs_BigIntStats, fs_Stats) union2 [@@js.global "statSync"]
  (**
    Asynchronous fstat(2) - Get file status.
    @param fd A file descriptor.
  *)
  val fstat: fd:float -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_Stats -> unit) -> unit [@@js.global "fstat"]
  (** Asynchronous fstat(2) - Get file status. *)
  val fstat: fd:float -> options:(fs_StatOptions, anonymous_interface_3) intersection2 or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_Stats -> unit) -> unit [@@js.global "fstat"]
  (** Asynchronous fstat(2) - Get file status. *)
  val fstat: fd:float -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_BigIntStats -> unit) -> unit [@@js.global "fstat"]
  (** Asynchronous fstat(2) - Get file status. *)
  val fstat: fd:float -> options:fs_StatOptions or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> stats:(fs_BigIntStats, fs_Stats) union2 -> unit) -> unit [@@js.global "fstat"]
  module[@js.scope "fstat"] Fstat : sig
    (**
      Asynchronous fstat(2) - Get file status.
      @param fd A file descriptor.
    *)
    val __promisify__: fd:float -> ?options:(fs_StatOptions, anonymous_interface_3) intersection2 -> unit -> fs_Stats Promise.t_1 [@@js.global "__promisify__"]
    (** Asynchronous fstat(2) - Get file status. *)
    val __promisify__: fd:float -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> fs_BigIntStats Promise.t_1 [@@js.global "__promisify__"]
    (** Asynchronous fstat(2) - Get file status. *)
    val __promisify__: fd:float -> ?options:fs_StatOptions -> unit -> (fs_BigIntStats, fs_Stats) union2 Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous fstat(2) - Get file status.
    @param fd A file descriptor.
  *)
  val fstatSync: fd:float -> ?options:(fs_StatOptions, anonymous_interface_3) intersection2 -> unit -> fs_Stats [@@js.global "fstatSync"]
  (** Synchronous fstat(2) - Get file status. *)
  val fstatSync: fd:float -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> fs_BigIntStats [@@js.global "fstatSync"]
  (** Synchronous fstat(2) - Get file status. *)
  val fstatSync: fd:float -> ?options:fs_StatOptions -> unit -> (fs_BigIntStats, fs_Stats) union2 [@@js.global "fstatSync"]
  (**
    Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val lstat: path:fs_PathLike -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_Stats -> unit) -> unit [@@js.global "lstat"]
  (** Asynchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
  val lstat: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_3) intersection2 or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_Stats -> unit) -> unit [@@js.global "lstat"]
  (** Asynchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
  val lstat: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> callback:(err:_NodeJS_ErrnoException or_null -> stats:fs_BigIntStats -> unit) -> unit [@@js.global "lstat"]
  (** Asynchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
  val lstat: path:fs_PathLike -> options:fs_StatOptions or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> stats:(fs_BigIntStats, fs_Stats) union2 -> unit) -> unit [@@js.global "lstat"]
  module[@js.scope "lstat"] Lstat : sig
    (**
      Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: path:fs_PathLike -> ?options:(fs_StatOptions, anonymous_interface_3) intersection2 -> unit -> fs_Stats Promise.t_1 [@@js.global "__promisify__"]
    (** Asynchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
    val __promisify__: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> fs_BigIntStats Promise.t_1 [@@js.global "__promisify__"]
    (** Asynchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
    val __promisify__: path:fs_PathLike -> ?options:fs_StatOptions -> unit -> (fs_BigIntStats, fs_Stats) union2 Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val lstatSync: path:fs_PathLike -> ?options:(fs_StatOptions, anonymous_interface_3) intersection2 -> unit -> fs_Stats [@@js.global "lstatSync"]
  (** Synchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
  val lstatSync: path:fs_PathLike -> options:(fs_StatOptions, anonymous_interface_4) intersection2 -> fs_BigIntStats [@@js.global "lstatSync"]
  (** Synchronous lstat(2) - Get file status. Does not dereference symbolic links. *)
  val lstatSync: path:fs_PathLike -> ?options:fs_StatOptions -> unit -> (fs_BigIntStats, fs_Stats) union2 [@@js.global "lstatSync"]
  (**
    Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
    @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val link: existingPath:fs_PathLike -> newPath:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "link"]
  module[@js.scope "link"] Link : sig
    (**
      Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
      @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: existingPath:fs_PathLike -> newPath:fs_PathLike -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.
    @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val linkSync: existingPath:fs_PathLike -> newPath:fs_PathLike -> unit [@@js.global "linkSync"]
  (**
    Asynchronous symlink(2) - Create a new symbolic link to an existing file.
    @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
    @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
    @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
    When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
  *)
  val symlink: target:fs_PathLike -> path:fs_PathLike -> type_:fs_symlink_Type or_null_or_undefined -> callback:fs_NoParamCallback -> unit [@@js.global "symlink"]
  (**
    Asynchronous symlink(2) - Create a new symbolic link to an existing file.
    @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
    @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
  *)
  val symlink: target:fs_PathLike -> path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "symlink"]
  module[@js.scope "symlink"] Symlink : sig
    (**
      Asynchronous symlink(2) - Create a new symbolic link to an existing file.
      @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
      @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
      @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
      When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
    *)
    val __promisify__: target:fs_PathLike -> path:fs_PathLike -> ?type_:string or_null -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
    module Type : sig
      type t = fs_symlink_Type
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
  end
  (**
    Synchronous symlink(2) - Create a new symbolic link to an existing file.
    @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
    @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
    @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
    When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
  *)
  val symlinkSync: target:fs_PathLike -> path:fs_PathLike -> ?type_:fs_symlink_Type or_null -> unit -> unit [@@js.global "symlinkSync"]
  (**
    Asynchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readlink: path:fs_PathLike -> options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> linkString:string -> unit) -> unit [@@js.global "readlink"]
  (**
    Asynchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readlink: path:fs_PathLike -> options:fs_BufferEncodingOption -> callback:(err:_NodeJS_ErrnoException or_null -> linkString:_Buffer -> unit) -> unit [@@js.global "readlink"]
  (**
    Asynchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readlink: path:fs_PathLike -> options:fs_BaseEncodingOptions or_string or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> linkString:_Buffer or_string -> unit) -> unit [@@js.global "readlink"]
  (**
    Asynchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val readlink: path:fs_PathLike -> callback:(err:_NodeJS_ErrnoException or_null -> linkString:string -> unit) -> unit [@@js.global "readlink"]
  module[@js.scope "readlink"] Readlink : sig
    (**
      Asynchronous readlink(2) - read value of a symbolic link.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous readlink(2) - read value of a symbolic link.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> options:fs_BufferEncodingOption -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous readlink(2) - read value of a symbolic link.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readlinkSync: path:fs_PathLike -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string [@@js.global "readlinkSync"]
  (**
    Synchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readlinkSync: path:fs_PathLike -> options:fs_BufferEncodingOption -> _Buffer [@@js.global "readlinkSync"]
  (**
    Synchronous readlink(2) - read value of a symbolic link.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readlinkSync: path:fs_PathLike -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string [@@js.global "readlinkSync"]
  (**
    Asynchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val realpath: path:fs_PathLike -> options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:string -> unit) -> unit [@@js.global "realpath"]
  (**
    Asynchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val realpath: path:fs_PathLike -> options:fs_BufferEncodingOption -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:_Buffer -> unit) -> unit [@@js.global "realpath"]
  (**
    Asynchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val realpath: path:fs_PathLike -> options:fs_BaseEncodingOptions or_string or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:_Buffer or_string -> unit) -> unit [@@js.global "realpath"]
  (**
    Asynchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val realpath: path:fs_PathLike -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:string -> unit) -> unit [@@js.global "realpath"]
  module[@js.scope "realpath"] Realpath : sig
    (**
      Asynchronous realpath(3) - return the canonicalized absolute pathname.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous realpath(3) - return the canonicalized absolute pathname.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> options:fs_BufferEncodingOption -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous realpath(3) - return the canonicalized absolute pathname.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string Promise.t_1 [@@js.global "__promisify__"]
    val native: path:fs_PathLike -> options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:string -> unit) -> unit [@@js.global "native"]
    val native: path:fs_PathLike -> options:fs_BufferEncodingOption -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:_Buffer -> unit) -> unit [@@js.global "native"]
    val native: path:fs_PathLike -> options:fs_BaseEncodingOptions or_string or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:_Buffer or_string -> unit) -> unit [@@js.global "native"]
    val native: path:fs_PathLike -> callback:(err:_NodeJS_ErrnoException or_null -> resolvedPath:string -> unit) -> unit [@@js.global "native"]
  end
  (**
    Synchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val realpathSync: path:fs_PathLike -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string [@@js.global "realpathSync"]
  (**
    Synchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val realpathSync: path:fs_PathLike -> options:fs_BufferEncodingOption -> _Buffer [@@js.global "realpathSync"]
  (**
    Synchronous realpath(3) - return the canonicalized absolute pathname.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val realpathSync: path:fs_PathLike -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string [@@js.global "realpathSync"]
  module[@js.scope "realpathSync"] RealpathSync : sig
    val native: path:fs_PathLike -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string [@@js.global "native"]
    val native: path:fs_PathLike -> options:fs_BufferEncodingOption -> _Buffer [@@js.global "native"]
    val native: path:fs_PathLike -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string [@@js.global "native"]
  end
  (**
    Asynchronous unlink(2) - delete a name and possibly the file it refers to.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val unlink: path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "unlink"]
  module[@js.scope "unlink"] Unlink : sig
    (**
      Asynchronous unlink(2) - delete a name and possibly the file it refers to.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: path:fs_PathLike -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous unlink(2) - delete a name and possibly the file it refers to.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val unlinkSync: path:fs_PathLike -> unit [@@js.global "unlinkSync"]
  module[@js.scope "RmDirOptions"] RmDirOptions : sig
    type t = fs_RmDirOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
      `EPERM` error is encountered, Node.js will retry the operation with a linear
      backoff wait of `retryDelay` ms longer on each try. This option represents the
      number of retries. This option is ignored if the `recursive` option is not
      `true`.
      default: 0
    *)
    (**
      If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
      `EPERM` error is encountered, Node.js will retry the operation with a linear
      backoff wait of `retryDelay` ms longer on each try. This option represents the
      number of retries. This option is ignored if the `recursive` option is not
      `true`.
      default: 0
    *)
    val get_maxRetries: t -> float [@@js.get "maxRetries"]
    (**
      If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
      `EPERM` error is encountered, Node.js will retry the operation with a linear
      backoff wait of `retryDelay` ms longer on each try. This option represents the
      number of retries. This option is ignored if the `recursive` option is not
      `true`.
      default: 0
    *)
    val set_maxRetries: t -> float -> unit [@@js.set "maxRetries"]
    (**
      @deprecated since v14.14.0 In future versions of Node.js,
      `fs.rmdir(path, \{ recursive: true \})` will throw on nonexistent
      paths, or when given a file as a target.
      Use `fs.rm(path, \{ recursive: true, force: true \})` instead.
      
      If `true`, perform a recursive directory removal. In
      recursive mode, errors are not reported if `path` does not exist, and
      operations are retried on failure.
      default: false
    *)
    (**
      @deprecated since v14.14.0 In future versions of Node.js,
      `fs.rmdir(path, \{ recursive: true \})` will throw on nonexistent
      paths, or when given a file as a target.
      Use `fs.rm(path, \{ recursive: true, force: true \})` instead.
      
      If `true`, perform a recursive directory removal. In
      recursive mode, errors are not reported if `path` does not exist, and
      operations are retried on failure.
      default: false
    *)
    val get_recursive: t -> bool [@@js.get "recursive"]
    (**
      @deprecated since v14.14.0 In future versions of Node.js,
      `fs.rmdir(path, \{ recursive: true \})` will throw on nonexistent
      paths, or when given a file as a target.
      Use `fs.rm(path, \{ recursive: true, force: true \})` instead.
      
      If `true`, perform a recursive directory removal. In
      recursive mode, errors are not reported if `path` does not exist, and
      operations are retried on failure.
      default: false
    *)
    val set_recursive: t -> bool -> unit [@@js.set "recursive"]
    (**
      The amount of time in milliseconds to wait between retries.
      This option is ignored if the `recursive` option is not `true`.
      default: 100
    *)
    (**
      The amount of time in milliseconds to wait between retries.
      This option is ignored if the `recursive` option is not `true`.
      default: 100
    *)
    val get_retryDelay: t -> float [@@js.get "retryDelay"]
    (**
      The amount of time in milliseconds to wait between retries.
      This option is ignored if the `recursive` option is not `true`.
      default: 100
    *)
    val set_retryDelay: t -> float -> unit [@@js.set "retryDelay"]
  end
  (**
    Asynchronous rmdir(2) - delete a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val rmdir: path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "rmdir"]
  (** Asynchronous rmdir(2) - delete a directory. *)
  val rmdir: path:fs_PathLike -> options:fs_RmDirOptions -> callback:fs_NoParamCallback -> unit [@@js.global "rmdir"]
  module[@js.scope "rmdir"] Rmdir : sig
    (**
      Asynchronous rmdir(2) - delete a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    *)
    val __promisify__: path:fs_PathLike -> ?options:fs_RmDirOptions -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous rmdir(2) - delete a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val rmdirSync: path:fs_PathLike -> ?options:fs_RmDirOptions -> unit -> unit [@@js.global "rmdirSync"]
  module[@js.scope "RmOptions"] RmOptions : sig
    type t = fs_RmOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      When `true`, exceptions will be ignored if `path` does not exist.
      default: false
    *)
    (**
      When `true`, exceptions will be ignored if `path` does not exist.
      default: false
    *)
    val get_force: t -> bool [@@js.get "force"]
    (**
      When `true`, exceptions will be ignored if `path` does not exist.
      default: false
    *)
    val set_force: t -> bool -> unit [@@js.set "force"]
    (**
      If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
      `EPERM` error is encountered, Node.js will retry the operation with a linear
      backoff wait of `retryDelay` ms longer on each try. This option represents the
      number of retries. This option is ignored if the `recursive` option is not
      `true`.
      default: 0
    *)
    (**
      If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
      `EPERM` error is encountered, Node.js will retry the operation with a linear
      backoff wait of `retryDelay` ms longer on each try. This option represents the
      number of retries. This option is ignored if the `recursive` option is not
      `true`.
      default: 0
    *)
    val get_maxRetries: t -> float [@@js.get "maxRetries"]
    (**
      If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
      `EPERM` error is encountered, Node.js will retry the operation with a linear
      backoff wait of `retryDelay` ms longer on each try. This option represents the
      number of retries. This option is ignored if the `recursive` option is not
      `true`.
      default: 0
    *)
    val set_maxRetries: t -> float -> unit [@@js.set "maxRetries"]
    (**
      If `true`, perform a recursive directory removal. In
      recursive mode, errors are not reported if `path` does not exist, and
      operations are retried on failure.
      default: false
    *)
    (**
      If `true`, perform a recursive directory removal. In
      recursive mode, errors are not reported if `path` does not exist, and
      operations are retried on failure.
      default: false
    *)
    val get_recursive: t -> bool [@@js.get "recursive"]
    (**
      If `true`, perform a recursive directory removal. In
      recursive mode, errors are not reported if `path` does not exist, and
      operations are retried on failure.
      default: false
    *)
    val set_recursive: t -> bool -> unit [@@js.set "recursive"]
    (**
      The amount of time in milliseconds to wait between retries.
      This option is ignored if the `recursive` option is not `true`.
      default: 100
    *)
    (**
      The amount of time in milliseconds to wait between retries.
      This option is ignored if the `recursive` option is not `true`.
      default: 100
    *)
    val get_retryDelay: t -> float [@@js.get "retryDelay"]
    (**
      The amount of time in milliseconds to wait between retries.
      This option is ignored if the `recursive` option is not `true`.
      default: 100
    *)
    val set_retryDelay: t -> float -> unit [@@js.set "retryDelay"]
  end
  (** Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). *)
  val rm: path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "rm"]
  (** Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). *)
  val rm: path:fs_PathLike -> options:fs_RmOptions -> callback:fs_NoParamCallback -> unit [@@js.global "rm"]
  module[@js.scope "rm"] Rm : sig
    (** Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). *)
    val __promisify__: path:fs_PathLike -> ?options:fs_RmOptions -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (** Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). *)
  val rmSync: path:fs_PathLike -> ?options:fs_RmOptions -> unit -> unit [@@js.global "rmSync"]
  module[@js.scope "MakeDirectoryOptions"] MakeDirectoryOptions : sig
    type t = fs_MakeDirectoryOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Indicates whether parent folders should be created.
      If a folder was created, the path to the first created folder will be returned.
      default: false
    *)
    (**
      Indicates whether parent folders should be created.
      If a folder was created, the path to the first created folder will be returned.
      default: false
    *)
    val get_recursive: t -> bool [@@js.get "recursive"]
    (**
      Indicates whether parent folders should be created.
      If a folder was created, the path to the first created folder will be returned.
      default: false
    *)
    val set_recursive: t -> bool -> unit [@@js.set "recursive"]
    (**
      A file mode. If a string is passed, it is parsed as an octal integer. If not specified
      default: 0o777
    *)
    (**
      A file mode. If a string is passed, it is parsed as an octal integer. If not specified
      default: 0o777
    *)
    val get_mode: t -> fs_Mode [@@js.get "mode"]
    (**
      A file mode. If a string is passed, it is parsed as an octal integer. If not specified
      default: 0o777
    *)
    val set_mode: t -> fs_Mode -> unit [@@js.set "mode"]
  end
  (**
    Asynchronous mkdir(2) - create a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
    should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
  *)
  val mkdir: path:fs_PathLike -> options:(fs_MakeDirectoryOptions, anonymous_interface_46) intersection2 -> callback:(err:_NodeJS_ErrnoException or_null -> ?path:string -> unit -> unit) -> unit [@@js.global "mkdir"]
  (**
    Asynchronous mkdir(2) - create a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
    should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
  *)
  val mkdir: path:fs_PathLike -> options:fs_Mode or_null_or_undefined -> callback:fs_NoParamCallback -> unit [@@js.global "mkdir"]
  (**
    Asynchronous mkdir(2) - create a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
    should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
  *)
  val mkdir: path:fs_PathLike -> options:(fs_MakeDirectoryOptions, fs_Mode) union2 or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> ?path:string -> unit -> unit) -> unit [@@js.global "mkdir"]
  (**
    Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val mkdir: path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "mkdir"]
  module[@js.scope "mkdir"] Mkdir : sig
    (**
      Asynchronous mkdir(2) - create a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
    *)
    val __promisify__: path:fs_PathLike -> options:(fs_MakeDirectoryOptions, anonymous_interface_46) intersection2 -> string or_undefined Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous mkdir(2) - create a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
    *)
    val __promisify__: path:fs_PathLike -> ?options:fs_Mode or_null -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous mkdir(2) - create a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
    *)
    val __promisify__: path:fs_PathLike -> ?options:(fs_MakeDirectoryOptions, fs_Mode) union2 or_null -> unit -> string or_undefined Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous mkdir(2) - create a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
    should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
  *)
  val mkdirSync: path:fs_PathLike -> options:(fs_MakeDirectoryOptions, anonymous_interface_46) intersection2 -> string or_undefined [@@js.global "mkdirSync"]
  (**
    Synchronous mkdir(2) - create a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
    should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
  *)
  val mkdirSync: path:fs_PathLike -> ?options:fs_Mode or_null -> unit -> unit [@@js.global "mkdirSync"]
  (**
    Synchronous mkdir(2) - create a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
    should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
  *)
  val mkdirSync: path:fs_PathLike -> ?options:(fs_MakeDirectoryOptions, fs_Mode) union2 or_null -> unit -> string or_undefined [@@js.global "mkdirSync"]
  (**
    Asynchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val mkdtemp: prefix:string -> options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> folder:string -> unit) -> unit [@@js.global "mkdtemp"]
  (**
    Asynchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val mkdtemp: prefix:string -> options:(anonymous_interface_14, ([`L_s187_buffer] [@js.enum])) or_enum -> callback:(err:_NodeJS_ErrnoException or_null -> folder:_Buffer -> unit) -> unit [@@js.global "mkdtemp"]
  (**
    Asynchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val mkdtemp: prefix:string -> options:fs_BaseEncodingOptions or_string or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> folder:_Buffer or_string -> unit) -> unit [@@js.global "mkdtemp"]
  (**
    Asynchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
  *)
  val mkdtemp: prefix:string -> callback:(err:_NodeJS_ErrnoException or_null -> folder:string -> unit) -> unit [@@js.global "mkdtemp"]
  module[@js.scope "mkdtemp"] Mkdtemp : sig
    (**
      Asynchronously creates a unique temporary directory.
      Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: prefix:string -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronously creates a unique temporary directory.
      Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: prefix:string -> options:fs_BufferEncodingOption -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronously creates a unique temporary directory.
      Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: prefix:string -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val mkdtempSync: prefix:string -> ?options:(fs_BaseEncodingOptions, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string [@@js.global "mkdtempSync"]
  (**
    Synchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val mkdtempSync: prefix:string -> options:fs_BufferEncodingOption -> _Buffer [@@js.global "mkdtempSync"]
  (**
    Synchronously creates a unique temporary directory.
    Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val mkdtempSync: prefix:string -> ?options:fs_BaseEncodingOptions or_string or_null -> unit -> _Buffer or_string [@@js.global "mkdtempSync"]
  (**
    Asynchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readdir: path:fs_PathLike -> options:(anonymous_interface_18, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> files:string list -> unit) -> unit [@@js.global "readdir"]
  (**
    Asynchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readdir: path:fs_PathLike -> options:(anonymous_interface_16, ([`L_s187_buffer] [@js.enum])) or_enum -> callback:(err:_NodeJS_ErrnoException or_null -> files:_Buffer list -> unit) -> unit [@@js.global "readdir"]
  (**
    Asynchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readdir: path:fs_PathLike -> options:([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum]) or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> files:_Buffer or_string list -> unit) -> unit [@@js.global "readdir"]
  (**
    Asynchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val readdir: path:fs_PathLike -> callback:(err:_NodeJS_ErrnoException or_null -> files:string list -> unit) -> unit [@@js.global "readdir"]
  (**
    Asynchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
  *)
  val readdir: path:fs_PathLike -> options:(fs_BaseEncodingOptions, anonymous_interface_63) intersection2 -> callback:(err:_NodeJS_ErrnoException or_null -> files:fs_Dirent list -> unit) -> unit [@@js.global "readdir"]
  module[@js.scope "readdir"] Readdir : sig
    (**
      Asynchronous readdir(3) - read a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> ?options:(anonymous_interface_18, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string list Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous readdir(3) - read a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> options:(anonymous_interface_16, ([`L_s187_buffer] [@js.enum])) or_enum -> _Buffer list Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous readdir(3) - read a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
    *)
    val __promisify__: path:fs_PathLike -> ?options:([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum]) or_null -> unit -> _Buffer or_string list Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronous readdir(3) - read a directory.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param options If called with `withFileTypes: true` the result data will be an array of Dirent
    *)
    val __promisify__: path:fs_PathLike -> options:(fs_BaseEncodingOptions, anonymous_interface_63) intersection2 -> fs_Dirent list Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readdirSync: path:fs_PathLike -> ?options:(anonymous_interface_18, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null -> unit -> string list [@@js.global "readdirSync"]
  (**
    Synchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readdirSync: path:fs_PathLike -> options:(anonymous_interface_16, ([`L_s187_buffer] [@js.enum])) or_enum -> _Buffer list [@@js.global "readdirSync"]
  (**
    Synchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
  *)
  val readdirSync: path:fs_PathLike -> ?options:([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum]) or_null -> unit -> _Buffer or_string list [@@js.global "readdirSync"]
  (**
    Synchronous readdir(3) - read a directory.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
  *)
  val readdirSync: path:fs_PathLike -> options:(fs_BaseEncodingOptions, anonymous_interface_63) intersection2 -> fs_Dirent list [@@js.global "readdirSync"]
  (**
    Asynchronous close(2) - close a file descriptor.
    @param fd A file descriptor.
  *)
  val close: fd:float -> callback:fs_NoParamCallback -> unit [@@js.global "close"]
  module[@js.scope "close"] Close : sig
    (**
      Asynchronous close(2) - close a file descriptor.
      @param fd A file descriptor.
    *)
    val __promisify__: fd:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous close(2) - close a file descriptor.
    @param fd A file descriptor.
  *)
  val closeSync: fd:float -> unit [@@js.global "closeSync"]
  (**
    Asynchronous open(2) - open and possibly create a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
  *)
  val open_: path:fs_PathLike -> flags:fs_OpenMode -> mode:fs_Mode or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> fd:float -> unit) -> unit [@@js.global "open"]
  (**
    Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
  *)
  val open_: path:fs_PathLike -> flags:fs_OpenMode -> callback:(err:_NodeJS_ErrnoException or_null -> fd:float -> unit) -> unit [@@js.global "open"]
  module[@js.scope "open"] Open : sig
    (**
      Asynchronous open(2) - open and possibly create a file.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
    *)
    val __promisify__: path:fs_PathLike -> flags:fs_OpenMode -> ?mode:fs_Mode or_null -> unit -> float Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous open(2) - open and possibly create a file, returning a file descriptor..
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
  *)
  val openSync: path:fs_PathLike -> flags:fs_OpenMode -> ?mode:fs_Mode or_null -> unit -> float [@@js.global "openSync"]
  (**
    Asynchronously change file timestamps of the file referenced by the supplied path.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param atime The last access time. If a string is provided, it will be coerced to number.
    @param mtime The last modified time. If a string is provided, it will be coerced to number.
  *)
  val utimes: path:fs_PathLike -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> callback:fs_NoParamCallback -> unit [@@js.global "utimes"]
  module[@js.scope "utimes"] Utimes : sig
    (**
      Asynchronously change file timestamps of the file referenced by the supplied path.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      @param atime The last access time. If a string is provided, it will be coerced to number.
      @param mtime The last modified time. If a string is provided, it will be coerced to number.
    *)
    val __promisify__: path:fs_PathLike -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously change file timestamps of the file referenced by the supplied path.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    @param atime The last access time. If a string is provided, it will be coerced to number.
    @param mtime The last modified time. If a string is provided, it will be coerced to number.
  *)
  val utimesSync: path:fs_PathLike -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> unit [@@js.global "utimesSync"]
  (**
    Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param atime The last access time. If a string is provided, it will be coerced to number.
    @param mtime The last modified time. If a string is provided, it will be coerced to number.
  *)
  val futimes: fd:float -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> callback:fs_NoParamCallback -> unit [@@js.global "futimes"]
  module[@js.scope "futimes"] Futimes : sig
    (**
      Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
      @param fd A file descriptor.
      @param atime The last access time. If a string is provided, it will be coerced to number.
      @param mtime The last modified time. If a string is provided, it will be coerced to number.
    *)
    val __promisify__: fd:float -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously change file timestamps of the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param atime The last access time. If a string is provided, it will be coerced to number.
    @param mtime The last modified time. If a string is provided, it will be coerced to number.
  *)
  val futimesSync: fd:float -> atime:Date.t_0 or_string or_number -> mtime:Date.t_0 or_string or_number -> unit [@@js.global "futimesSync"]
  (**
    Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
    @param fd A file descriptor.
  *)
  val fsync: fd:float -> callback:fs_NoParamCallback -> unit [@@js.global "fsync"]
  module[@js.scope "fsync"] Fsync : sig
    (**
      Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
      @param fd A file descriptor.
    *)
    val __promisify__: fd:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
    @param fd A file descriptor.
  *)
  val fsyncSync: fd:float -> unit [@@js.global "fsyncSync"]
  (**
    Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
    @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
    @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
  *)
  val write: fd:float -> buffer:'TBuffer -> offset:float or_null_or_undefined -> length:float or_null_or_undefined -> position:float or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> buffer:'TBuffer -> unit) -> unit [@@js.global "write"]
  (**
    Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
    @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
  *)
  val write: fd:float -> buffer:'TBuffer -> offset:float or_null_or_undefined -> length:float or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> buffer:'TBuffer -> unit) -> unit [@@js.global "write"]
  (**
    Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
  *)
  val write: fd:float -> buffer:'TBuffer -> offset:float or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> buffer:'TBuffer -> unit) -> unit [@@js.global "write"]
  (**
    Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
  *)
  val write: fd:float -> buffer:'TBuffer -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> buffer:'TBuffer -> unit) -> unit [@@js.global "write"]
  (**
    Asynchronously writes `string` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param string A string to write.
    @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
    @param encoding The expected string encoding.
  *)
  val write: fd:float -> string:string -> position:float or_null_or_undefined -> encoding:_BufferEncoding or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> str:string -> unit) -> unit [@@js.global "write"]
  (**
    Asynchronously writes `string` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param string A string to write.
    @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
  *)
  val write: fd:float -> string:string -> position:float or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> str:string -> unit) -> unit [@@js.global "write"]
  (**
    Asynchronously writes `string` to the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param string A string to write.
  *)
  val write: fd:float -> string:string -> callback:(err:_NodeJS_ErrnoException or_null -> written:float -> str:string -> unit) -> unit [@@js.global "write"]
  module[@js.scope "write"] Write : sig
    (**
      Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
      @param fd A file descriptor.
      @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
      @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
      @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
    *)
    val __promisify__: fd:float -> ?buffer:'TBuffer -> ?offset:float -> ?length:float -> ?position:float or_null -> unit -> anonymous_interface_6 Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronously writes `string` to the file referenced by the supplied file descriptor.
      @param fd A file descriptor.
      @param string A string to write.
      @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
      @param encoding The expected string encoding.
    *)
    val __promisify__: fd:float -> string:string -> ?position:float or_null -> ?encoding:_BufferEncoding or_null -> unit -> anonymous_interface_7 Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.
    @param fd A file descriptor.
    @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
    @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
    @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
  *)
  val writeSync: fd:float -> buffer:_NodeJS_ArrayBufferView -> ?offset:float or_null -> ?length:float or_null -> ?position:float or_null -> unit -> float [@@js.global "writeSync"]
  (**
    Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
    @param fd A file descriptor.
    @param string A string to write.
    @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
    @param encoding The expected string encoding.
  *)
  val writeSync: fd:float -> string:string -> ?position:float or_null -> ?encoding:_BufferEncoding or_null -> unit -> float [@@js.global "writeSync"]
  (**
    Asynchronously reads data from the file referenced by the supplied file descriptor.
    @param fd A file descriptor.
    @param buffer The buffer that the data will be written to.
    @param offset The offset in the buffer at which to start writing.
    @param length The number of bytes to read.
    @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
  *)
  val read: fd:float -> buffer:'TBuffer -> offset:float -> length:float -> position:float or_null -> callback:(err:_NodeJS_ErrnoException or_null -> bytesRead:float -> buffer:'TBuffer -> unit) -> unit [@@js.global "read"]
  module[@js.scope "read"] Read : sig
    (**
      @param fd A file descriptor.
      @param buffer The buffer that the data will be written to.
      @param offset The offset in the buffer at which to start writing.
      @param length The number of bytes to read.
      @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
    *)
    val __promisify__: fd:float -> buffer:'TBuffer -> offset:float -> length:float -> position:float or_null -> anonymous_interface_5 Promise.t_1 [@@js.global "__promisify__"]
  end
  module[@js.scope "ReadSyncOptions"] ReadSyncOptions : sig
    type t = fs_ReadSyncOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** default: 0 *)
    (** default: 0 *)
    val get_offset: t -> float [@@js.get "offset"]
    (** default: 0 *)
    val set_offset: t -> float -> unit [@@js.set "offset"]
    (** default: `length of buffer` *)
    (** default: `length of buffer` *)
    val get_length: t -> float [@@js.get "length"]
    (** default: `length of buffer` *)
    val set_length: t -> float -> unit [@@js.set "length"]
    (** default: null *)
    (** default: null *)
    val get_position: t -> float or_null [@@js.get "position"]
    (** default: null *)
    val set_position: t -> float or_null -> unit [@@js.set "position"]
  end
  (**
    Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.
    @param fd A file descriptor.
    @param buffer The buffer that the data will be written to.
    @param offset The offset in the buffer at which to start writing.
    @param length The number of bytes to read.
    @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
  *)
  val readSync: fd:float -> buffer:_NodeJS_ArrayBufferView -> offset:float -> length:float -> position:float or_null -> float [@@js.global "readSync"]
  (**
    Similar to the above `fs.readSync` function, this version takes an optional `options` object.
    If no `options` object is specified, it will default with the above values.
  *)
  val readSync: fd:float -> buffer:_NodeJS_ArrayBufferView -> ?opts:fs_ReadSyncOptions -> unit -> float [@@js.global "readSync"]
  (**
    Asynchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param options An object that may contain an optional flag.
    If a flag is not provided, it defaults to `'r'`.
  *)
  val readFile: path:fs_PathLike or_number -> options:anonymous_interface_13 or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> data:_Buffer -> unit) -> unit [@@js.global "readFile"]
  (**
    Asynchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
    If a flag is not provided, it defaults to `'r'`.
  *)
  val readFile: path:fs_PathLike or_number -> options:anonymous_interface_12 or_string -> callback:(err:_NodeJS_ErrnoException or_null -> data:string -> unit) -> unit [@@js.global "readFile"]
  (**
    Asynchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
    If a flag is not provided, it defaults to `'r'`.
  *)
  val readFile: path:fs_PathLike or_number -> options:(fs_BaseEncodingOptions, anonymous_interface_26) intersection2 or_string or_null_or_undefined -> callback:(err:_NodeJS_ErrnoException or_null -> data:_Buffer or_string -> unit) -> unit [@@js.global "readFile"]
  (**
    Asynchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
  *)
  val readFile: path:fs_PathLike or_number -> callback:(err:_NodeJS_ErrnoException or_null -> data:_Buffer -> unit) -> unit [@@js.global "readFile"]
  module[@js.scope "readFile"] ReadFile : sig
    (**
      Asynchronously reads the entire contents of a file.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      @param options An object that may contain an optional flag.
      If a flag is not provided, it defaults to `'r'`.
    *)
    val __promisify__: path:fs_PathLike or_number -> ?options:anonymous_interface_13 or_null -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronously reads the entire contents of a file.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
      If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
      If a flag is not provided, it defaults to `'r'`.
    *)
    val __promisify__: path:fs_PathLike or_number -> options:anonymous_interface_12 or_string -> string Promise.t_1 [@@js.global "__promisify__"]
    (**
      Asynchronously reads the entire contents of a file.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
      If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
      If a flag is not provided, it defaults to `'r'`.
    *)
    val __promisify__: path:fs_PathLike or_number -> ?options:(fs_BaseEncodingOptions, anonymous_interface_26) intersection2 or_string or_null -> unit -> _Buffer or_string Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`.
  *)
  val readFileSync: path:fs_PathLike or_number -> ?options:anonymous_interface_13 or_null -> unit -> _Buffer [@@js.global "readFileSync"]
  (**
    Synchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
    If a flag is not provided, it defaults to `'r'`.
  *)
  val readFileSync: path:fs_PathLike or_number -> options:(anonymous_interface_12, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum -> string [@@js.global "readFileSync"]
  (**
    Synchronously reads the entire contents of a file.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
    If a flag is not provided, it defaults to `'r'`.
  *)
  val readFileSync: path:fs_PathLike or_number -> ?options:([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum]) or_null -> unit -> _Buffer or_string [@@js.global "readFileSync"]
  module WriteFileOptions : sig
    type t = fs_WriteFileOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  (**
    Asynchronously writes data to a file, replacing the file if it already exists.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
    @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `mode` is not supplied, the default of `0o666` is used.
    If `mode` is a string, it is parsed as an octal integer.
    If `flag` is not supplied, the default of `'w'` is used.
  *)
  val writeFile: path:fs_PathLike or_number -> data:_NodeJS_ArrayBufferView or_string -> options:fs_WriteFileOptions -> callback:fs_NoParamCallback -> unit [@@js.global "writeFile"]
  (**
    Asynchronously writes data to a file, replacing the file if it already exists.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
  *)
  val writeFile: path:fs_PathLike or_number -> data:_NodeJS_ArrayBufferView or_string -> callback:fs_NoParamCallback -> unit [@@js.global "writeFile"]
  module[@js.scope "writeFile"] WriteFile : sig
    (**
      Asynchronously writes data to a file, replacing the file if it already exists.
      @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
      If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
      @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
      If `encoding` is not supplied, the default of `'utf8'` is used.
      If `mode` is not supplied, the default of `0o666` is used.
      If `mode` is a string, it is parsed as an octal integer.
      If `flag` is not supplied, the default of `'w'` is used.
    *)
    val __promisify__: path:fs_PathLike or_number -> data:_NodeJS_ArrayBufferView or_string -> ?options:fs_WriteFileOptions -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously writes data to a file, replacing the file if it already exists.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
    @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `mode` is not supplied, the default of `0o666` is used.
    If `mode` is a string, it is parsed as an octal integer.
    If `flag` is not supplied, the default of `'w'` is used.
  *)
  val writeFileSync: path:fs_PathLike or_number -> data:_NodeJS_ArrayBufferView or_string -> ?options:fs_WriteFileOptions -> unit -> unit [@@js.global "writeFileSync"]
  (**
    Asynchronously append data to a file, creating the file if it does not exist.
    @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
    @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `mode` is not supplied, the default of `0o666` is used.
    If `mode` is a string, it is parsed as an octal integer.
    If `flag` is not supplied, the default of `'a'` is used.
  *)
  val appendFile: file:fs_PathLike or_number -> data:Uint8Array.t_0 or_string -> options:fs_WriteFileOptions -> callback:fs_NoParamCallback -> unit [@@js.global "appendFile"]
  (**
    Asynchronously append data to a file, creating the file if it does not exist.
    @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
  *)
  val appendFile: file:fs_PathLike or_number -> data:Uint8Array.t_0 or_string -> callback:fs_NoParamCallback -> unit [@@js.global "appendFile"]
  module[@js.scope "appendFile"] AppendFile : sig
    (**
      Asynchronously append data to a file, creating the file if it does not exist.
      @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
      If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
      @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
      If `encoding` is not supplied, the default of `'utf8'` is used.
      If `mode` is not supplied, the default of `0o666` is used.
      If `mode` is a string, it is parsed as an octal integer.
      If `flag` is not supplied, the default of `'a'` is used.
    *)
    val __promisify__: file:fs_PathLike or_number -> data:Uint8Array.t_0 or_string -> ?options:fs_WriteFileOptions -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously append data to a file, creating the file if it does not exist.
    @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    If a file descriptor is provided, the underlying file will _not_ be closed automatically.
    @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
    @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `mode` is not supplied, the default of `0o666` is used.
    If `mode` is a string, it is parsed as an octal integer.
    If `flag` is not supplied, the default of `'a'` is used.
  *)
  val appendFileSync: file:fs_PathLike or_number -> data:Uint8Array.t_0 or_string -> ?options:fs_WriteFileOptions -> unit -> unit [@@js.global "appendFileSync"]
  (** Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed. *)
  val watchFile: filename:fs_PathLike -> options:anonymous_interface_38 or_undefined -> listener:(curr:fs_Stats -> prev:fs_Stats -> unit) -> unit [@@js.global "watchFile"]
  (**
    Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
    @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val watchFile: filename:fs_PathLike -> listener:(curr:fs_Stats -> prev:fs_Stats -> unit) -> unit [@@js.global "watchFile"]
  (**
    Stop watching for changes on `filename`.
    @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val unwatchFile: filename:fs_PathLike -> ?listener:(curr:fs_Stats -> prev:fs_Stats -> unit) -> unit -> unit [@@js.global "unwatchFile"]
  (**
    Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
    @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `persistent` is not supplied, the default of `true` is used.
    If `recursive` is not supplied, the default of `false` is used.
  *)
  val watch: filename:fs_PathLike -> options:(anonymous_interface_17, ([`L_s179_ascii | `L_s181_base64 | `L_s182_base64url | `L_s185_binary | `L_s226_hex | `L_s242_latin1 | `L_s315_ucs_2 | `L_s316_ucs2 | `L_s327_utf_8 | `L_s328_utf16le | `L_s329_utf8] [@js.enum])) or_enum or_null_or_undefined -> ?listener:(event:([`L_s189_change[@js "change"] | `L_s284_rename[@js "rename"]] [@js.enum]) -> filename:string -> unit) -> unit -> fs_FSWatcher [@@js.global "watch"]
  (**
    Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
    @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `persistent` is not supplied, the default of `true` is used.
    If `recursive` is not supplied, the default of `false` is used.
  *)
  val watch: filename:fs_PathLike -> options:(anonymous_interface_15, ([`L_s187_buffer] [@js.enum])) or_enum -> ?listener:(event:([`L_s189_change[@js "change"] | `L_s284_rename[@js "rename"]] [@js.enum]) -> filename:_Buffer -> unit) -> unit -> fs_FSWatcher [@@js.global "watch"]
  (**
    Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
    @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
    @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
    If `encoding` is not supplied, the default of `'utf8'` is used.
    If `persistent` is not supplied, the default of `true` is used.
    If `recursive` is not supplied, the default of `false` is used.
  *)
  val watch: filename:fs_PathLike -> options:anonymous_interface_17 or_string or_null -> ?listener:(event:([`L_s189_change[@js "change"] | `L_s284_rename[@js "rename"]] [@js.enum]) -> filename:_Buffer or_string -> unit) -> unit -> fs_FSWatcher [@@js.global "watch"]
  (**
    Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
    @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val watch: filename:fs_PathLike -> ?listener:(event:([`L_s189_change[@js "change"] | `L_s284_rename[@js "rename"]] [@js.enum]) -> filename:string -> any) -> unit -> fs_FSWatcher [@@js.global "watch"]
  (**
    Asynchronously tests whether or not the given path exists by checking with the file system.
    @deprecated since v1.0.0 Use `fs.stat()` or `fs.access()` instead
    @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val exists: path:fs_PathLike -> callback:(exists:bool -> unit) -> unit [@@js.global "exists"]
  module[@js.scope "exists"] Exists : sig
    (**
      @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
    *)
    val __promisify__: path:fs_PathLike -> bool Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously tests whether or not the given path exists by checking with the file system.
    @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val existsSync: path:fs_PathLike -> bool [@@js.global "existsSync"]
  module[@js.scope "constants"] Constants : sig
    (** Constant for fs.access(). File is visible to the calling process. *)
    val f_ok: float [@@js.global "F_OK"]
    (** Constant for fs.access(). File can be read by the calling process. *)
    val r_ok: float [@@js.global "R_OK"]
    (** Constant for fs.access(). File can be written by the calling process. *)
    val w_ok: float [@@js.global "W_OK"]
    (** Constant for fs.access(). File can be executed by the calling process. *)
    val x_ok: float [@@js.global "X_OK"]
    (** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. *)
    val copyfile_excl: float [@@js.global "COPYFILE_EXCL"]
    (**
      Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
      If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
    *)
    val copyfile_ficlone: float [@@js.global "COPYFILE_FICLONE"]
    (**
      Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
      If the underlying platform does not support copy-on-write, then the operation will fail with an error.
    *)
    val copyfile_ficlone_force: float [@@js.global "COPYFILE_FICLONE_FORCE"]
    (** Constant for fs.open(). Flag indicating to open a file for read-only access. *)
    val o_rdonly: float [@@js.global "O_RDONLY"]
    (** Constant for fs.open(). Flag indicating to open a file for write-only access. *)
    val o_wronly: float [@@js.global "O_WRONLY"]
    (** Constant for fs.open(). Flag indicating to open a file for read-write access. *)
    val o_rdwr: float [@@js.global "O_RDWR"]
    (** Constant for fs.open(). Flag indicating to create the file if it does not already exist. *)
    val o_creat: float [@@js.global "O_CREAT"]
    (** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. *)
    val o_excl: float [@@js.global "O_EXCL"]
    (**
      Constant for fs.open(). Flag indicating that if path identifies a terminal device,
      opening the path shall not cause that terminal to become the controlling terminal for the process
      (if the process does not already have one).
    *)
    val o_noctty: float [@@js.global "O_NOCTTY"]
    (** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. *)
    val o_trunc: float [@@js.global "O_TRUNC"]
    (** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. *)
    val o_append: float [@@js.global "O_APPEND"]
    (** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. *)
    val o_directory: float [@@js.global "O_DIRECTORY"]
    (**
      constant for fs.open().
      Flag indicating reading accesses to the file system will no longer result in
      an update to the atime information associated with the file.
      This flag is available on Linux operating systems only.
    *)
    val o_noatime: float [@@js.global "O_NOATIME"]
    (** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. *)
    val o_nofollow: float [@@js.global "O_NOFOLLOW"]
    (** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. *)
    val o_sync: float [@@js.global "O_SYNC"]
    (** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. *)
    val o_dsync: float [@@js.global "O_DSYNC"]
    (** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. *)
    val o_symlink: float [@@js.global "O_SYMLINK"]
    (** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. *)
    val o_direct: float [@@js.global "O_DIRECT"]
    (** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. *)
    val o_nonblock: float [@@js.global "O_NONBLOCK"]
    (** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. *)
    val s_ifmt: float [@@js.global "S_IFMT"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. *)
    val s_ifreg: float [@@js.global "S_IFREG"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. *)
    val s_ifdir: float [@@js.global "S_IFDIR"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. *)
    val s_ifchr: float [@@js.global "S_IFCHR"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. *)
    val s_ifblk: float [@@js.global "S_IFBLK"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. *)
    val s_ififo: float [@@js.global "S_IFIFO"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. *)
    val s_iflnk: float [@@js.global "S_IFLNK"]
    (** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. *)
    val s_ifsock: float [@@js.global "S_IFSOCK"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. *)
    val s_irwxu: float [@@js.global "S_IRWXU"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. *)
    val s_irusr: float [@@js.global "S_IRUSR"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. *)
    val s_iwusr: float [@@js.global "S_IWUSR"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. *)
    val s_ixusr: float [@@js.global "S_IXUSR"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. *)
    val s_irwxg: float [@@js.global "S_IRWXG"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. *)
    val s_irgrp: float [@@js.global "S_IRGRP"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. *)
    val s_iwgrp: float [@@js.global "S_IWGRP"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. *)
    val s_ixgrp: float [@@js.global "S_IXGRP"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. *)
    val s_irwxo: float [@@js.global "S_IRWXO"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. *)
    val s_iroth: float [@@js.global "S_IROTH"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. *)
    val s_iwoth: float [@@js.global "S_IWOTH"]
    (** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. *)
    val s_ixoth: float [@@js.global "S_IXOTH"]
    (**
      When set, a memory file mapping is used to access the file. This flag
      is available on Windows operating systems only. On other operating systems,
      this flag is ignored.
    *)
    val uv_fs_o_filemap: float [@@js.global "UV_FS_O_FILEMAP"]
  end
  (**
    Asynchronously tests a user's permissions for the file specified by path.
    @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val access: path:fs_PathLike -> mode:float or_undefined -> callback:fs_NoParamCallback -> unit [@@js.global "access"]
  (**
    Asynchronously tests a user's permissions for the file specified by path.
    @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val access: path:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "access"]
  module[@js.scope "access"] Access : sig
    (**
      Asynchronously tests a user's permissions for the file specified by path.
      @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
      URL support is _experimental_.
    *)
    val __promisify__: path:fs_PathLike -> ?mode:float -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously tests a user's permissions for the file specified by path.
    @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val accessSync: path:fs_PathLike -> ?mode:float -> unit -> unit [@@js.global "accessSync"]
  (**
    Returns a new `ReadStream` object.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val createReadStream: path:fs_PathLike -> ?options:anonymous_interface_28 or_string -> unit -> fs_ReadStream [@@js.global "createReadStream"]
  (**
    Returns a new `WriteStream` object.
    @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
    URL support is _experimental_.
  *)
  val createWriteStream: path:fs_PathLike -> ?options:anonymous_interface_27 or_string -> unit -> fs_WriteStream [@@js.global "createWriteStream"]
  (**
    Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
    @param fd A file descriptor.
  *)
  val fdatasync: fd:float -> callback:fs_NoParamCallback -> unit [@@js.global "fdatasync"]
  module[@js.scope "fdatasync"] Fdatasync : sig
    (**
      Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
      @param fd A file descriptor.
    *)
    val __promisify__: fd:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.
    @param fd A file descriptor.
  *)
  val fdatasyncSync: fd:float -> unit [@@js.global "fdatasyncSync"]
  (**
    Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
    No arguments other than a possible exception are given to the callback function.
    Node.js makes no guarantees about the atomicity of the copy operation.
    If an error occurs after the destination file has been opened for writing, Node.js will attempt
    to remove the destination.
    @param src A path to the source file.
    @param dest A path to the destination file.
  *)
  val copyFile: src:fs_PathLike -> dest:fs_PathLike -> callback:fs_NoParamCallback -> unit [@@js.global "copyFile"]
  (**
    Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
    No arguments other than a possible exception are given to the callback function.
    Node.js makes no guarantees about the atomicity of the copy operation.
    If an error occurs after the destination file has been opened for writing, Node.js will attempt
    to remove the destination.
    @param src A path to the source file.
    @param dest A path to the destination file.
    @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
  *)
  val copyFile: src:fs_PathLike -> dest:fs_PathLike -> flags:float -> callback:fs_NoParamCallback -> unit [@@js.global "copyFile"]
  module[@js.scope "copyFile"] CopyFile : sig
    (**
      Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
      No arguments other than a possible exception are given to the callback function.
      Node.js makes no guarantees about the atomicity of the copy operation.
      If an error occurs after the destination file has been opened for writing, Node.js will attempt
      to remove the destination.
      @param src A path to the source file.
      @param dest A path to the destination file.
      @param flags An optional integer that specifies the behavior of the copy operation.
      The only supported flag is fs.constants.COPYFILE_EXCL,
      which causes the copy operation to fail if dest already exists.
    *)
    val __promisify__: src:fs_PathLike -> dst:fs_PathLike -> ?flags:float -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  end
  (**
    Synchronously copies src to dest. By default, dest is overwritten if it already exists.
    Node.js makes no guarantees about the atomicity of the copy operation.
    If an error occurs after the destination file has been opened for writing, Node.js will attempt
    to remove the destination.
    @param src A path to the source file.
    @param dest A path to the destination file.
    @param flags An optional integer that specifies the behavior of the copy operation.
    The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
  *)
  val copyFileSync: src:fs_PathLike -> dest:fs_PathLike -> ?flags:float -> unit -> unit [@@js.global "copyFileSync"]
  (**
    Write an array of ArrayBufferViews to the file specified by fd using writev().
    position is the offset from the beginning of the file where this data should be written.
    It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream().
    On Linux, positional writes don't work when the file is opened in append mode.
    The kernel ignores the position argument and always appends the data to the end of the file.
  *)
  val writev: fd:float -> buffers:_NodeJS_ArrayBufferView list -> cb:(err:_NodeJS_ErrnoException or_null -> bytesWritten:float -> buffers:_NodeJS_ArrayBufferView list -> unit) -> unit [@@js.global "writev"]
  (**
    Write an array of ArrayBufferViews to the file specified by fd using writev().
    position is the offset from the beginning of the file where this data should be written.
    It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream().
    On Linux, positional writes don't work when the file is opened in append mode.
    The kernel ignores the position argument and always appends the data to the end of the file.
  *)
  val writev: fd:float -> buffers:_NodeJS_ArrayBufferView list -> position:float -> cb:(err:_NodeJS_ErrnoException or_null -> bytesWritten:float -> buffers:_NodeJS_ArrayBufferView list -> unit) -> unit [@@js.global "writev"]
  module[@js.scope "WriteVResult"] WriteVResult : sig
    type t = fs_WriteVResult
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_bytesWritten: t -> float [@@js.get "bytesWritten"]
    val set_bytesWritten: t -> float -> unit [@@js.set "bytesWritten"]
    val get_buffers: t -> _NodeJS_ArrayBufferView list [@@js.get "buffers"]
    val set_buffers: t -> _NodeJS_ArrayBufferView list -> unit [@@js.set "buffers"]
  end
  module[@js.scope "writev"] Writev : sig
    val __promisify__: fd:float -> buffers:_NodeJS_ArrayBufferView list -> ?position:float -> unit -> fs_WriteVResult Promise.t_1 [@@js.global "__promisify__"]
  end
  (** See `writev`. *)
  val writevSync: fd:float -> buffers:_NodeJS_ArrayBufferView list -> ?position:float -> unit -> float [@@js.global "writevSync"]
  val readv: fd:float -> buffers:_NodeJS_ArrayBufferView list -> cb:(err:_NodeJS_ErrnoException or_null -> bytesRead:float -> buffers:_NodeJS_ArrayBufferView list -> unit) -> unit [@@js.global "readv"]
  val readv: fd:float -> buffers:_NodeJS_ArrayBufferView list -> position:float -> cb:(err:_NodeJS_ErrnoException or_null -> bytesRead:float -> buffers:_NodeJS_ArrayBufferView list -> unit) -> unit [@@js.global "readv"]
  module[@js.scope "ReadVResult"] ReadVResult : sig
    type t = fs_ReadVResult
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_bytesRead: t -> float [@@js.get "bytesRead"]
    val set_bytesRead: t -> float -> unit [@@js.set "bytesRead"]
    val get_buffers: t -> _NodeJS_ArrayBufferView list [@@js.get "buffers"]
    val set_buffers: t -> _NodeJS_ArrayBufferView list -> unit [@@js.set "buffers"]
  end
  module[@js.scope "readv"] Readv : sig
    val __promisify__: fd:float -> buffers:_NodeJS_ArrayBufferView list -> ?position:float -> unit -> fs_ReadVResult Promise.t_1 [@@js.global "__promisify__"]
  end
  (** See `readv`. *)
  val readvSync: fd:float -> buffers:_NodeJS_ArrayBufferView list -> ?position:float -> unit -> float [@@js.global "readvSync"]
  module[@js.scope "OpenDirOptions"] OpenDirOptions : sig
    type t = fs_OpenDirOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
    val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
    (**
      Number of directory entries that are buffered
      internally when reading from the directory. Higher values lead to better
      performance but higher memory usage.
      default: 32
    *)
    (**
      Number of directory entries that are buffered
      internally when reading from the directory. Higher values lead to better
      performance but higher memory usage.
      default: 32
    *)
    val get_bufferSize: t -> float [@@js.get "bufferSize"]
    (**
      Number of directory entries that are buffered
      internally when reading from the directory. Higher values lead to better
      performance but higher memory usage.
      default: 32
    *)
    val set_bufferSize: t -> float -> unit [@@js.set "bufferSize"]
  end
  val opendirSync: path:string -> ?options:fs_OpenDirOptions -> unit -> fs_Dir [@@js.global "opendirSync"]
  val opendir: path:string -> cb:(err:_NodeJS_ErrnoException or_null -> dir:fs_Dir -> unit) -> unit [@@js.global "opendir"]
  val opendir: path:string -> options:fs_OpenDirOptions -> cb:(err:_NodeJS_ErrnoException or_null -> dir:fs_Dir -> unit) -> unit [@@js.global "opendir"]
  module[@js.scope "opendir"] Opendir : sig
    val __promisify__: path:string -> ?options:fs_OpenDirOptions -> unit -> fs_Dir Promise.t_1 [@@js.global "__promisify__"]
  end
  module[@js.scope "BigIntStats"] BigIntStats : sig
    type t = fs_BigIntStats
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_atimeNs: t -> bigint [@@js.get "atimeNs"]
    val set_atimeNs: t -> bigint -> unit [@@js.set "atimeNs"]
    val get_mtimeNs: t -> bigint [@@js.get "mtimeNs"]
    val set_mtimeNs: t -> bigint -> unit [@@js.set "mtimeNs"]
    val get_ctimeNs: t -> bigint [@@js.get "ctimeNs"]
    val set_ctimeNs: t -> bigint -> unit [@@js.set "ctimeNs"]
    val get_birthtimeNs: t -> bigint [@@js.get "birthtimeNs"]
    val set_birthtimeNs: t -> bigint -> unit [@@js.set "birthtimeNs"]
    val cast: t -> bigint fs_StatsBase [@@js.cast]
  end
  module[@js.scope "BigIntOptions"] BigIntOptions : sig
    type t = fs_BigIntOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_bigint: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "bigint"]
    val set_bigint: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "bigint"]
  end
  module[@js.scope "StatOptions"] StatOptions : sig
    type t = fs_StatOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_bigint: t -> bool [@@js.get "bigint"]
    val set_bigint: t -> bool -> unit [@@js.set "bigint"]
  end
end
module[@js.scope "ErrorConstructor"] ErrorConstructor : sig
  type t = _ErrorConstructor
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (** Create .stack property on a target object *)
  val captureStackTrace: t -> targetObject:untyped_object -> ?constructorOpt:untyped_function -> unit -> unit [@@js.call "captureStackTrace"]
  (**
    Optional override for formatting stack traces
    @see "https" ://v8.dev/docs/stack-trace-api#customizing-stack-traces
  *)
  val prepareStackTrace: t -> err:Error.t_0 -> stackTraces:_NodeJS_CallSite list -> any [@@js.call "prepareStackTrace"]
  val get_stackTraceLimit: t -> float [@@js.get "stackTraceLimit"]
  val set_stackTraceLimit: t -> float -> unit [@@js.set "stackTraceLimit"]
end
module[@js.scope "String"] String : sig
  type t = _String
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (** Removes whitespace from the left end of a string. *)
  val trimLeft: t -> string [@@js.call "trimLeft"]
  (** Removes whitespace from the right end of a string. *)
  val trimRight: t -> string [@@js.call "trimRight"]
  (** Returns a copy with leading whitespace removed. *)
  val trimStart: t -> string [@@js.call "trimStart"]
  (** Returns a copy with trailing whitespace removed. *)
  val trimEnd: t -> string [@@js.call "trimEnd"]
  val to_ml: t -> string [@@js.cast]
  val of_ml: string -> t [@@js.cast]
end
module[@js.scope "ImportMeta"] ImportMeta : sig
  type t = _ImportMeta
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val get_url: t -> string [@@js.get "url"]
  val set_url: t -> string -> unit [@@js.set "url"]
end
module[@js.scope "NodeRequire"] NodeRequire : sig
  type t = _NodeRequire
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast: t -> _NodeJS_Require [@@js.cast]
end
module[@js.scope "RequireResolve"] RequireResolve : sig
  type t = _RequireResolve
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast: t -> _NodeJS_RequireResolve [@@js.cast]
end
module[@js.scope "NodeModule"] NodeModule : sig
  type t = _NodeModule
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  val cast: t -> _NodeJS_Module [@@js.cast]
end
val process: NodeJS.Process.t_0 [@@js.global "process"]
val console: Console.t_0 [@@js.global "console"]
val __filename: string [@@js.global "__filename"]
val __dirname: string [@@js.global "__dirname"]
val setTimeout: callback:(args:(any list [@js.variadic]) -> unit) -> ?ms:float -> args:(any list [@js.variadic]) -> _NodeJS_Timeout [@@js.global "setTimeout"]
module[@js.scope "setTimeout"] SetTimeout : sig
  val __promisify__: ms:float -> unit Promise.t_1 [@@js.global "__promisify__"]
  val __promisify__: ms:float -> value:'T -> 'T Promise.t_1 [@@js.global "__promisify__"]
end
val clearTimeout: timeoutId:_NodeJS_Timeout -> unit [@@js.global "clearTimeout"]
val setInterval: callback:(args:(any list [@js.variadic]) -> unit) -> ?ms:float -> args:(any list [@js.variadic]) -> _NodeJS_Timeout [@@js.global "setInterval"]
val clearInterval: intervalId:_NodeJS_Timeout -> unit [@@js.global "clearInterval"]
val setImmediate: callback:(args:(any list [@js.variadic]) -> unit) -> args:(any list [@js.variadic]) -> _NodeJS_Immediate [@@js.global "setImmediate"]
module[@js.scope "setImmediate"] SetImmediate : sig
  val __promisify__: unit -> unit Promise.t_1 [@@js.global "__promisify__"]
  val __promisify__: value:'T -> 'T Promise.t_1 [@@js.global "__promisify__"]
end
val clearImmediate: immediateId:_NodeJS_Immediate -> unit [@@js.global "clearImmediate"]
val queueMicrotask: callback:(unit -> unit) -> unit [@@js.global "queueMicrotask"]
val require: _NodeRequire [@@js.global "require"]
val module_: _NodeModule [@@js.global "module"]
val exports: any [@@js.global "exports"]
module BufferEncoding : sig
  type t = _BufferEncoding
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
end
module WithImplicitCoercion : sig
  type 'T t = 'T _WithImplicitCoercion
  val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
  val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
  type 'T t_1 = 'T t
  val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
  val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
end
(**
  Raw data is stored in instances of the Buffer class.
  A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
  Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
*)
module[@js.scope "Buffer"] Buffer : sig
  type t = _Buffer
  val t_to_js: t -> Ojs.t
  val t_of_js: Ojs.t -> t
  type t_0 = t
  val t_0_to_js: t_0 -> Ojs.t
  val t_0_of_js: Ojs.t -> t_0
  (**
    Allocates a new buffer containing the given \{str\}.
    @param str String to store in buffer.
    @param encoding encoding to use, optional.  Default is 'utf8'
    @deprecated since v10.0.0 - Use `Buffer.from(string\[, encoding\])` instead.
  *)
  val create: str:string -> ?encoding:_BufferEncoding -> unit -> t [@@js.create]
  (**
    Allocates a new buffer of \{size\} octets.
    @param size count of octets to allocate.
    @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).
  *)
  val create': size:float -> t [@@js.create]
  (**
    Allocates a new buffer containing the given \{array\} of octets.
    @param array The octets to store.
    @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
  *)
  val create'': array:Uint8Array.t_0 -> t [@@js.create]
  (**
    Produces a Buffer backed by the same allocated memory as
    the given \{ArrayBuffer\}/\{SharedArrayBuffer\}.
    @param arrayBuffer The ArrayBuffer with which to share memory.
    @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer\[, byteOffset\[, length\]\])` instead.
  *)
  val create''': arrayBuffer:(ArrayBuffer.t_0, SharedArrayBuffer.t_0) union2 -> t [@@js.create]
  (**
    Allocates a new buffer containing the given \{array\} of octets.
    @param array The octets to store.
    @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
  *)
  val create'''': array:any list -> t [@@js.create]
  (**
    Copies the passed \{buffer\} data onto a new \{Buffer\} instance.
    @param buffer The buffer to copy.
    @deprecated since v10.0.0 - Use `Buffer.from(buffer)` instead.
  *)
  val create''''': buffer:t -> t [@@js.create]
  (**
    When passed a reference to the .buffer property of a TypedArray instance,
    the newly created Buffer will share the same allocated memory as the TypedArray.
    The optional \{byteOffset\} and \{length\} arguments specify a memory range
    within the \{arrayBuffer\} that will be shared by the Buffer.
    @param arrayBuffer The .buffer property of any TypedArray or a new ArrayBuffer()
  *)
  val from: arrayBuffer:(ArrayBuffer.t_0, SharedArrayBuffer.t_0) union2 _WithImplicitCoercion -> ?byteOffset:float -> ?length:float -> unit -> t [@@js.global "from"]
  (**
    Creates a new Buffer using the passed \{data\}
    @param data data to create a new Buffer
  *)
  val from': data:(Uint8Array.t_0, float list) union2 -> t [@@js.global "from"]
  (**
    When passed a reference to the .buffer property of a TypedArray instance,
    the newly created Buffer will share the same allocated memory as the TypedArray.
    The optional \{byteOffset\} and \{length\} arguments specify a memory range
    within the \{arrayBuffer\} that will be shared by the Buffer.
    
    
    Creates a new Buffer using the passed \{data\}
    
    
    Creates a new Buffer containing the given JavaScript string \{str\}.
    If provided, the \{encoding\} parameter identifies the character encoding.
    If not provided, \{encoding\} defaults to 'utf8'.
  *)
  val from'': data:(Uint8Array.t_0, float list) union2 or_string _WithImplicitCoercion -> t [@@js.global "from"]
  (**
    Creates a new Buffer containing the given JavaScript string \{str\}.
    If provided, the \{encoding\} parameter identifies the character encoding.
    If not provided, \{encoding\} defaults to 'utf8'.
  *)
  val from''': str:(anonymous_interface_64, string _WithImplicitCoercion) union2 -> ?encoding:_BufferEncoding -> unit -> t [@@js.global "from"]
  (**
    Creates a new Buffer using the passed \{data\}
    @param values to create a new Buffer
  *)
  val of_: items:(float list [@js.variadic]) -> t [@@js.global "of"]
  (**
    Returns true if \{obj\} is a Buffer
    @param obj object to test.
  *)
  val isBuffer: obj:any -> bool [@@js.global "isBuffer"]
  (**
    Returns true if \{encoding\} is a valid encoding argument.
    Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'
    @param encoding string to test.
  *)
  val isEncoding: encoding:string -> bool [@@js.global "isEncoding"]
  (**
    Gives the actual byte length of a string. encoding defaults to 'utf8'.
    This is not the same as String.prototype.length since that returns the number of characters in a string.
    @param string string to test.
    @param encoding encoding used to evaluate (defaults to 'utf8')
  *)
  val byteLength: string:(ArrayBuffer.t_0, _NodeJS_ArrayBufferView, SharedArrayBuffer.t_0) union3 or_string -> ?encoding:_BufferEncoding -> unit -> float [@@js.global "byteLength"]
  (**
    Returns a buffer which is the result of concatenating all the buffers in the list together.
    
    If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.
    If the list has exactly one item, then the first item of the list is returned.
    If the list has more than one item, then a new Buffer is created.
    @param list An array of Buffer objects to concatenate
    @param totalLength Total length of the buffers when concatenated.
    If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.
  *)
  val concat: list:Uint8Array.t_0 list -> ?totalLength:float -> unit -> t [@@js.global "concat"]
  (** The same as buf1.compare(buf2). *)
  val compare: buf1:Uint8Array.t_0 -> buf2:Uint8Array.t_0 -> float [@@js.global "compare"]
  (**
    Allocates a new buffer of \{size\} octets.
    @param size count of octets to allocate.
    @param fill if specified, buffer will be initialized by calling buf.fill(fill).
    If parameter is omitted, buffer will be filled with zeros.
    @param encoding encoding used for call to buf.fill while initalizing
  *)
  val alloc: size:float -> ?fill:t or_string or_number -> ?encoding:_BufferEncoding -> unit -> t [@@js.global "alloc"]
  (**
    Allocates a new buffer of \{size\} octets, leaving memory not initialized, so the contents
    of the newly created Buffer are unknown and may contain sensitive data.
    @param size count of octets to allocate
  *)
  val allocUnsafe: size:float -> t [@@js.global "allocUnsafe"]
  (**
    Allocates a new non-pooled buffer of \{size\} octets, leaving memory not initialized, so the contents
    of the newly created Buffer are unknown and may contain sensitive data.
    @param size count of octets to allocate
  *)
  val allocUnsafeSlow: size:float -> t [@@js.global "allocUnsafeSlow"]
  (** This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified. *)
  (** This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified. *)
  val get_poolSize: unit -> float [@@js.get "poolSize"]
  (** This is the number of bytes used to determine the size of pre-allocated, internal Buffer instances used for pooling. This value may be modified. *)
  val set_poolSize: float -> unit [@@js.set "poolSize"]
  val write: t -> string:string -> ?encoding:_BufferEncoding -> unit -> float [@@js.call "write"]
  val write': t -> string:string -> offset:float -> ?encoding:_BufferEncoding -> unit -> float [@@js.call "write"]
  val write'': t -> string:string -> offset:float -> length:float -> ?encoding:_BufferEncoding -> unit -> float [@@js.call "write"]
  val toString: t -> ?encoding:_BufferEncoding -> ?start:float -> ?end_:float -> unit -> string [@@js.call "toString"]
  val toJSON: t -> anonymous_interface_55 [@@js.call "toJSON"]
  val equals: t -> otherBuffer:Uint8Array.t_0 -> bool [@@js.call "equals"]
  val compare': t -> otherBuffer:Uint8Array.t_0 -> ?targetStart:float -> ?targetEnd:float -> ?sourceStart:float -> ?sourceEnd:float -> unit -> float [@@js.call "compare"]
  val copy: t -> targetBuffer:Uint8Array.t_0 -> ?targetStart:float -> ?sourceStart:float -> ?sourceEnd:float -> unit -> float [@@js.call "copy"]
  (**
    Returns a new `Buffer` that references **the same memory as the original**, but offset and cropped by the start and end indices.
    
    This method is incompatible with `Uint8Array#slice()`, which returns a copy of the original memory.
    @param begin Where the new `Buffer` will start. Default: `0`.
    @param end Where the new `Buffer` will end (not inclusive). Default: `buf.length`.
  *)
  val slice: t -> ?begin_:float -> ?end_:float -> unit -> t [@@js.call "slice"]
  (**
    Returns a new `Buffer` that references **the same memory as the original**, but offset and cropped by the start and end indices.
    
    This method is compatible with `Uint8Array#subarray()`.
    @param begin Where the new `Buffer` will start. Default: `0`.
    @param end Where the new `Buffer` will end (not inclusive). Default: `buf.length`.
  *)
  val subarray: t -> ?begin_:float -> ?end_:float -> unit -> t [@@js.call "subarray"]
  val writeBigInt64BE: t -> value:bigint -> ?offset:float -> unit -> float [@@js.call "writeBigInt64BE"]
  val writeBigInt64LE: t -> value:bigint -> ?offset:float -> unit -> float [@@js.call "writeBigInt64LE"]
  val writeBigUInt64BE: t -> value:bigint -> ?offset:float -> unit -> float [@@js.call "writeBigUInt64BE"]
  val writeBigUInt64LE: t -> value:bigint -> ?offset:float -> unit -> float [@@js.call "writeBigUInt64LE"]
  val writeUIntLE: t -> value:float -> offset:float -> byteLength:float -> float [@@js.call "writeUIntLE"]
  val writeUIntBE: t -> value:float -> offset:float -> byteLength:float -> float [@@js.call "writeUIntBE"]
  val writeIntLE: t -> value:float -> offset:float -> byteLength:float -> float [@@js.call "writeIntLE"]
  val writeIntBE: t -> value:float -> offset:float -> byteLength:float -> float [@@js.call "writeIntBE"]
  val readBigUInt64BE: t -> ?offset:float -> unit -> bigint [@@js.call "readBigUInt64BE"]
  val readBigUInt64LE: t -> ?offset:float -> unit -> bigint [@@js.call "readBigUInt64LE"]
  val readBigInt64BE: t -> ?offset:float -> unit -> bigint [@@js.call "readBigInt64BE"]
  val readBigInt64LE: t -> ?offset:float -> unit -> bigint [@@js.call "readBigInt64LE"]
  val readUIntLE: t -> offset:float -> byteLength:float -> float [@@js.call "readUIntLE"]
  val readUIntBE: t -> offset:float -> byteLength:float -> float [@@js.call "readUIntBE"]
  val readIntLE: t -> offset:float -> byteLength:float -> float [@@js.call "readIntLE"]
  val readIntBE: t -> offset:float -> byteLength:float -> float [@@js.call "readIntBE"]
  val readUInt8: t -> ?offset:float -> unit -> float [@@js.call "readUInt8"]
  val readUInt16LE: t -> ?offset:float -> unit -> float [@@js.call "readUInt16LE"]
  val readUInt16BE: t -> ?offset:float -> unit -> float [@@js.call "readUInt16BE"]
  val readUInt32LE: t -> ?offset:float -> unit -> float [@@js.call "readUInt32LE"]
  val readUInt32BE: t -> ?offset:float -> unit -> float [@@js.call "readUInt32BE"]
  val readInt8: t -> ?offset:float -> unit -> float [@@js.call "readInt8"]
  val readInt16LE: t -> ?offset:float -> unit -> float [@@js.call "readInt16LE"]
  val readInt16BE: t -> ?offset:float -> unit -> float [@@js.call "readInt16BE"]
  val readInt32LE: t -> ?offset:float -> unit -> float [@@js.call "readInt32LE"]
  val readInt32BE: t -> ?offset:float -> unit -> float [@@js.call "readInt32BE"]
  val readFloatLE: t -> ?offset:float -> unit -> float [@@js.call "readFloatLE"]
  val readFloatBE: t -> ?offset:float -> unit -> float [@@js.call "readFloatBE"]
  val readDoubleLE: t -> ?offset:float -> unit -> float [@@js.call "readDoubleLE"]
  val readDoubleBE: t -> ?offset:float -> unit -> float [@@js.call "readDoubleBE"]
  val reverse: t -> t [@@js.call "reverse"]
  val swap16: t -> t [@@js.call "swap16"]
  val swap32: t -> t [@@js.call "swap32"]
  val swap64: t -> t [@@js.call "swap64"]
  val writeUInt8: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeUInt8"]
  val writeUInt16LE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeUInt16LE"]
  val writeUInt16BE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeUInt16BE"]
  val writeUInt32LE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeUInt32LE"]
  val writeUInt32BE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeUInt32BE"]
  val writeInt8: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeInt8"]
  val writeInt16LE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeInt16LE"]
  val writeInt16BE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeInt16BE"]
  val writeInt32LE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeInt32LE"]
  val writeInt32BE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeInt32BE"]
  val writeFloatLE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeFloatLE"]
  val writeFloatBE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeFloatBE"]
  val writeDoubleLE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeDoubleLE"]
  val writeDoubleBE: t -> value:float -> ?offset:float -> unit -> float [@@js.call "writeDoubleBE"]
  val fill: t -> value:Uint8Array.t_0 or_string or_number -> ?offset:float -> ?end_:float -> ?encoding:_BufferEncoding -> unit -> t [@@js.call "fill"]
  val indexOf: t -> value:Uint8Array.t_0 or_string or_number -> ?byteOffset:float -> ?encoding:_BufferEncoding -> unit -> float [@@js.call "indexOf"]
  val lastIndexOf: t -> value:Uint8Array.t_0 or_string or_number -> ?byteOffset:float -> ?encoding:_BufferEncoding -> unit -> float [@@js.call "lastIndexOf"]
  val entries: t -> (float * float) IterableIterator.t_1 [@@js.call "entries"]
  val includes: t -> value:t or_string or_number -> ?byteOffset:float -> ?encoding:_BufferEncoding -> unit -> bool [@@js.call "includes"]
  val keys: t -> float IterableIterator.t_1 [@@js.call "keys"]
  val values: t -> float IterableIterator.t_1 [@@js.call "values"]
  val cast: t -> Uint8Array.t_0 [@@js.cast]
end
module[@js.scope "NodeJS"] NodeJS : sig
  module[@js.scope "InspectOptions"] InspectOptions : sig
    type t = _NodeJS_InspectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      If set to `true`, getters are going to be
      inspected as well. If set to `'get'` only getters without setter are going
      to be inspected. If set to `'set'` only getters having a corresponding
      setter are going to be inspected. This might cause side effects depending on
      the getter function.
      default: `false`
    *)
    (**
      If set to `true`, getters are going to be
      inspected as well. If set to `'get'` only getters without setter are going
      to be inspected. If set to `'set'` only getters having a corresponding
      setter are going to be inspected. This might cause side effects depending on
      the getter function.
      default: `false`
    *)
    val get_getters: t -> ([`L_s223_get[@js "get"] | `L_s299_set[@js "set"]] [@js.enum]) or_boolean [@@js.get "getters"]
    (**
      If set to `true`, getters are going to be
      inspected as well. If set to `'get'` only getters without setter are going
      to be inspected. If set to `'set'` only getters having a corresponding
      setter are going to be inspected. This might cause side effects depending on
      the getter function.
      default: `false`
    *)
    val set_getters: t -> ([`L_s223_get | `L_s299_set] [@js.enum]) or_boolean -> unit [@@js.set "getters"]
    val get_showHidden: t -> bool [@@js.get "showHidden"]
    val set_showHidden: t -> bool -> unit [@@js.set "showHidden"]
    (** default: 2 *)
    (** default: 2 *)
    val get_depth: t -> float or_null [@@js.get "depth"]
    (** default: 2 *)
    val set_depth: t -> float or_null -> unit [@@js.set "depth"]
    val get_colors: t -> bool [@@js.get "colors"]
    val set_colors: t -> bool -> unit [@@js.set "colors"]
    val get_customInspect: t -> bool [@@js.get "customInspect"]
    val set_customInspect: t -> bool -> unit [@@js.set "customInspect"]
    val get_showProxy: t -> bool [@@js.get "showProxy"]
    val set_showProxy: t -> bool -> unit [@@js.set "showProxy"]
    val get_maxArrayLength: t -> float or_null [@@js.get "maxArrayLength"]
    val set_maxArrayLength: t -> float or_null -> unit [@@js.set "maxArrayLength"]
    (**
      Specifies the maximum number of characters to
      include when formatting. Set to `null` or `Infinity` to show all elements.
      Set to `0` or negative to show no characters.
      default: Infinity
    *)
    (**
      Specifies the maximum number of characters to
      include when formatting. Set to `null` or `Infinity` to show all elements.
      Set to `0` or negative to show no characters.
      default: Infinity
    *)
    val get_maxStringLength: t -> float or_null [@@js.get "maxStringLength"]
    (**
      Specifies the maximum number of characters to
      include when formatting. Set to `null` or `Infinity` to show all elements.
      Set to `0` or negative to show no characters.
      default: Infinity
    *)
    val set_maxStringLength: t -> float or_null -> unit [@@js.set "maxStringLength"]
    val get_breakLength: t -> float [@@js.get "breakLength"]
    val set_breakLength: t -> float -> unit [@@js.set "breakLength"]
    (**
      Setting this to `false` causes each object key
      to be displayed on a new line. It will also add new lines to text that is
      longer than `breakLength`. If set to a number, the most `n` inner elements
      are united on a single line as long as all properties fit into
      `breakLength`. Short array elements are also grouped together. Note that no
      text will be reduced below 16 characters, no matter the `breakLength` size.
      For more information, see the example below.
      default: `true`
    *)
    (**
      Setting this to `false` causes each object key
      to be displayed on a new line. It will also add new lines to text that is
      longer than `breakLength`. If set to a number, the most `n` inner elements
      are united on a single line as long as all properties fit into
      `breakLength`. Short array elements are also grouped together. Note that no
      text will be reduced below 16 characters, no matter the `breakLength` size.
      For more information, see the example below.
      default: `true`
    *)
    val get_compact: t -> bool or_number [@@js.get "compact"]
    (**
      Setting this to `false` causes each object key
      to be displayed on a new line. It will also add new lines to text that is
      longer than `breakLength`. If set to a number, the most `n` inner elements
      are united on a single line as long as all properties fit into
      `breakLength`. Short array elements are also grouped together. Note that no
      text will be reduced below 16 characters, no matter the `breakLength` size.
      For more information, see the example below.
      default: `true`
    *)
    val set_compact: t -> bool or_number -> unit [@@js.set "compact"]
    val get_sorted: t -> (a:string -> b:string -> float) or_boolean [@@js.get "sorted"]
    val set_sorted: t -> (a:string -> b:string -> float) or_boolean -> unit [@@js.set "sorted"]
  end
  module[@js.scope "CallSite"] CallSite : sig
    type t = _NodeJS_CallSite
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Value of "this" *)
    val getThis: t -> any [@@js.call "getThis"]
    (**
      Type of "this" as a string.
      This is the name of the function stored in the constructor field of
      "this", if available.  Otherwise the object's \[\[Class\]\] internal
      property.
    *)
    val getTypeName: t -> string or_null [@@js.call "getTypeName"]
    (** Current function *)
    val getFunction: t -> untyped_function or_undefined [@@js.call "getFunction"]
    (**
      Name of the current function, typically its name property.
      If a name property is not available an attempt will be made to try
      to infer a name from the function's context.
    *)
    val getFunctionName: t -> string or_null [@@js.call "getFunctionName"]
    (**
      Name of the property \[of "this" or one of its prototypes\] that holds
      the current function
    *)
    val getMethodName: t -> string or_null [@@js.call "getMethodName"]
    (** Name of the script \[if this function was defined in a script\] *)
    val getFileName: t -> string or_null [@@js.call "getFileName"]
    (** Current line number \[if this function was defined in a script\] *)
    val getLineNumber: t -> float or_null [@@js.call "getLineNumber"]
    (** Current column number \[if this function was defined in a script\] *)
    val getColumnNumber: t -> float or_null [@@js.call "getColumnNumber"]
    (**
      A call site object representing the location where eval was called
      \[if this function was created using a call to eval\]
    *)
    val getEvalOrigin: t -> string or_undefined [@@js.call "getEvalOrigin"]
    (** Is this a toplevel invocation, that is, is "this" the global object? *)
    val isToplevel: t -> bool [@@js.call "isToplevel"]
    (** Does this call take place in code defined by a call to eval? *)
    val isEval: t -> bool [@@js.call "isEval"]
    (** Is this call in native V8 code? *)
    val isNative: t -> bool [@@js.call "isNative"]
    (** Is this a constructor call? *)
    val isConstructor: t -> bool [@@js.call "isConstructor"]
  end
  module[@js.scope "ErrnoException"] ErrnoException : sig
    type t = _NodeJS_ErrnoException
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_errno: t -> float [@@js.get "errno"]
    val set_errno: t -> float -> unit [@@js.set "errno"]
    val get_code: t -> string [@@js.get "code"]
    val set_code: t -> string -> unit [@@js.set "code"]
    val get_path: t -> string [@@js.get "path"]
    val set_path: t -> string -> unit [@@js.set "path"]
    val get_syscall: t -> string [@@js.get "syscall"]
    val set_syscall: t -> string -> unit [@@js.set "syscall"]
    val get_stack: t -> string [@@js.get "stack"]
    val set_stack: t -> string -> unit [@@js.set "stack"]
    val cast: t -> Error.t_0 [@@js.cast]
  end
  module[@js.scope "ReadableStream"] ReadableStream : sig
    type t = _NodeJS_ReadableStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_readable: t -> bool [@@js.get "readable"]
    val set_readable: t -> bool -> unit [@@js.set "readable"]
    val read: t -> ?size:float -> unit -> _Buffer or_string [@@js.call "read"]
    val setEncoding: t -> encoding:_BufferEncoding -> t [@@js.call "setEncoding"]
    val pause: t -> t [@@js.call "pause"]
    val resume: t -> t [@@js.call "resume"]
    val isPaused: t -> bool [@@js.call "isPaused"]
    val pipe: t -> destination:'T -> ?options:anonymous_interface_20 -> unit -> 'T [@@js.call "pipe"]
    val unpipe: t -> ?destination:_NodeJS_WritableStream -> unit -> t [@@js.call "unpipe"]
    val unshift: t -> chunk:Uint8Array.t_0 or_string -> ?encoding:_BufferEncoding -> unit -> unit [@@js.call "unshift"]
    val wrap: t -> oldStream:t -> t [@@js.call "wrap"]
    val _Symbol_asyncIterator_: t -> _Buffer or_string AsyncIterableIterator.t_1 [@@js.call "[Symbol.asyncIterator]"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "WritableStream"] WritableStream : sig
    type t = _NodeJS_WritableStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_writable: t -> bool [@@js.get "writable"]
    val set_writable: t -> bool -> unit [@@js.set "writable"]
    val write: t -> buffer:Uint8Array.t_0 or_string -> ?cb:(?err:Error.t_0 or_null -> unit -> unit) -> unit -> bool [@@js.call "write"]
    val write': t -> str:string -> ?encoding:_BufferEncoding -> ?cb:(?err:Error.t_0 or_null -> unit -> unit) -> unit -> bool [@@js.call "write"]
    val end_: t -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val end_': t -> data:Uint8Array.t_0 or_string -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val end_'': t -> str:string -> ?encoding:_BufferEncoding -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "ReadWriteStream"] ReadWriteStream : sig
    type t = _NodeJS_ReadWriteStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> _NodeJS_ReadableStream [@@js.cast]
    val cast': t -> _NodeJS_WritableStream [@@js.cast]
  end
  module[@js.scope "Global"] Global : sig
    type t = _NodeJS_Global
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_Array: t -> (* FIXME: unknown type 'typeof Array' *)any [@@js.get "Array"]
    val set_Array: t -> (* FIXME: unknown type 'typeof Array' *)any -> unit [@@js.set "Array"]
    val get_ArrayBuffer: t -> (* FIXME: unknown type 'typeof ArrayBuffer' *)any [@@js.get "ArrayBuffer"]
    val set_ArrayBuffer: t -> (* FIXME: unknown type 'typeof ArrayBuffer' *)any -> unit [@@js.set "ArrayBuffer"]
    val get_Boolean: t -> (* FIXME: unknown type 'typeof Boolean' *)any [@@js.get "Boolean"]
    val set_Boolean: t -> (* FIXME: unknown type 'typeof Boolean' *)any -> unit [@@js.set "Boolean"]
    val get_Buffer: t -> (* FIXME: unknown type 'typeof Buffer' *)any [@@js.get "Buffer"]
    val set_Buffer: t -> (* FIXME: unknown type 'typeof Buffer' *)any -> unit [@@js.set "Buffer"]
    val get_DataView: t -> (* FIXME: unknown type 'typeof DataView' *)any [@@js.get "DataView"]
    val set_DataView: t -> (* FIXME: unknown type 'typeof DataView' *)any -> unit [@@js.set "DataView"]
    val get_Date: t -> (* FIXME: unknown type 'typeof Date' *)any [@@js.get "Date"]
    val set_Date: t -> (* FIXME: unknown type 'typeof Date' *)any -> unit [@@js.set "Date"]
    val get_Error: t -> (* FIXME: unknown type 'typeof Error' *)any [@@js.get "Error"]
    val set_Error: t -> (* FIXME: unknown type 'typeof Error' *)any -> unit [@@js.set "Error"]
    val get_EvalError: t -> (* FIXME: unknown type 'typeof EvalError' *)any [@@js.get "EvalError"]
    val set_EvalError: t -> (* FIXME: unknown type 'typeof EvalError' *)any -> unit [@@js.set "EvalError"]
    val get_Float32Array: t -> (* FIXME: unknown type 'typeof Float32Array' *)any [@@js.get "Float32Array"]
    val set_Float32Array: t -> (* FIXME: unknown type 'typeof Float32Array' *)any -> unit [@@js.set "Float32Array"]
    val get_Float64Array: t -> (* FIXME: unknown type 'typeof Float64Array' *)any [@@js.get "Float64Array"]
    val set_Float64Array: t -> (* FIXME: unknown type 'typeof Float64Array' *)any -> unit [@@js.set "Float64Array"]
    val get_Function: t -> (* FIXME: unknown type 'typeof Function' *)any [@@js.get "Function"]
    val set_Function: t -> (* FIXME: unknown type 'typeof Function' *)any -> unit [@@js.set "Function"]
    val get_Infinity: t -> (* FIXME: unknown type 'typeof Infinity' *)any [@@js.get "Infinity"]
    val set_Infinity: t -> (* FIXME: unknown type 'typeof Infinity' *)any -> unit [@@js.set "Infinity"]
    val get_Int16Array: t -> (* FIXME: unknown type 'typeof Int16Array' *)any [@@js.get "Int16Array"]
    val set_Int16Array: t -> (* FIXME: unknown type 'typeof Int16Array' *)any -> unit [@@js.set "Int16Array"]
    val get_Int32Array: t -> (* FIXME: unknown type 'typeof Int32Array' *)any [@@js.get "Int32Array"]
    val set_Int32Array: t -> (* FIXME: unknown type 'typeof Int32Array' *)any -> unit [@@js.set "Int32Array"]
    val get_Int8Array: t -> (* FIXME: unknown type 'typeof Int8Array' *)any [@@js.get "Int8Array"]
    val set_Int8Array: t -> (* FIXME: unknown type 'typeof Int8Array' *)any -> unit [@@js.set "Int8Array"]
    val get_Intl: t -> (* FIXME: unknown type 'typeof Intl' *)any [@@js.get "Intl"]
    val set_Intl: t -> (* FIXME: unknown type 'typeof Intl' *)any -> unit [@@js.set "Intl"]
    val get_JSON: t -> (* FIXME: unknown type 'typeof JSON' *)any [@@js.get "JSON"]
    val set_JSON: t -> (* FIXME: unknown type 'typeof JSON' *)any -> unit [@@js.set "JSON"]
    val get_Map: t -> MapConstructor.t_0 [@@js.get "Map"]
    val set_Map: t -> MapConstructor.t_0 -> unit [@@js.set "Map"]
    val get_Math: t -> (* FIXME: unknown type 'typeof Math' *)any [@@js.get "Math"]
    val set_Math: t -> (* FIXME: unknown type 'typeof Math' *)any -> unit [@@js.set "Math"]
    val get_NaN: t -> (* FIXME: unknown type 'typeof NaN' *)any [@@js.get "NaN"]
    val set_NaN: t -> (* FIXME: unknown type 'typeof NaN' *)any -> unit [@@js.set "NaN"]
    val get_Number: t -> (* FIXME: unknown type 'typeof Number' *)any [@@js.get "Number"]
    val set_Number: t -> (* FIXME: unknown type 'typeof Number' *)any -> unit [@@js.set "Number"]
    val get_Object: t -> (* FIXME: unknown type 'typeof Object' *)any [@@js.get "Object"]
    val set_Object: t -> (* FIXME: unknown type 'typeof Object' *)any -> unit [@@js.set "Object"]
    val get_Promise: t -> (* FIXME: unknown type 'typeof Promise' *)any [@@js.get "Promise"]
    val set_Promise: t -> (* FIXME: unknown type 'typeof Promise' *)any -> unit [@@js.set "Promise"]
    val get_RangeError: t -> (* FIXME: unknown type 'typeof RangeError' *)any [@@js.get "RangeError"]
    val set_RangeError: t -> (* FIXME: unknown type 'typeof RangeError' *)any -> unit [@@js.set "RangeError"]
    val get_ReferenceError: t -> (* FIXME: unknown type 'typeof ReferenceError' *)any [@@js.get "ReferenceError"]
    val set_ReferenceError: t -> (* FIXME: unknown type 'typeof ReferenceError' *)any -> unit [@@js.set "ReferenceError"]
    val get_RegExp: t -> (* FIXME: unknown type 'typeof RegExp' *)any [@@js.get "RegExp"]
    val set_RegExp: t -> (* FIXME: unknown type 'typeof RegExp' *)any -> unit [@@js.set "RegExp"]
    val get_Set: t -> SetConstructor.t_0 [@@js.get "Set"]
    val set_Set: t -> SetConstructor.t_0 -> unit [@@js.set "Set"]
    val get_String: t -> (* FIXME: unknown type 'typeof String' *)any [@@js.get "String"]
    val set_String: t -> (* FIXME: unknown type 'typeof String' *)any -> unit [@@js.set "String"]
    val get_Symbol: t -> untyped_function [@@js.get "Symbol"]
    val set_Symbol: t -> untyped_function -> unit [@@js.set "Symbol"]
    val get_SyntaxError: t -> (* FIXME: unknown type 'typeof SyntaxError' *)any [@@js.get "SyntaxError"]
    val set_SyntaxError: t -> (* FIXME: unknown type 'typeof SyntaxError' *)any -> unit [@@js.set "SyntaxError"]
    val get_TypeError: t -> (* FIXME: unknown type 'typeof TypeError' *)any [@@js.get "TypeError"]
    val set_TypeError: t -> (* FIXME: unknown type 'typeof TypeError' *)any -> unit [@@js.set "TypeError"]
    val get_URIError: t -> (* FIXME: unknown type 'typeof URIError' *)any [@@js.get "URIError"]
    val set_URIError: t -> (* FIXME: unknown type 'typeof URIError' *)any -> unit [@@js.set "URIError"]
    val get_Uint16Array: t -> (* FIXME: unknown type 'typeof Uint16Array' *)any [@@js.get "Uint16Array"]
    val set_Uint16Array: t -> (* FIXME: unknown type 'typeof Uint16Array' *)any -> unit [@@js.set "Uint16Array"]
    val get_Uint32Array: t -> (* FIXME: unknown type 'typeof Uint32Array' *)any [@@js.get "Uint32Array"]
    val set_Uint32Array: t -> (* FIXME: unknown type 'typeof Uint32Array' *)any -> unit [@@js.set "Uint32Array"]
    val get_Uint8Array: t -> (* FIXME: unknown type 'typeof Uint8Array' *)any [@@js.get "Uint8Array"]
    val set_Uint8Array: t -> (* FIXME: unknown type 'typeof Uint8Array' *)any -> unit [@@js.set "Uint8Array"]
    val get_Uint8ClampedArray: t -> (* FIXME: unknown type 'typeof Uint8ClampedArray' *)any [@@js.get "Uint8ClampedArray"]
    val set_Uint8ClampedArray: t -> (* FIXME: unknown type 'typeof Uint8ClampedArray' *)any -> unit [@@js.set "Uint8ClampedArray"]
    val get_WeakMap: t -> WeakMapConstructor.t_0 [@@js.get "WeakMap"]
    val set_WeakMap: t -> WeakMapConstructor.t_0 -> unit [@@js.set "WeakMap"]
    val get_WeakSet: t -> WeakSetConstructor.t_0 [@@js.get "WeakSet"]
    val set_WeakSet: t -> WeakSetConstructor.t_0 -> unit [@@js.set "WeakSet"]
    val clearImmediate: t -> immediateId:_NodeJS_Immediate -> unit [@@js.call "clearImmediate"]
    val clearInterval: t -> intervalId:_NodeJS_Timeout -> unit [@@js.call "clearInterval"]
    val clearTimeout: t -> timeoutId:_NodeJS_Timeout -> unit [@@js.call "clearTimeout"]
    val get_decodeURI: t -> (* FIXME: unknown type 'typeof decodeURI' *)any [@@js.get "decodeURI"]
    val set_decodeURI: t -> (* FIXME: unknown type 'typeof decodeURI' *)any -> unit [@@js.set "decodeURI"]
    val get_decodeURIComponent: t -> (* FIXME: unknown type 'typeof decodeURIComponent' *)any [@@js.get "decodeURIComponent"]
    val set_decodeURIComponent: t -> (* FIXME: unknown type 'typeof decodeURIComponent' *)any -> unit [@@js.set "decodeURIComponent"]
    val get_encodeURI: t -> (* FIXME: unknown type 'typeof encodeURI' *)any [@@js.get "encodeURI"]
    val set_encodeURI: t -> (* FIXME: unknown type 'typeof encodeURI' *)any -> unit [@@js.set "encodeURI"]
    val get_encodeURIComponent: t -> (* FIXME: unknown type 'typeof encodeURIComponent' *)any [@@js.get "encodeURIComponent"]
    val set_encodeURIComponent: t -> (* FIXME: unknown type 'typeof encodeURIComponent' *)any -> unit [@@js.set "encodeURIComponent"]
    val escape: t -> str:string -> string [@@js.call "escape"]
    val get_eval: t -> (* FIXME: unknown type 'typeof eval' *)any [@@js.get "eval"]
    val set_eval: t -> (* FIXME: unknown type 'typeof eval' *)any -> unit [@@js.set "eval"]
    val get_global: t -> t [@@js.get "global"]
    val set_global: t -> t -> unit [@@js.set "global"]
    val get_isFinite: t -> (* FIXME: unknown type 'typeof isFinite' *)any [@@js.get "isFinite"]
    val set_isFinite: t -> (* FIXME: unknown type 'typeof isFinite' *)any -> unit [@@js.set "isFinite"]
    val get_isNaN: t -> (* FIXME: unknown type 'typeof isNaN' *)any [@@js.get "isNaN"]
    val set_isNaN: t -> (* FIXME: unknown type 'typeof isNaN' *)any -> unit [@@js.set "isNaN"]
    val get_parseFloat: t -> (* FIXME: unknown type 'typeof parseFloat' *)any [@@js.get "parseFloat"]
    val set_parseFloat: t -> (* FIXME: unknown type 'typeof parseFloat' *)any -> unit [@@js.set "parseFloat"]
    val get_parseInt: t -> (* FIXME: unknown type 'typeof parseInt' *)any [@@js.get "parseInt"]
    val set_parseInt: t -> (* FIXME: unknown type 'typeof parseInt' *)any -> unit [@@js.set "parseInt"]
    val setImmediate: t -> callback:(args:(any list [@js.variadic]) -> unit) -> args:(any list [@js.variadic]) -> _NodeJS_Immediate [@@js.call "setImmediate"]
    val setInterval: t -> callback:(args:(any list [@js.variadic]) -> unit) -> ?ms:float -> args:(any list [@js.variadic]) -> _NodeJS_Timeout [@@js.call "setInterval"]
    val setTimeout: t -> callback:(args:(any list [@js.variadic]) -> unit) -> ?ms:float -> args:(any list [@js.variadic]) -> _NodeJS_Timeout [@@js.call "setTimeout"]
    val queueMicrotask: t -> callback:(unit -> unit) -> unit [@@js.call "queueMicrotask"]
    val get_undefined: t -> (* FIXME: unknown type 'typeof undefined' *)any [@@js.get "undefined"]
    val set_undefined: t -> (* FIXME: unknown type 'typeof undefined' *)any -> unit [@@js.set "undefined"]
    val unescape: t -> str:string -> string [@@js.call "unescape"]
    val gc: t -> unit [@@js.call "gc"]
    val get_v8debug: t -> any [@@js.get "v8debug"]
    val set_v8debug: t -> any -> unit [@@js.set "v8debug"]
  end
  module[@js.scope "RefCounted"] RefCounted : sig
    type t = _NodeJS_RefCounted
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val ref: t -> t [@@js.call "ref"]
    val unref: t -> t [@@js.call "unref"]
  end
  module[@js.scope "Timer"] Timer : sig
    type t = _NodeJS_Timer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val hasRef: t -> bool [@@js.call "hasRef"]
    val refresh: t -> t [@@js.call "refresh"]
    val _Symbol_toPrimitive_: t -> float [@@js.call "[Symbol.toPrimitive]"]
    val cast: t -> _NodeJS_RefCounted [@@js.cast]
  end
  module[@js.scope "Immediate"] Immediate : sig
    type t = _NodeJS_Immediate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val hasRef: t -> bool [@@js.call "hasRef"]
    val get__onImmediate: t -> untyped_function [@@js.get "_onImmediate"]
    val set__onImmediate: t -> untyped_function -> unit [@@js.set "_onImmediate"]
    val cast: t -> _NodeJS_RefCounted [@@js.cast]
  end
  module[@js.scope "Timeout"] Timeout : sig
    type t = _NodeJS_Timeout
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val hasRef: t -> bool [@@js.call "hasRef"]
    val refresh: t -> t [@@js.call "refresh"]
    val _Symbol_toPrimitive_: t -> float [@@js.call "[Symbol.toPrimitive]"]
    val cast: t -> _NodeJS_Timer [@@js.cast]
  end
  module TypedArray : sig
    type t = _NodeJS_TypedArray
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module ArrayBufferView : sig
    type t = _NodeJS_ArrayBufferView
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "Require"] Require : sig
    type t = _NodeJS_Require
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> id:string -> any [@@js.apply]
    val get_resolve: t -> _NodeJS_RequireResolve [@@js.get "resolve"]
    val set_resolve: t -> _NodeJS_RequireResolve -> unit [@@js.set "resolve"]
    val get_cache: t -> _NodeModule _NodeJS_Dict [@@js.get "cache"]
    val set_cache: t -> _NodeModule _NodeJS_Dict -> unit [@@js.set "cache"]
    (** @deprecated  *)
    (** @deprecated  *)
    val get_extensions: t -> _NodeJS_RequireExtensions [@@js.get "extensions"]
    (** @deprecated  *)
    val set_extensions: t -> _NodeJS_RequireExtensions -> unit [@@js.set "extensions"]
    val get_main: t -> _NodeJS_Module or_undefined [@@js.get "main"]
    val set_main: t -> _NodeJS_Module or_undefined -> unit [@@js.set "main"]
  end
  module[@js.scope "RequireResolve"] RequireResolve : sig
    type t = _NodeJS_RequireResolve
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> id:string -> ?options:anonymous_interface_37 -> unit -> string [@@js.apply]
    val paths: t -> request:string -> string list or_null [@@js.call "paths"]
  end
  module[@js.scope "RequireExtensions"] RequireExtensions : sig
    type t = _NodeJS_RequireExtensions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val _js: t -> m:_NodeJS_Module -> filename:string -> any [@@js.call ".js"]
    val _json: t -> m:_NodeJS_Module -> filename:string -> any [@@js.call ".json"]
    val _node: t -> m:_NodeJS_Module -> filename:string -> any [@@js.call ".node"]
    val cast: t -> (m:_NodeJS_Module -> filename:string -> any) _NodeJS_Dict [@@js.cast]
  end
  module[@js.scope "Module"] Module : sig
    type t = _NodeJS_Module
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_exports: t -> any [@@js.get "exports"]
    val set_exports: t -> any -> unit [@@js.set "exports"]
    val get_require: t -> _NodeJS_Require [@@js.get "require"]
    val set_require: t -> _NodeJS_Require -> unit [@@js.set "require"]
    val get_id: t -> string [@@js.get "id"]
    val set_id: t -> string -> unit [@@js.set "id"]
    val get_filename: t -> string [@@js.get "filename"]
    val set_filename: t -> string -> unit [@@js.set "filename"]
    val get_loaded: t -> bool [@@js.get "loaded"]
    val set_loaded: t -> bool -> unit [@@js.set "loaded"]
    (** @deprecated since 14.6.0 Please use `require.main` and `module.children` instead. *)
    (** @deprecated since 14.6.0 Please use `require.main` and `module.children` instead. *)
    val get_parent: t -> t or_null_or_undefined [@@js.get "parent"]
    (** @deprecated since 14.6.0 Please use `require.main` and `module.children` instead. *)
    val set_parent: t -> t or_null_or_undefined -> unit [@@js.set "parent"]
    val get_children: t -> t list [@@js.get "children"]
    val set_children: t -> t list -> unit [@@js.set "children"]
    (**
      @since 11.14.0
      
      The directory name of the module. This is usually the same as the path.dirname() of the module.id.
    *)
    (**
      @since 11.14.0
      
      The directory name of the module. This is usually the same as the path.dirname() of the module.id.
    *)
    val get_path: t -> string [@@js.get "path"]
    (**
      @since 11.14.0
      
      The directory name of the module. This is usually the same as the path.dirname() of the module.id.
    *)
    val set_path: t -> string -> unit [@@js.set "path"]
    val get_paths: t -> string list [@@js.get "paths"]
    val set_paths: t -> string list -> unit [@@js.set "paths"]
  end
  module[@js.scope "Dict"] Dict : sig
    type 'T t = 'T _NodeJS_Dict
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get: 'T t -> string -> 'T or_undefined [@@js.index_get]
    val set: 'T t -> string -> 'T or_undefined -> unit [@@js.index_set]
  end
  module[@js.scope "ReadOnlyDict"] ReadOnlyDict : sig
    type 'T t = 'T _NodeJS_ReadOnlyDict
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get: 'T t -> string -> 'T or_undefined [@@js.index_get]
  end
end
val global: (_NodeJS_Global, (* FIXME: unknown type 'typeof globalThis' *)any) intersection2 [@@js.global "global"]
module Node_http2 : sig
  (* export * from 'http2'; *)
end
module[@js.scope "http2"] Http2 : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:fs
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = NamespaceImport ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = NamespaceImport ([object Object])
    loc = line 9, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:tls
    clause = NamespaceImport ([object Object])
    loc = line 10, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:url
    clause = NamespaceImport ([object Object])
    loc = line 11, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:http
    clause = ES6Import ([object Object])
    loc = line 13, col 5 of node_modules/@types/node/http2.d.ts } *)
  (* export { OutgoingHttpHeaders } from 'node:http'; *)
  module[@js.scope "IncomingHttpStatusHeader"] IncomingHttpStatusHeader : sig
    type t = http2_IncomingHttpStatusHeader
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get__status: t -> float [@@js.get ":status"]
    val set__status: t -> float -> unit [@@js.set ":status"]
  end
  module[@js.scope "IncomingHttpHeaders"] IncomingHttpHeaders : sig
    type t = http2_IncomingHttpHeaders
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get__path: t -> string [@@js.get ":path"]
    val set__path: t -> string -> unit [@@js.set ":path"]
    val get__method: t -> string [@@js.get ":method"]
    val set__method: t -> string -> unit [@@js.set ":method"]
    val get__authority: t -> string [@@js.get ":authority"]
    val set__authority: t -> string -> unit [@@js.set ":authority"]
    val get__scheme: t -> string [@@js.get ":scheme"]
    val set__scheme: t -> string -> unit [@@js.set ":scheme"]
    val cast: t -> Http1IncomingHttpHeaders.t_0 [@@js.cast]
  end
  module[@js.scope "StreamPriorityOptions"] StreamPriorityOptions : sig
    type t = http2_StreamPriorityOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_exclusive: t -> bool [@@js.get "exclusive"]
    val set_exclusive: t -> bool -> unit [@@js.set "exclusive"]
    val get_parent: t -> float [@@js.get "parent"]
    val set_parent: t -> float -> unit [@@js.set "parent"]
    val get_weight: t -> float [@@js.get "weight"]
    val set_weight: t -> float -> unit [@@js.set "weight"]
    val get_silent: t -> bool [@@js.get "silent"]
    val set_silent: t -> bool -> unit [@@js.set "silent"]
  end
  module[@js.scope "StreamState"] StreamState : sig
    type t = http2_StreamState
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_localWindowSize: t -> float [@@js.get "localWindowSize"]
    val set_localWindowSize: t -> float -> unit [@@js.set "localWindowSize"]
    val get_state: t -> float [@@js.get "state"]
    val set_state: t -> float -> unit [@@js.set "state"]
    val get_localClose: t -> float [@@js.get "localClose"]
    val set_localClose: t -> float -> unit [@@js.set "localClose"]
    val get_remoteClose: t -> float [@@js.get "remoteClose"]
    val set_remoteClose: t -> float -> unit [@@js.set "remoteClose"]
    val get_sumDependencyWeight: t -> float [@@js.get "sumDependencyWeight"]
    val set_sumDependencyWeight: t -> float -> unit [@@js.set "sumDependencyWeight"]
    val get_weight: t -> float [@@js.get "weight"]
    val set_weight: t -> float -> unit [@@js.set "weight"]
  end
  module[@js.scope "ServerStreamResponseOptions"] ServerStreamResponseOptions : sig
    type t = http2_ServerStreamResponseOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_endStream: t -> bool [@@js.get "endStream"]
    val set_endStream: t -> bool -> unit [@@js.set "endStream"]
    val get_waitForTrailers: t -> bool [@@js.get "waitForTrailers"]
    val set_waitForTrailers: t -> bool -> unit [@@js.set "waitForTrailers"]
  end
  module[@js.scope "StatOptions"] StatOptions : sig
    type t = http2_StatOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_offset: t -> float [@@js.get "offset"]
    val set_offset: t -> float -> unit [@@js.set "offset"]
    val get_length: t -> float [@@js.get "length"]
    val set_length: t -> float -> unit [@@js.set "length"]
  end
  module[@js.scope "ServerStreamFileResponseOptions"] ServerStreamFileResponseOptions : sig
    type t = http2_ServerStreamFileResponseOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val statCheck: t -> stats:fs_Stats -> headers:OutgoingHttpHeaders.t_0 -> statOptions:http2_StatOptions -> unit or_boolean [@@js.call "statCheck"]
    val get_waitForTrailers: t -> bool [@@js.get "waitForTrailers"]
    val set_waitForTrailers: t -> bool -> unit [@@js.set "waitForTrailers"]
    val get_offset: t -> float [@@js.get "offset"]
    val set_offset: t -> float -> unit [@@js.set "offset"]
    val get_length: t -> float [@@js.get "length"]
    val set_length: t -> float -> unit [@@js.set "length"]
  end
  module[@js.scope "ServerStreamFileResponseOptionsWithError"] ServerStreamFileResponseOptionsWithError : sig
    type t = http2_ServerStreamFileResponseOptionsWithError
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val onError: t -> err:_NodeJS_ErrnoException -> unit [@@js.call "onError"]
    val cast: t -> http2_ServerStreamFileResponseOptions [@@js.cast]
  end
  module[@js.scope "Http2Stream"] Http2Stream : sig
    type t = http2_Http2Stream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_aborted: t -> bool [@@js.get "aborted"]
    val get_bufferSize: t -> float [@@js.get "bufferSize"]
    val get_closed: t -> bool [@@js.get "closed"]
    val get_destroyed: t -> bool [@@js.get "destroyed"]
    (**
      Set the true if the END_STREAM flag was set in the request or response HEADERS frame received,
      indicating that no additional data should be received and the readable side of the Http2Stream will be closed.
    *)
    val get_endAfterHeaders: t -> bool [@@js.get "endAfterHeaders"]
    val get_id: t -> float [@@js.get "id"]
    val get_pending: t -> bool [@@js.get "pending"]
    val get_rstCode: t -> float [@@js.get "rstCode"]
    val get_sentHeaders: t -> OutgoingHttpHeaders.t_0 [@@js.get "sentHeaders"]
    val get_sentInfoHeaders: t -> OutgoingHttpHeaders.t_0 list [@@js.get "sentInfoHeaders"]
    val get_sentTrailers: t -> OutgoingHttpHeaders.t_0 [@@js.get "sentTrailers"]
    val get_session: t -> http2_Http2Session [@@js.get "session"]
    val get_state: t -> http2_StreamState [@@js.get "state"]
    val close: t -> ?code:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "close"]
    val priority: t -> options:http2_StreamPriorityOptions -> unit [@@js.call "priority"]
    val setTimeout: t -> msecs:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "setTimeout"]
    val sendTrailers: t -> headers:OutgoingHttpHeaders.t_0 -> unit [@@js.call "sendTrailers"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''''''': t -> event:([`L_s305_streamClosed] [@js.enum]) -> listener:(code:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''''''''': t -> event:([`L_s314_trailers] [@js.enum]) -> listener:(trailers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''''''''': t -> event:([`L_s330_wantTrailers] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s167_aborted] [@js.enum]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s198_data] [@js.enum]) -> chunk:_Buffer or_string -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s206_drain] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s211_end] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s217_finish] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s219_frameError] [@js.enum]) -> frameType:float -> errorCode:float -> bool [@@js.call "emit"]
    val emit'''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> src:Stream.Readable.t_0 -> bool [@@js.call "emit"]
    val emit''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> src:Stream.Readable.t_0 -> bool [@@js.call "emit"]
    val emit'''''''''': t -> event:([`L_s305_streamClosed] [@js.enum]) -> code:float -> bool [@@js.call "emit"]
    val emit''''''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''''''''': t -> event:([`L_s314_trailers] [@js.enum]) -> trailers:http2_IncomingHttpHeaders -> flags:float -> bool [@@js.call "emit"]
    val emit''''''''''''': t -> event:([`L_s330_wantTrailers] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''''''''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''''''': t -> event:([`L_s305_streamClosed] [@js.enum]) -> listener:(code:float -> unit) -> t [@@js.call "on"]
    val on''''''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''''''': t -> event:([`L_s314_trailers] [@js.enum]) -> listener:(trailers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "on"]
    val on''''''''''''': t -> event:([`L_s330_wantTrailers] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''''''': t -> event:([`L_s305_streamClosed] [@js.enum]) -> listener:(code:float -> unit) -> t [@@js.call "once"]
    val once''''''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''''''': t -> event:([`L_s314_trailers] [@js.enum]) -> listener:(trailers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "once"]
    val once''''''''''''': t -> event:([`L_s330_wantTrailers] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''''': t -> event:([`L_s305_streamClosed] [@js.enum]) -> listener:(code:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''''''': t -> event:([`L_s314_trailers] [@js.enum]) -> listener:(trailers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''''''': t -> event:([`L_s330_wantTrailers] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''''': t -> event:([`L_s305_streamClosed] [@js.enum]) -> listener:(code:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''''''': t -> event:([`L_s314_trailers] [@js.enum]) -> listener:(trailers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''''''': t -> event:([`L_s330_wantTrailers] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Stream.Duplex.t_0 [@@js.cast]
  end
  module[@js.scope "ClientHttp2Stream"] ClientHttp2Stream : sig
    type t = http2_ClientHttp2Stream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener: t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> anonymous_interface_0) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener': t -> event:([`L_s225_headers] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'': t -> event:([`L_s276_push] [@js.enum]) -> listener:(headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
      
      
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s195_continue] [@js.enum]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s225_headers] [@js.enum]) -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s276_push] [@js.enum]) -> headers:http2_IncomingHttpHeaders -> flags:float -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s289_response] [@js.enum]) -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> bool [@@js.call "emit"]
    val emit'''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> anonymous_interface_0) -> t [@@js.call "on"]
    val on': t -> event:([`L_s225_headers] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s276_push] [@js.enum]) -> listener:(headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> anonymous_interface_0) -> t [@@js.call "once"]
    val once': t -> event:([`L_s225_headers] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s276_push] [@js.enum]) -> listener:(headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> anonymous_interface_0) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s225_headers] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s276_push] [@js.enum]) -> listener:(headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> anonymous_interface_0) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s225_headers] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s276_push] [@js.enum]) -> listener:(headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> http2_Http2Stream [@@js.cast]
  end
  module[@js.scope "ServerHttp2Stream"] ServerHttp2Stream : sig
    type t = http2_ServerHttp2Stream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_headersSent: t -> bool [@@js.get "headersSent"]
    val get_pushAllowed: t -> bool [@@js.get "pushAllowed"]
    val additionalHeaders: t -> headers:OutgoingHttpHeaders.t_0 -> unit [@@js.call "additionalHeaders"]
    val pushStream: t -> headers:OutgoingHttpHeaders.t_0 -> ?callback:(err:Error.t_0 or_null -> pushStream:t -> headers:OutgoingHttpHeaders.t_0 -> unit) -> unit -> unit [@@js.call "pushStream"]
    val pushStream': t -> headers:OutgoingHttpHeaders.t_0 -> ?options:http2_StreamPriorityOptions -> ?callback:(err:Error.t_0 or_null -> pushStream:t -> headers:OutgoingHttpHeaders.t_0 -> unit) -> unit -> unit [@@js.call "pushStream"]
    val respond: t -> ?headers:OutgoingHttpHeaders.t_0 -> ?options:http2_ServerStreamResponseOptions -> unit -> unit [@@js.call "respond"]
    val respondWithFD: t -> fd:Fs.Promises.FileHandle.t_0 or_number -> ?headers:OutgoingHttpHeaders.t_0 -> ?options:http2_ServerStreamFileResponseOptions -> unit -> unit [@@js.call "respondWithFD"]
    val respondWithFile: t -> path:string -> ?headers:OutgoingHttpHeaders.t_0 -> ?options:http2_ServerStreamFileResponseOptionsWithError -> unit -> unit [@@js.call "respondWithFile"]
    val cast: t -> http2_Http2Stream [@@js.cast]
  end
  module[@js.scope "Settings"] Settings : sig
    type t = http2_Settings
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_headerTableSize: t -> float [@@js.get "headerTableSize"]
    val set_headerTableSize: t -> float -> unit [@@js.set "headerTableSize"]
    val get_enablePush: t -> bool [@@js.get "enablePush"]
    val set_enablePush: t -> bool -> unit [@@js.set "enablePush"]
    val get_initialWindowSize: t -> float [@@js.get "initialWindowSize"]
    val set_initialWindowSize: t -> float -> unit [@@js.set "initialWindowSize"]
    val get_maxFrameSize: t -> float [@@js.get "maxFrameSize"]
    val set_maxFrameSize: t -> float -> unit [@@js.set "maxFrameSize"]
    val get_maxConcurrentStreams: t -> float [@@js.get "maxConcurrentStreams"]
    val set_maxConcurrentStreams: t -> float -> unit [@@js.set "maxConcurrentStreams"]
    val get_maxHeaderListSize: t -> float [@@js.get "maxHeaderListSize"]
    val set_maxHeaderListSize: t -> float -> unit [@@js.set "maxHeaderListSize"]
    val get_enableConnectProtocol: t -> bool [@@js.get "enableConnectProtocol"]
    val set_enableConnectProtocol: t -> bool -> unit [@@js.set "enableConnectProtocol"]
  end
  module[@js.scope "ClientSessionRequestOptions"] ClientSessionRequestOptions : sig
    type t = http2_ClientSessionRequestOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_endStream: t -> bool [@@js.get "endStream"]
    val set_endStream: t -> bool -> unit [@@js.set "endStream"]
    val get_exclusive: t -> bool [@@js.get "exclusive"]
    val set_exclusive: t -> bool -> unit [@@js.set "exclusive"]
    val get_parent: t -> float [@@js.get "parent"]
    val set_parent: t -> float -> unit [@@js.set "parent"]
    val get_weight: t -> float [@@js.get "weight"]
    val set_weight: t -> float -> unit [@@js.set "weight"]
    val get_waitForTrailers: t -> bool [@@js.get "waitForTrailers"]
    val set_waitForTrailers: t -> bool -> unit [@@js.set "waitForTrailers"]
  end
  module[@js.scope "SessionState"] SessionState : sig
    type t = http2_SessionState
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_effectiveLocalWindowSize: t -> float [@@js.get "effectiveLocalWindowSize"]
    val set_effectiveLocalWindowSize: t -> float -> unit [@@js.set "effectiveLocalWindowSize"]
    val get_effectiveRecvDataLength: t -> float [@@js.get "effectiveRecvDataLength"]
    val set_effectiveRecvDataLength: t -> float -> unit [@@js.set "effectiveRecvDataLength"]
    val get_nextStreamID: t -> float [@@js.get "nextStreamID"]
    val set_nextStreamID: t -> float -> unit [@@js.set "nextStreamID"]
    val get_localWindowSize: t -> float [@@js.get "localWindowSize"]
    val set_localWindowSize: t -> float -> unit [@@js.set "localWindowSize"]
    val get_lastProcStreamID: t -> float [@@js.get "lastProcStreamID"]
    val set_lastProcStreamID: t -> float -> unit [@@js.set "lastProcStreamID"]
    val get_remoteWindowSize: t -> float [@@js.get "remoteWindowSize"]
    val set_remoteWindowSize: t -> float -> unit [@@js.set "remoteWindowSize"]
    val get_outboundQueueSize: t -> float [@@js.get "outboundQueueSize"]
    val set_outboundQueueSize: t -> float -> unit [@@js.set "outboundQueueSize"]
    val get_deflateDynamicTableSize: t -> float [@@js.get "deflateDynamicTableSize"]
    val set_deflateDynamicTableSize: t -> float -> unit [@@js.set "deflateDynamicTableSize"]
    val get_inflateDynamicTableSize: t -> float [@@js.get "inflateDynamicTableSize"]
    val set_inflateDynamicTableSize: t -> float -> unit [@@js.set "inflateDynamicTableSize"]
  end
  module[@js.scope "Http2Session"] Http2Session : sig
    type t = http2_Http2Session
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_alpnProtocol: t -> string [@@js.get "alpnProtocol"]
    val get_closed: t -> bool [@@js.get "closed"]
    val get_connecting: t -> bool [@@js.get "connecting"]
    val get_destroyed: t -> bool [@@js.get "destroyed"]
    val get_encrypted: t -> bool [@@js.get "encrypted"]
    val get_localSettings: t -> http2_Settings [@@js.get "localSettings"]
    val get_originSet: t -> string list [@@js.get "originSet"]
    val get_pendingSettingsAck: t -> bool [@@js.get "pendingSettingsAck"]
    val get_remoteSettings: t -> http2_Settings [@@js.get "remoteSettings"]
    val get_socket: t -> (net_Socket, tls_TLSSocket) union2 [@@js.get "socket"]
    val get_state: t -> http2_SessionState [@@js.get "state"]
    val get_type: t -> float [@@js.get "type"]
    val close: t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "close"]
    val destroy: t -> ?error:Error.t_0 -> ?code:float -> unit -> unit [@@js.call "destroy"]
    val goaway: t -> ?code:float -> ?lastStreamID:float -> ?opaqueData:_NodeJS_ArrayBufferView -> unit -> unit [@@js.call "goaway"]
    val ping: t -> callback:(err:Error.t_0 or_null -> duration:float -> payload:_Buffer -> unit) -> bool [@@js.call "ping"]
    val ping': t -> payload:_NodeJS_ArrayBufferView -> callback:(err:Error.t_0 or_null -> duration:float -> payload:_Buffer -> unit) -> bool [@@js.call "ping"]
    val ref: t -> unit [@@js.call "ref"]
    val setLocalWindowSize: t -> windowSize:float -> unit [@@js.call "setLocalWindowSize"]
    val setTimeout: t -> msecs:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "setTimeout"]
    val settings: t -> settings:http2_Settings -> unit [@@js.call "settings"]
    val unref: t -> unit [@@js.call "unref"]
    val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val addListener': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    val addListener'': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> streamID:float -> unit) -> t [@@js.call "addListener"]
    val addListener''': t -> event:([`L_s224_goaway] [@js.enum]) -> listener:(errorCode:float -> lastStreamID:float -> opaqueData:_Buffer -> unit) -> t [@@js.call "addListener"]
    val addListener'''': t -> event:([`L_s247_localSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "addListener"]
    val addListener''''': t -> event:([`L_s270_ping] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val addListener'''''': t -> event:([`L_s282_remoteSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "addListener"]
    val addListener''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val addListener'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s219_frameError] [@js.enum]) -> frameType:float -> errorCode:float -> streamID:float -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s224_goaway] [@js.enum]) -> errorCode:float -> lastStreamID:float -> opaqueData:_Buffer -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s247_localSettings] [@js.enum]) -> settings:http2_Settings -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s270_ping] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s282_remoteSettings] [@js.enum]) -> settings:http2_Settings -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> streamID:float -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s224_goaway] [@js.enum]) -> listener:(errorCode:float -> lastStreamID:float -> opaqueData:_Buffer -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s247_localSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s270_ping] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s282_remoteSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> streamID:float -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s224_goaway] [@js.enum]) -> listener:(errorCode:float -> lastStreamID:float -> opaqueData:_Buffer -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s247_localSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s270_ping] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s282_remoteSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> streamID:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s224_goaway] [@js.enum]) -> listener:(errorCode:float -> lastStreamID:float -> opaqueData:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s247_localSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s270_ping] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s282_remoteSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s219_frameError] [@js.enum]) -> listener:(frameType:float -> errorCode:float -> streamID:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s224_goaway] [@js.enum]) -> listener:(errorCode:float -> lastStreamID:float -> opaqueData:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s247_localSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s270_ping] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s282_remoteSettings] [@js.enum]) -> listener:(settings:http2_Settings -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "ClientHttp2Session"] ClientHttp2Session : sig
    type t = http2_ClientHttp2Session
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val request: t -> ?headers:OutgoingHttpHeaders.t_0 -> ?options:http2_ClientSessionRequestOptions -> unit -> http2_ClientHttp2Stream [@@js.call "request"]
    val addListener: t -> event:([`L_s177_altsvc] [@js.enum]) -> listener:(alt:string -> origin:string -> stream:float -> unit) -> t [@@js.call "addListener"]
    val addListener': t -> event:([`L_s267_origin] [@js.enum]) -> listener:(origins:string list -> unit) -> t [@@js.call "addListener"]
    val addListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "addListener"]
    val addListener''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ClientHttp2Stream -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "addListener"]
    val addListener'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s177_altsvc] [@js.enum]) -> alt:string -> origin:string -> stream:float -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s267_origin] [@js.enum]) -> origins:string list -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s193_connect] [@js.enum]) -> session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s304_stream] [@js.enum]) -> stream:http2_ClientHttp2Stream -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> bool [@@js.call "emit"]
    val emit'''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s177_altsvc] [@js.enum]) -> listener:(alt:string -> origin:string -> stream:float -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s267_origin] [@js.enum]) -> listener:(origins:string list -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ClientHttp2Stream -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s177_altsvc] [@js.enum]) -> listener:(alt:string -> origin:string -> stream:float -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s267_origin] [@js.enum]) -> listener:(origins:string list -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ClientHttp2Stream -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s177_altsvc] [@js.enum]) -> listener:(alt:string -> origin:string -> stream:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s267_origin] [@js.enum]) -> listener:(origins:string list -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ClientHttp2Stream -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s177_altsvc] [@js.enum]) -> listener:(alt:string -> origin:string -> stream:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s267_origin] [@js.enum]) -> listener:(origins:string list -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ClientHttp2Stream -> headers:(http2_IncomingHttpHeaders, http2_IncomingHttpStatusHeader) intersection2 -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> http2_Http2Session [@@js.cast]
  end
  module[@js.scope "AlternativeServiceOptions"] AlternativeServiceOptions : sig
    type t = http2_AlternativeServiceOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_origin: t -> url_URL or_string or_number [@@js.get "origin"]
    val set_origin: t -> url_URL or_string or_number -> unit [@@js.set "origin"]
  end
  module[@js.scope "ServerHttp2Session"] ServerHttp2Session : sig
    type t = http2_ServerHttp2Session
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_server: t -> (http2_Http2SecureServer, http2_Http2Server) union2 [@@js.get "server"]
    val altsvc: t -> alt:string -> originOrStream:(http2_AlternativeServiceOptions, url_URL) union2 or_string or_number -> unit [@@js.call "altsvc"]
    val origin: t -> args:((* FIXME: type 'Array<union<String | url.URL | {..}>>' cannot be used for variadic argument *)any list [@js.variadic]) -> unit [@@js.call "origin"]
    val addListener: t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "addListener"]
    val addListener': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "addListener"]
    val addListener'': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s193_connect] [@js.enum]) -> session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s304_stream] [@js.enum]) -> stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> bool [@@js.call "emit"]
    val emit'': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "on"]
    val on'': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "once"]
    val once'': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s193_connect] [@js.enum]) -> listener:(session:t -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> http2_Http2Session [@@js.cast]
  end
  module[@js.scope "SessionOptions"] SessionOptions : sig
    type t = http2_SessionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_maxDeflateDynamicTableSize: t -> float [@@js.get "maxDeflateDynamicTableSize"]
    val set_maxDeflateDynamicTableSize: t -> float -> unit [@@js.set "maxDeflateDynamicTableSize"]
    val get_maxSessionMemory: t -> float [@@js.get "maxSessionMemory"]
    val set_maxSessionMemory: t -> float -> unit [@@js.set "maxSessionMemory"]
    val get_maxHeaderListPairs: t -> float [@@js.get "maxHeaderListPairs"]
    val set_maxHeaderListPairs: t -> float -> unit [@@js.set "maxHeaderListPairs"]
    val get_maxOutstandingPings: t -> float [@@js.get "maxOutstandingPings"]
    val set_maxOutstandingPings: t -> float -> unit [@@js.set "maxOutstandingPings"]
    val get_maxSendHeaderBlockLength: t -> float [@@js.get "maxSendHeaderBlockLength"]
    val set_maxSendHeaderBlockLength: t -> float -> unit [@@js.set "maxSendHeaderBlockLength"]
    val get_paddingStrategy: t -> float [@@js.get "paddingStrategy"]
    val set_paddingStrategy: t -> float -> unit [@@js.set "paddingStrategy"]
    val get_peerMaxConcurrentStreams: t -> float [@@js.get "peerMaxConcurrentStreams"]
    val set_peerMaxConcurrentStreams: t -> float -> unit [@@js.set "peerMaxConcurrentStreams"]
    val get_settings: t -> http2_Settings [@@js.get "settings"]
    val set_settings: t -> http2_Settings -> unit [@@js.set "settings"]
    val selectPadding: t -> frameLen:float -> maxFrameLen:float -> float [@@js.call "selectPadding"]
    val createConnection: t -> authority:url_URL -> option:t -> Stream.Duplex.t_0 [@@js.call "createConnection"]
  end
  module[@js.scope "ClientSessionOptions"] ClientSessionOptions : sig
    type t = http2_ClientSessionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_maxReservedRemoteStreams: t -> float [@@js.get "maxReservedRemoteStreams"]
    val set_maxReservedRemoteStreams: t -> float -> unit [@@js.set "maxReservedRemoteStreams"]
    val createConnection: t -> authority:url_URL -> option:http2_SessionOptions -> Stream.Duplex.t_0 [@@js.call "createConnection"]
    val get_protocol: t -> ([`L_s229_http_[@js "http:"] | `L_s230_https_[@js "https:"]] [@js.enum]) [@@js.get "protocol"]
    val set_protocol: t -> ([`L_s229_http_ | `L_s230_https_] [@js.enum]) -> unit [@@js.set "protocol"]
    val cast: t -> http2_SessionOptions [@@js.cast]
  end
  module[@js.scope "ServerSessionOptions"] ServerSessionOptions : sig
    type t = http2_ServerSessionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_Http1IncomingMessage: t -> (* FIXME: unknown type 'typeof IncomingMessage' *)any [@@js.get "Http1IncomingMessage"]
    val set_Http1IncomingMessage: t -> (* FIXME: unknown type 'typeof IncomingMessage' *)any -> unit [@@js.set "Http1IncomingMessage"]
    val get_Http1ServerResponse: t -> (* FIXME: unknown type 'typeof ServerResponse' *)any [@@js.get "Http1ServerResponse"]
    val set_Http1ServerResponse: t -> (* FIXME: unknown type 'typeof ServerResponse' *)any -> unit [@@js.set "Http1ServerResponse"]
    val get_Http2ServerRequest: t -> (* FIXME: unknown type 'typeof Http2ServerRequest' *)any [@@js.get "Http2ServerRequest"]
    val set_Http2ServerRequest: t -> (* FIXME: unknown type 'typeof Http2ServerRequest' *)any -> unit [@@js.set "Http2ServerRequest"]
    val get_Http2ServerResponse: t -> (* FIXME: unknown type 'typeof Http2ServerResponse' *)any [@@js.get "Http2ServerResponse"]
    val set_Http2ServerResponse: t -> (* FIXME: unknown type 'typeof Http2ServerResponse' *)any -> unit [@@js.set "Http2ServerResponse"]
    val cast: t -> http2_SessionOptions [@@js.cast]
  end
  module[@js.scope "SecureClientSessionOptions"] SecureClientSessionOptions : sig
    type t = http2_SecureClientSessionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> http2_ClientSessionOptions [@@js.cast]
    val cast': t -> tls_ConnectionOptions [@@js.cast]
  end
  module[@js.scope "SecureServerSessionOptions"] SecureServerSessionOptions : sig
    type t = http2_SecureServerSessionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> http2_ServerSessionOptions [@@js.cast]
    val cast': t -> tls_TlsOptions [@@js.cast]
  end
  module[@js.scope "ServerOptions"] ServerOptions : sig
    type t = http2_ServerOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> http2_ServerSessionOptions [@@js.cast]
  end
  module[@js.scope "SecureServerOptions"] SecureServerOptions : sig
    type t = http2_SecureServerOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_allowHTTP1: t -> bool [@@js.get "allowHTTP1"]
    val set_allowHTTP1: t -> bool -> unit [@@js.set "allowHTTP1"]
    val get_origins: t -> string list [@@js.get "origins"]
    val set_origins: t -> string list -> unit [@@js.set "origins"]
    val cast: t -> http2_SecureServerSessionOptions [@@js.cast]
  end
  module[@js.scope "Http2Server"] Http2Server : sig
    type t = http2_Http2Server
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s190_checkContinue] [@js.enum]) -> request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s285_request] [@js.enum]) -> request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s297_session] [@js.enum]) -> session:http2_ServerHttp2Session -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s298_sessionError] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s304_stream] [@js.enum]) -> stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s312_timeout] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val setTimeout: t -> ?msec:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    val cast: t -> net_Server [@@js.cast]
  end
  module[@js.scope "Http2SecureServer"] Http2SecureServer : sig
    type t = http2_Http2SecureServer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener'''''': t -> event:([`L_s324_unknownProtocol] [@js.enum]) -> listener:(socket:tls_TLSSocket -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s190_checkContinue] [@js.enum]) -> request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s285_request] [@js.enum]) -> request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s297_session] [@js.enum]) -> session:http2_ServerHttp2Session -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s298_sessionError] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s304_stream] [@js.enum]) -> stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s312_timeout] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s324_unknownProtocol] [@js.enum]) -> socket:tls_TLSSocket -> bool [@@js.call "emit"]
    val emit''''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s324_unknownProtocol] [@js.enum]) -> listener:(socket:tls_TLSSocket -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s324_unknownProtocol] [@js.enum]) -> listener:(socket:tls_TLSSocket -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s324_unknownProtocol] [@js.enum]) -> listener:(socket:tls_TLSSocket -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s190_checkContinue] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s285_request] [@js.enum]) -> listener:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:http2_ServerHttp2Session -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s298_sessionError] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s304_stream] [@js.enum]) -> listener:(stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> flags:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s324_unknownProtocol] [@js.enum]) -> listener:(socket:tls_TLSSocket -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val setTimeout: t -> ?msec:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    val cast: t -> tls_Server [@@js.cast]
  end
  module[@js.scope "Http2ServerRequest"] Http2ServerRequest : sig
    type t = http2_Http2ServerRequest
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: stream:http2_ServerHttp2Stream -> headers:http2_IncomingHttpHeaders -> options:Stream.ReadableOptions.t_0 -> rawHeaders:string list -> t [@@js.create]
    val get_aborted: t -> bool [@@js.get "aborted"]
    val get_authority: t -> string [@@js.get "authority"]
    val get_connection: t -> (net_Socket, tls_TLSSocket) union2 [@@js.get "connection"]
    val get_complete: t -> bool [@@js.get "complete"]
    val get_headers: t -> http2_IncomingHttpHeaders [@@js.get "headers"]
    val get_httpVersion: t -> string [@@js.get "httpVersion"]
    val get_httpVersionMinor: t -> float [@@js.get "httpVersionMinor"]
    val get_httpVersionMajor: t -> float [@@js.get "httpVersionMajor"]
    val get_method: t -> string [@@js.get "method"]
    val get_rawHeaders: t -> string list [@@js.get "rawHeaders"]
    val get_rawTrailers: t -> string list [@@js.get "rawTrailers"]
    val get_scheme: t -> string [@@js.get "scheme"]
    val get_socket: t -> (net_Socket, tls_TLSSocket) union2 [@@js.get "socket"]
    val get_stream: t -> http2_ServerHttp2Stream [@@js.get "stream"]
    val get_trailers: t -> http2_IncomingHttpHeaders [@@js.get "trailers"]
    val get_url: t -> string [@@js.get "url"]
    val setTimeout: t -> msecs:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "setTimeout"]
    val read: t -> ?size:float -> unit -> _Buffer or_string or_null [@@js.call "read"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(hadError:bool -> code:float -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s167_aborted] [@js.enum]) -> hadError:bool -> code:float -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s198_data] [@js.enum]) -> chunk:_Buffer or_string -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s211_end] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s277_readable] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(hadError:bool -> code:float -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(hadError:bool -> code:float -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(hadError:bool -> code:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s167_aborted] [@js.enum]) -> listener:(hadError:bool -> code:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:_Buffer or_string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Stream.Readable.t_0 [@@js.cast]
  end
  module[@js.scope "Http2ServerResponse"] Http2ServerResponse : sig
    type t = http2_Http2ServerResponse
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: stream:http2_ServerHttp2Stream -> t [@@js.create]
    val get_connection: t -> (net_Socket, tls_TLSSocket) union2 [@@js.get "connection"]
    val get_finished: t -> bool [@@js.get "finished"]
    val get_headersSent: t -> bool [@@js.get "headersSent"]
    val get_socket: t -> (net_Socket, tls_TLSSocket) union2 [@@js.get "socket"]
    val get_stream: t -> http2_ServerHttp2Stream [@@js.get "stream"]
    val get_sendDate: t -> bool [@@js.get "sendDate"]
    val set_sendDate: t -> bool -> unit [@@js.set "sendDate"]
    val get_statusCode: t -> float [@@js.get "statusCode"]
    val set_statusCode: t -> float -> unit [@@js.set "statusCode"]
    val get_statusMessage: t -> ([`L_s0[@js ""]] [@js.enum]) [@@js.get "statusMessage"]
    val set_statusMessage: t -> ([`L_s0] [@js.enum]) -> unit [@@js.set "statusMessage"]
    val addTrailers: t -> trailers:OutgoingHttpHeaders.t_0 -> unit [@@js.call "addTrailers"]
    val end_: t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val end_': t -> data:Uint8Array.t_0 or_string -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val end_'': t -> data:Uint8Array.t_0 or_string -> encoding:_BufferEncoding -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val getHeader: t -> name:string -> string [@@js.call "getHeader"]
    val getHeaderNames: t -> string list [@@js.call "getHeaderNames"]
    val getHeaders: t -> OutgoingHttpHeaders.t_0 [@@js.call "getHeaders"]
    val hasHeader: t -> name:string -> bool [@@js.call "hasHeader"]
    val removeHeader: t -> name:string -> unit [@@js.call "removeHeader"]
    val setHeader: t -> name:string -> value:string list or_string or_number -> unit [@@js.call "setHeader"]
    val setTimeout: t -> msecs:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "setTimeout"]
    val write: t -> chunk:Uint8Array.t_0 or_string -> ?callback:(err:Error.t_0 -> unit) -> unit -> bool [@@js.call "write"]
    val write': t -> chunk:Uint8Array.t_0 or_string -> encoding:_BufferEncoding -> ?callback:(err:Error.t_0 -> unit) -> unit -> bool [@@js.call "write"]
    val writeContinue: t -> unit [@@js.call "writeContinue"]
    val writeHead: t -> statusCode:float -> ?headers:OutgoingHttpHeaders.t_0 -> unit -> t [@@js.call "writeHead"]
    val writeHead': t -> statusCode:float -> statusMessage:string -> ?headers:OutgoingHttpHeaders.t_0 -> unit -> t [@@js.call "writeHead"]
    val createPushResponse: t -> headers:OutgoingHttpHeaders.t_0 -> callback:(err:Error.t_0 or_null -> res:t -> unit) -> unit [@@js.call "createPushResponse"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s206_drain] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s213_error] [@js.enum]) -> error:Error.t_0 -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s217_finish] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s271_pipe] [@js.enum]) -> src:Stream.Readable.t_0 -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> src:Stream.Readable.t_0 -> bool [@@js.call "emit"]
    val emit'''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Stream.Writable.t_0 [@@js.cast]
  end
  module[@js.scope "constants"] Constants : sig
    val nghttp2_session_server: float [@@js.global "NGHTTP2_SESSION_SERVER"]
    val nghttp2_session_client: float [@@js.global "NGHTTP2_SESSION_CLIENT"]
    val nghttp2_stream_state_idle: float [@@js.global "NGHTTP2_STREAM_STATE_IDLE"]
    val nghttp2_stream_state_open: float [@@js.global "NGHTTP2_STREAM_STATE_OPEN"]
    val nghttp2_stream_state_reserved_local: float [@@js.global "NGHTTP2_STREAM_STATE_RESERVED_LOCAL"]
    val nghttp2_stream_state_reserved_remote: float [@@js.global "NGHTTP2_STREAM_STATE_RESERVED_REMOTE"]
    val nghttp2_stream_state_half_closed_local: float [@@js.global "NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL"]
    val nghttp2_stream_state_half_closed_remote: float [@@js.global "NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE"]
    val nghttp2_stream_state_closed: float [@@js.global "NGHTTP2_STREAM_STATE_CLOSED"]
    val nghttp2_no_error: float [@@js.global "NGHTTP2_NO_ERROR"]
    val nghttp2_protocol_error: float [@@js.global "NGHTTP2_PROTOCOL_ERROR"]
    val nghttp2_internal_error: float [@@js.global "NGHTTP2_INTERNAL_ERROR"]
    val nghttp2_flow_control_error: float [@@js.global "NGHTTP2_FLOW_CONTROL_ERROR"]
    val nghttp2_settings_timeout: float [@@js.global "NGHTTP2_SETTINGS_TIMEOUT"]
    val nghttp2_stream_closed: float [@@js.global "NGHTTP2_STREAM_CLOSED"]
    val nghttp2_frame_size_error: float [@@js.global "NGHTTP2_FRAME_SIZE_ERROR"]
    val nghttp2_refused_stream: float [@@js.global "NGHTTP2_REFUSED_STREAM"]
    val nghttp2_cancel: float [@@js.global "NGHTTP2_CANCEL"]
    val nghttp2_compression_error: float [@@js.global "NGHTTP2_COMPRESSION_ERROR"]
    val nghttp2_connect_error: float [@@js.global "NGHTTP2_CONNECT_ERROR"]
    val nghttp2_enhance_your_calm: float [@@js.global "NGHTTP2_ENHANCE_YOUR_CALM"]
    val nghttp2_inadequate_security: float [@@js.global "NGHTTP2_INADEQUATE_SECURITY"]
    val nghttp2_http_1_1_required: float [@@js.global "NGHTTP2_HTTP_1_1_REQUIRED"]
    val nghttp2_err_frame_size_error: float [@@js.global "NGHTTP2_ERR_FRAME_SIZE_ERROR"]
    val nghttp2_flag_none: float [@@js.global "NGHTTP2_FLAG_NONE"]
    val nghttp2_flag_end_stream: float [@@js.global "NGHTTP2_FLAG_END_STREAM"]
    val nghttp2_flag_end_headers: float [@@js.global "NGHTTP2_FLAG_END_HEADERS"]
    val nghttp2_flag_ack: float [@@js.global "NGHTTP2_FLAG_ACK"]
    val nghttp2_flag_padded: float [@@js.global "NGHTTP2_FLAG_PADDED"]
    val nghttp2_flag_priority: float [@@js.global "NGHTTP2_FLAG_PRIORITY"]
    val default_settings_header_table_size: float [@@js.global "DEFAULT_SETTINGS_HEADER_TABLE_SIZE"]
    val default_settings_enable_push: float [@@js.global "DEFAULT_SETTINGS_ENABLE_PUSH"]
    val default_settings_initial_window_size: float [@@js.global "DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE"]
    val default_settings_max_frame_size: float [@@js.global "DEFAULT_SETTINGS_MAX_FRAME_SIZE"]
    val max_max_frame_size: float [@@js.global "MAX_MAX_FRAME_SIZE"]
    val min_max_frame_size: float [@@js.global "MIN_MAX_FRAME_SIZE"]
    val max_initial_window_size: float [@@js.global "MAX_INITIAL_WINDOW_SIZE"]
    val nghttp2_default_weight: float [@@js.global "NGHTTP2_DEFAULT_WEIGHT"]
    val nghttp2_settings_header_table_size: float [@@js.global "NGHTTP2_SETTINGS_HEADER_TABLE_SIZE"]
    val nghttp2_settings_enable_push: float [@@js.global "NGHTTP2_SETTINGS_ENABLE_PUSH"]
    val nghttp2_settings_max_concurrent_streams: float [@@js.global "NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS"]
    val nghttp2_settings_initial_window_size: float [@@js.global "NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE"]
    val nghttp2_settings_max_frame_size: float [@@js.global "NGHTTP2_SETTINGS_MAX_FRAME_SIZE"]
    val nghttp2_settings_max_header_list_size: float [@@js.global "NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE"]
    val padding_strategy_none: float [@@js.global "PADDING_STRATEGY_NONE"]
    val padding_strategy_max: float [@@js.global "PADDING_STRATEGY_MAX"]
    val padding_strategy_callback: float [@@js.global "PADDING_STRATEGY_CALLBACK"]
    val http2_header_status: string [@@js.global "HTTP2_HEADER_STATUS"]
    val http2_header_method: string [@@js.global "HTTP2_HEADER_METHOD"]
    val http2_header_authority: string [@@js.global "HTTP2_HEADER_AUTHORITY"]
    val http2_header_scheme: string [@@js.global "HTTP2_HEADER_SCHEME"]
    val http2_header_path: string [@@js.global "HTTP2_HEADER_PATH"]
    val http2_header_accept_charset: string [@@js.global "HTTP2_HEADER_ACCEPT_CHARSET"]
    val http2_header_accept_encoding: string [@@js.global "HTTP2_HEADER_ACCEPT_ENCODING"]
    val http2_header_accept_language: string [@@js.global "HTTP2_HEADER_ACCEPT_LANGUAGE"]
    val http2_header_accept_ranges: string [@@js.global "HTTP2_HEADER_ACCEPT_RANGES"]
    val http2_header_accept: string [@@js.global "HTTP2_HEADER_ACCEPT"]
    val http2_header_access_control_allow_origin: string [@@js.global "HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN"]
    val http2_header_age: string [@@js.global "HTTP2_HEADER_AGE"]
    val http2_header_allow: string [@@js.global "HTTP2_HEADER_ALLOW"]
    val http2_header_authorization: string [@@js.global "HTTP2_HEADER_AUTHORIZATION"]
    val http2_header_cache_control: string [@@js.global "HTTP2_HEADER_CACHE_CONTROL"]
    val http2_header_connection: string [@@js.global "HTTP2_HEADER_CONNECTION"]
    val http2_header_content_disposition: string [@@js.global "HTTP2_HEADER_CONTENT_DISPOSITION"]
    val http2_header_content_encoding: string [@@js.global "HTTP2_HEADER_CONTENT_ENCODING"]
    val http2_header_content_language: string [@@js.global "HTTP2_HEADER_CONTENT_LANGUAGE"]
    val http2_header_content_length: string [@@js.global "HTTP2_HEADER_CONTENT_LENGTH"]
    val http2_header_content_location: string [@@js.global "HTTP2_HEADER_CONTENT_LOCATION"]
    val http2_header_content_md5: string [@@js.global "HTTP2_HEADER_CONTENT_MD5"]
    val http2_header_content_range: string [@@js.global "HTTP2_HEADER_CONTENT_RANGE"]
    val http2_header_content_type: string [@@js.global "HTTP2_HEADER_CONTENT_TYPE"]
    val http2_header_cookie: string [@@js.global "HTTP2_HEADER_COOKIE"]
    val http2_header_date: string [@@js.global "HTTP2_HEADER_DATE"]
    val http2_header_etag: string [@@js.global "HTTP2_HEADER_ETAG"]
    val http2_header_expect: string [@@js.global "HTTP2_HEADER_EXPECT"]
    val http2_header_expires: string [@@js.global "HTTP2_HEADER_EXPIRES"]
    val http2_header_from: string [@@js.global "HTTP2_HEADER_FROM"]
    val http2_header_host: string [@@js.global "HTTP2_HEADER_HOST"]
    val http2_header_if_match: string [@@js.global "HTTP2_HEADER_IF_MATCH"]
    val http2_header_if_modified_since: string [@@js.global "HTTP2_HEADER_IF_MODIFIED_SINCE"]
    val http2_header_if_none_match: string [@@js.global "HTTP2_HEADER_IF_NONE_MATCH"]
    val http2_header_if_range: string [@@js.global "HTTP2_HEADER_IF_RANGE"]
    val http2_header_if_unmodified_since: string [@@js.global "HTTP2_HEADER_IF_UNMODIFIED_SINCE"]
    val http2_header_last_modified: string [@@js.global "HTTP2_HEADER_LAST_MODIFIED"]
    val http2_header_link: string [@@js.global "HTTP2_HEADER_LINK"]
    val http2_header_location: string [@@js.global "HTTP2_HEADER_LOCATION"]
    val http2_header_max_forwards: string [@@js.global "HTTP2_HEADER_MAX_FORWARDS"]
    val http2_header_prefer: string [@@js.global "HTTP2_HEADER_PREFER"]
    val http2_header_proxy_authenticate: string [@@js.global "HTTP2_HEADER_PROXY_AUTHENTICATE"]
    val http2_header_proxy_authorization: string [@@js.global "HTTP2_HEADER_PROXY_AUTHORIZATION"]
    val http2_header_range: string [@@js.global "HTTP2_HEADER_RANGE"]
    val http2_header_referer: string [@@js.global "HTTP2_HEADER_REFERER"]
    val http2_header_refresh: string [@@js.global "HTTP2_HEADER_REFRESH"]
    val http2_header_retry_after: string [@@js.global "HTTP2_HEADER_RETRY_AFTER"]
    val http2_header_server: string [@@js.global "HTTP2_HEADER_SERVER"]
    val http2_header_set_cookie: string [@@js.global "HTTP2_HEADER_SET_COOKIE"]
    val http2_header_strict_transport_security: string [@@js.global "HTTP2_HEADER_STRICT_TRANSPORT_SECURITY"]
    val http2_header_transfer_encoding: string [@@js.global "HTTP2_HEADER_TRANSFER_ENCODING"]
    val http2_header_te: string [@@js.global "HTTP2_HEADER_TE"]
    val http2_header_upgrade: string [@@js.global "HTTP2_HEADER_UPGRADE"]
    val http2_header_user_agent: string [@@js.global "HTTP2_HEADER_USER_AGENT"]
    val http2_header_vary: string [@@js.global "HTTP2_HEADER_VARY"]
    val http2_header_via: string [@@js.global "HTTP2_HEADER_VIA"]
    val http2_header_www_authenticate: string [@@js.global "HTTP2_HEADER_WWW_AUTHENTICATE"]
    val http2_header_http2_settings: string [@@js.global "HTTP2_HEADER_HTTP2_SETTINGS"]
    val http2_header_keep_alive: string [@@js.global "HTTP2_HEADER_KEEP_ALIVE"]
    val http2_header_proxy_connection: string [@@js.global "HTTP2_HEADER_PROXY_CONNECTION"]
    val http2_method_acl: string [@@js.global "HTTP2_METHOD_ACL"]
    val http2_method_baseline_control: string [@@js.global "HTTP2_METHOD_BASELINE_CONTROL"]
    val http2_method_bind: string [@@js.global "HTTP2_METHOD_BIND"]
    val http2_method_checkin: string [@@js.global "HTTP2_METHOD_CHECKIN"]
    val http2_method_checkout: string [@@js.global "HTTP2_METHOD_CHECKOUT"]
    val http2_method_connect: string [@@js.global "HTTP2_METHOD_CONNECT"]
    val http2_method_copy: string [@@js.global "HTTP2_METHOD_COPY"]
    val http2_method_delete: string [@@js.global "HTTP2_METHOD_DELETE"]
    val http2_method_get: string [@@js.global "HTTP2_METHOD_GET"]
    val http2_method_head: string [@@js.global "HTTP2_METHOD_HEAD"]
    val http2_method_label: string [@@js.global "HTTP2_METHOD_LABEL"]
    val http2_method_link: string [@@js.global "HTTP2_METHOD_LINK"]
    val http2_method_lock: string [@@js.global "HTTP2_METHOD_LOCK"]
    val http2_method_merge: string [@@js.global "HTTP2_METHOD_MERGE"]
    val http2_method_mkactivity: string [@@js.global "HTTP2_METHOD_MKACTIVITY"]
    val http2_method_mkcalendar: string [@@js.global "HTTP2_METHOD_MKCALENDAR"]
    val http2_method_mkcol: string [@@js.global "HTTP2_METHOD_MKCOL"]
    val http2_method_mkredirectref: string [@@js.global "HTTP2_METHOD_MKREDIRECTREF"]
    val http2_method_mkworkspace: string [@@js.global "HTTP2_METHOD_MKWORKSPACE"]
    val http2_method_move: string [@@js.global "HTTP2_METHOD_MOVE"]
    val http2_method_options: string [@@js.global "HTTP2_METHOD_OPTIONS"]
    val http2_method_orderpatch: string [@@js.global "HTTP2_METHOD_ORDERPATCH"]
    val http2_method_patch: string [@@js.global "HTTP2_METHOD_PATCH"]
    val http2_method_post: string [@@js.global "HTTP2_METHOD_POST"]
    val http2_method_pri: string [@@js.global "HTTP2_METHOD_PRI"]
    val http2_method_propfind: string [@@js.global "HTTP2_METHOD_PROPFIND"]
    val http2_method_proppatch: string [@@js.global "HTTP2_METHOD_PROPPATCH"]
    val http2_method_put: string [@@js.global "HTTP2_METHOD_PUT"]
    val http2_method_rebind: string [@@js.global "HTTP2_METHOD_REBIND"]
    val http2_method_report: string [@@js.global "HTTP2_METHOD_REPORT"]
    val http2_method_search: string [@@js.global "HTTP2_METHOD_SEARCH"]
    val http2_method_trace: string [@@js.global "HTTP2_METHOD_TRACE"]
    val http2_method_unbind: string [@@js.global "HTTP2_METHOD_UNBIND"]
    val http2_method_uncheckout: string [@@js.global "HTTP2_METHOD_UNCHECKOUT"]
    val http2_method_unlink: string [@@js.global "HTTP2_METHOD_UNLINK"]
    val http2_method_unlock: string [@@js.global "HTTP2_METHOD_UNLOCK"]
    val http2_method_update: string [@@js.global "HTTP2_METHOD_UPDATE"]
    val http2_method_updateredirectref: string [@@js.global "HTTP2_METHOD_UPDATEREDIRECTREF"]
    val http2_method_version_control: string [@@js.global "HTTP2_METHOD_VERSION_CONTROL"]
    val http_status_continue: float [@@js.global "HTTP_STATUS_CONTINUE"]
    val http_status_switching_protocols: float [@@js.global "HTTP_STATUS_SWITCHING_PROTOCOLS"]
    val http_status_processing: float [@@js.global "HTTP_STATUS_PROCESSING"]
    val http_status_ok: float [@@js.global "HTTP_STATUS_OK"]
    val http_status_created: float [@@js.global "HTTP_STATUS_CREATED"]
    val http_status_accepted: float [@@js.global "HTTP_STATUS_ACCEPTED"]
    val http_status_non_authoritative_information: float [@@js.global "HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION"]
    val http_status_no_content: float [@@js.global "HTTP_STATUS_NO_CONTENT"]
    val http_status_reset_content: float [@@js.global "HTTP_STATUS_RESET_CONTENT"]
    val http_status_partial_content: float [@@js.global "HTTP_STATUS_PARTIAL_CONTENT"]
    val http_status_multi_status: float [@@js.global "HTTP_STATUS_MULTI_STATUS"]
    val http_status_already_reported: float [@@js.global "HTTP_STATUS_ALREADY_REPORTED"]
    val http_status_im_used: float [@@js.global "HTTP_STATUS_IM_USED"]
    val http_status_multiple_choices: float [@@js.global "HTTP_STATUS_MULTIPLE_CHOICES"]
    val http_status_moved_permanently: float [@@js.global "HTTP_STATUS_MOVED_PERMANENTLY"]
    val http_status_found: float [@@js.global "HTTP_STATUS_FOUND"]
    val http_status_see_other: float [@@js.global "HTTP_STATUS_SEE_OTHER"]
    val http_status_not_modified: float [@@js.global "HTTP_STATUS_NOT_MODIFIED"]
    val http_status_use_proxy: float [@@js.global "HTTP_STATUS_USE_PROXY"]
    val http_status_temporary_redirect: float [@@js.global "HTTP_STATUS_TEMPORARY_REDIRECT"]
    val http_status_permanent_redirect: float [@@js.global "HTTP_STATUS_PERMANENT_REDIRECT"]
    val http_status_bad_request: float [@@js.global "HTTP_STATUS_BAD_REQUEST"]
    val http_status_unauthorized: float [@@js.global "HTTP_STATUS_UNAUTHORIZED"]
    val http_status_payment_required: float [@@js.global "HTTP_STATUS_PAYMENT_REQUIRED"]
    val http_status_forbidden: float [@@js.global "HTTP_STATUS_FORBIDDEN"]
    val http_status_not_found: float [@@js.global "HTTP_STATUS_NOT_FOUND"]
    val http_status_method_not_allowed: float [@@js.global "HTTP_STATUS_METHOD_NOT_ALLOWED"]
    val http_status_not_acceptable: float [@@js.global "HTTP_STATUS_NOT_ACCEPTABLE"]
    val http_status_proxy_authentication_required: float [@@js.global "HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED"]
    val http_status_request_timeout: float [@@js.global "HTTP_STATUS_REQUEST_TIMEOUT"]
    val http_status_conflict: float [@@js.global "HTTP_STATUS_CONFLICT"]
    val http_status_gone: float [@@js.global "HTTP_STATUS_GONE"]
    val http_status_length_required: float [@@js.global "HTTP_STATUS_LENGTH_REQUIRED"]
    val http_status_precondition_failed: float [@@js.global "HTTP_STATUS_PRECONDITION_FAILED"]
    val http_status_payload_too_large: float [@@js.global "HTTP_STATUS_PAYLOAD_TOO_LARGE"]
    val http_status_uri_too_long: float [@@js.global "HTTP_STATUS_URI_TOO_LONG"]
    val http_status_unsupported_media_type: float [@@js.global "HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE"]
    val http_status_range_not_satisfiable: float [@@js.global "HTTP_STATUS_RANGE_NOT_SATISFIABLE"]
    val http_status_expectation_failed: float [@@js.global "HTTP_STATUS_EXPECTATION_FAILED"]
    val http_status_teapot: float [@@js.global "HTTP_STATUS_TEAPOT"]
    val http_status_misdirected_request: float [@@js.global "HTTP_STATUS_MISDIRECTED_REQUEST"]
    val http_status_unprocessable_entity: float [@@js.global "HTTP_STATUS_UNPROCESSABLE_ENTITY"]
    val http_status_locked: float [@@js.global "HTTP_STATUS_LOCKED"]
    val http_status_failed_dependency: float [@@js.global "HTTP_STATUS_FAILED_DEPENDENCY"]
    val http_status_unordered_collection: float [@@js.global "HTTP_STATUS_UNORDERED_COLLECTION"]
    val http_status_upgrade_required: float [@@js.global "HTTP_STATUS_UPGRADE_REQUIRED"]
    val http_status_precondition_required: float [@@js.global "HTTP_STATUS_PRECONDITION_REQUIRED"]
    val http_status_too_many_requests: float [@@js.global "HTTP_STATUS_TOO_MANY_REQUESTS"]
    val http_status_request_header_fields_too_large: float [@@js.global "HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE"]
    val http_status_unavailable_for_legal_reasons: float [@@js.global "HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS"]
    val http_status_internal_server_error: float [@@js.global "HTTP_STATUS_INTERNAL_SERVER_ERROR"]
    val http_status_not_implemented: float [@@js.global "HTTP_STATUS_NOT_IMPLEMENTED"]
    val http_status_bad_gateway: float [@@js.global "HTTP_STATUS_BAD_GATEWAY"]
    val http_status_service_unavailable: float [@@js.global "HTTP_STATUS_SERVICE_UNAVAILABLE"]
    val http_status_gateway_timeout: float [@@js.global "HTTP_STATUS_GATEWAY_TIMEOUT"]
    val http_status_http_version_not_supported: float [@@js.global "HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED"]
    val http_status_variant_also_negotiates: float [@@js.global "HTTP_STATUS_VARIANT_ALSO_NEGOTIATES"]
    val http_status_insufficient_storage: float [@@js.global "HTTP_STATUS_INSUFFICIENT_STORAGE"]
    val http_status_loop_detected: float [@@js.global "HTTP_STATUS_LOOP_DETECTED"]
    val http_status_bandwidth_limit_exceeded: float [@@js.global "HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED"]
    val http_status_not_extended: float [@@js.global "HTTP_STATUS_NOT_EXTENDED"]
    val http_status_network_authentication_required: float [@@js.global "HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED"]
  end
  val getDefaultSettings: unit -> http2_Settings [@@js.global "getDefaultSettings"]
  val getPackedSettings: settings:http2_Settings -> _Buffer [@@js.global "getPackedSettings"]
  val getUnpackedSettings: buf:Uint8Array.t_0 -> http2_Settings [@@js.global "getUnpackedSettings"]
  val createServer: ?onRequestHandler:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> unit -> http2_Http2Server [@@js.global "createServer"]
  val createServer: options:http2_ServerOptions -> ?onRequestHandler:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> unit -> http2_Http2Server [@@js.global "createServer"]
  val createSecureServer: ?onRequestHandler:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> unit -> http2_Http2SecureServer [@@js.global "createSecureServer"]
  val createSecureServer: options:http2_SecureServerOptions -> ?onRequestHandler:(request:http2_Http2ServerRequest -> response:http2_Http2ServerResponse -> unit) -> unit -> http2_Http2SecureServer [@@js.global "createSecureServer"]
  val connect: authority:url_URL or_string -> listener:(session:http2_ClientHttp2Session -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> http2_ClientHttp2Session [@@js.global "connect"]
  val connect: authority:url_URL or_string -> ?options:([`U_s229_http_ of (http2_ClientSessionOptions, http2_SecureClientSessionOptions) union2  | `U_s230_https_ of (http2_ClientSessionOptions, http2_SecureClientSessionOptions) union2 ] [@js.union on_field "protocol"]) -> ?listener:(session:http2_ClientHttp2Session -> socket:(net_Socket, tls_TLSSocket) union2 -> unit) -> unit -> http2_ClientHttp2Session [@@js.global "connect"]
end
module Node_http : sig
  (* export * from 'http'; *)
end
module[@js.scope "http"] Http : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/http.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:url
    clause = ES6Import ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/http.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = ES6Import ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/http.d.ts } *)
  module[@js.scope "IncomingHttpHeaders"] IncomingHttpHeaders : sig
    type t = http_IncomingHttpHeaders
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_accept: t -> string [@@js.get "accept"]
    val set_accept: t -> string -> unit [@@js.set "accept"]
    val get_accept_language: t -> string [@@js.get "accept-language"]
    val set_accept_language: t -> string -> unit [@@js.set "accept-language"]
    val get_accept_patch: t -> string [@@js.get "accept-patch"]
    val set_accept_patch: t -> string -> unit [@@js.set "accept-patch"]
    val get_accept_ranges: t -> string [@@js.get "accept-ranges"]
    val set_accept_ranges: t -> string -> unit [@@js.set "accept-ranges"]
    val get_access_control_allow_credentials: t -> string [@@js.get "access-control-allow-credentials"]
    val set_access_control_allow_credentials: t -> string -> unit [@@js.set "access-control-allow-credentials"]
    val get_access_control_allow_headers: t -> string [@@js.get "access-control-allow-headers"]
    val set_access_control_allow_headers: t -> string -> unit [@@js.set "access-control-allow-headers"]
    val get_access_control_allow_methods: t -> string [@@js.get "access-control-allow-methods"]
    val set_access_control_allow_methods: t -> string -> unit [@@js.set "access-control-allow-methods"]
    val get_access_control_allow_origin: t -> string [@@js.get "access-control-allow-origin"]
    val set_access_control_allow_origin: t -> string -> unit [@@js.set "access-control-allow-origin"]
    val get_access_control_expose_headers: t -> string [@@js.get "access-control-expose-headers"]
    val set_access_control_expose_headers: t -> string -> unit [@@js.set "access-control-expose-headers"]
    val get_access_control_max_age: t -> string [@@js.get "access-control-max-age"]
    val set_access_control_max_age: t -> string -> unit [@@js.set "access-control-max-age"]
    val get_access_control_request_headers: t -> string [@@js.get "access-control-request-headers"]
    val set_access_control_request_headers: t -> string -> unit [@@js.set "access-control-request-headers"]
    val get_access_control_request_method: t -> string [@@js.get "access-control-request-method"]
    val set_access_control_request_method: t -> string -> unit [@@js.set "access-control-request-method"]
    val get_age: t -> string [@@js.get "age"]
    val set_age: t -> string -> unit [@@js.set "age"]
    val get_allow: t -> string [@@js.get "allow"]
    val set_allow: t -> string -> unit [@@js.set "allow"]
    val get_alt_svc: t -> string [@@js.get "alt-svc"]
    val set_alt_svc: t -> string -> unit [@@js.set "alt-svc"]
    val get_authorization: t -> string [@@js.get "authorization"]
    val set_authorization: t -> string -> unit [@@js.set "authorization"]
    val get_cache_control: t -> string [@@js.get "cache-control"]
    val set_cache_control: t -> string -> unit [@@js.set "cache-control"]
    val get_connection: t -> string [@@js.get "connection"]
    val set_connection: t -> string -> unit [@@js.set "connection"]
    val get_content_disposition: t -> string [@@js.get "content-disposition"]
    val set_content_disposition: t -> string -> unit [@@js.set "content-disposition"]
    val get_content_encoding: t -> string [@@js.get "content-encoding"]
    val set_content_encoding: t -> string -> unit [@@js.set "content-encoding"]
    val get_content_language: t -> string [@@js.get "content-language"]
    val set_content_language: t -> string -> unit [@@js.set "content-language"]
    val get_content_length: t -> string [@@js.get "content-length"]
    val set_content_length: t -> string -> unit [@@js.set "content-length"]
    val get_content_location: t -> string [@@js.get "content-location"]
    val set_content_location: t -> string -> unit [@@js.set "content-location"]
    val get_content_range: t -> string [@@js.get "content-range"]
    val set_content_range: t -> string -> unit [@@js.set "content-range"]
    val get_content_type: t -> string [@@js.get "content-type"]
    val set_content_type: t -> string -> unit [@@js.set "content-type"]
    val get_cookie: t -> string [@@js.get "cookie"]
    val set_cookie: t -> string -> unit [@@js.set "cookie"]
    val get_date: t -> string [@@js.get "date"]
    val set_date: t -> string -> unit [@@js.set "date"]
    val get_etag: t -> string [@@js.get "etag"]
    val set_etag: t -> string -> unit [@@js.set "etag"]
    val get_expect: t -> string [@@js.get "expect"]
    val set_expect: t -> string -> unit [@@js.set "expect"]
    val get_expires: t -> string [@@js.get "expires"]
    val set_expires: t -> string -> unit [@@js.set "expires"]
    val get_forwarded: t -> string [@@js.get "forwarded"]
    val set_forwarded: t -> string -> unit [@@js.set "forwarded"]
    val get_from: t -> string [@@js.get "from"]
    val set_from: t -> string -> unit [@@js.set "from"]
    val get_host: t -> string [@@js.get "host"]
    val set_host: t -> string -> unit [@@js.set "host"]
    val get_if_match: t -> string [@@js.get "if-match"]
    val set_if_match: t -> string -> unit [@@js.set "if-match"]
    val get_if_modified_since: t -> string [@@js.get "if-modified-since"]
    val set_if_modified_since: t -> string -> unit [@@js.set "if-modified-since"]
    val get_if_none_match: t -> string [@@js.get "if-none-match"]
    val set_if_none_match: t -> string -> unit [@@js.set "if-none-match"]
    val get_if_unmodified_since: t -> string [@@js.get "if-unmodified-since"]
    val set_if_unmodified_since: t -> string -> unit [@@js.set "if-unmodified-since"]
    val get_last_modified: t -> string [@@js.get "last-modified"]
    val set_last_modified: t -> string -> unit [@@js.set "last-modified"]
    val get_location: t -> string [@@js.get "location"]
    val set_location: t -> string -> unit [@@js.set "location"]
    val get_origin: t -> string [@@js.get "origin"]
    val set_origin: t -> string -> unit [@@js.set "origin"]
    val get_pragma: t -> string [@@js.get "pragma"]
    val set_pragma: t -> string -> unit [@@js.set "pragma"]
    val get_proxy_authenticate: t -> string [@@js.get "proxy-authenticate"]
    val set_proxy_authenticate: t -> string -> unit [@@js.set "proxy-authenticate"]
    val get_proxy_authorization: t -> string [@@js.get "proxy-authorization"]
    val set_proxy_authorization: t -> string -> unit [@@js.set "proxy-authorization"]
    val get_public_key_pins: t -> string [@@js.get "public-key-pins"]
    val set_public_key_pins: t -> string -> unit [@@js.set "public-key-pins"]
    val get_range: t -> string [@@js.get "range"]
    val set_range: t -> string -> unit [@@js.set "range"]
    val get_referer: t -> string [@@js.get "referer"]
    val set_referer: t -> string -> unit [@@js.set "referer"]
    val get_retry_after: t -> string [@@js.get "retry-after"]
    val set_retry_after: t -> string -> unit [@@js.set "retry-after"]
    val get_sec_websocket_accept: t -> string [@@js.get "sec-websocket-accept"]
    val set_sec_websocket_accept: t -> string -> unit [@@js.set "sec-websocket-accept"]
    val get_sec_websocket_extensions: t -> string [@@js.get "sec-websocket-extensions"]
    val set_sec_websocket_extensions: t -> string -> unit [@@js.set "sec-websocket-extensions"]
    val get_sec_websocket_key: t -> string [@@js.get "sec-websocket-key"]
    val set_sec_websocket_key: t -> string -> unit [@@js.set "sec-websocket-key"]
    val get_sec_websocket_protocol: t -> string [@@js.get "sec-websocket-protocol"]
    val set_sec_websocket_protocol: t -> string -> unit [@@js.set "sec-websocket-protocol"]
    val get_sec_websocket_version: t -> string [@@js.get "sec-websocket-version"]
    val set_sec_websocket_version: t -> string -> unit [@@js.set "sec-websocket-version"]
    val get_set_cookie: t -> string list [@@js.get "set-cookie"]
    val set_set_cookie: t -> string list -> unit [@@js.set "set-cookie"]
    val get_strict_transport_security: t -> string [@@js.get "strict-transport-security"]
    val set_strict_transport_security: t -> string -> unit [@@js.set "strict-transport-security"]
    val get_tk: t -> string [@@js.get "tk"]
    val set_tk: t -> string -> unit [@@js.set "tk"]
    val get_trailer: t -> string [@@js.get "trailer"]
    val set_trailer: t -> string -> unit [@@js.set "trailer"]
    val get_transfer_encoding: t -> string [@@js.get "transfer-encoding"]
    val set_transfer_encoding: t -> string -> unit [@@js.set "transfer-encoding"]
    val get_upgrade: t -> string [@@js.get "upgrade"]
    val set_upgrade: t -> string -> unit [@@js.set "upgrade"]
    val get_user_agent: t -> string [@@js.get "user-agent"]
    val set_user_agent: t -> string -> unit [@@js.set "user-agent"]
    val get_vary: t -> string [@@js.get "vary"]
    val set_vary: t -> string -> unit [@@js.set "vary"]
    val get_via: t -> string [@@js.get "via"]
    val set_via: t -> string -> unit [@@js.set "via"]
    val get_warning: t -> string [@@js.get "warning"]
    val set_warning: t -> string -> unit [@@js.set "warning"]
    val get_www_authenticate: t -> string [@@js.get "www-authenticate"]
    val set_www_authenticate: t -> string -> unit [@@js.set "www-authenticate"]
    val cast: t -> string list or_string _NodeJS_Dict [@@js.cast]
  end
  module OutgoingHttpHeader : sig
    type t = http_OutgoingHttpHeader
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "OutgoingHttpHeaders"] OutgoingHttpHeaders : sig
    type t = http_OutgoingHttpHeaders
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> http_OutgoingHttpHeader _NodeJS_Dict [@@js.cast]
  end
  module[@js.scope "ClientRequestArgs"] ClientRequestArgs : sig
    type t = http_ClientRequestArgs
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_protocol: t -> string or_null [@@js.get "protocol"]
    val set_protocol: t -> string or_null -> unit [@@js.set "protocol"]
    val get_host: t -> string or_null [@@js.get "host"]
    val set_host: t -> string or_null -> unit [@@js.set "host"]
    val get_hostname: t -> string or_null [@@js.get "hostname"]
    val set_hostname: t -> string or_null -> unit [@@js.set "hostname"]
    val get_family: t -> float [@@js.get "family"]
    val set_family: t -> float -> unit [@@js.set "family"]
    val get_port: t -> string or_number or_null [@@js.get "port"]
    val set_port: t -> string or_number or_null -> unit [@@js.set "port"]
    val get_defaultPort: t -> string or_number [@@js.get "defaultPort"]
    val set_defaultPort: t -> string or_number -> unit [@@js.set "defaultPort"]
    val get_localAddress: t -> string [@@js.get "localAddress"]
    val set_localAddress: t -> string -> unit [@@js.set "localAddress"]
    val get_socketPath: t -> string [@@js.get "socketPath"]
    val set_socketPath: t -> string -> unit [@@js.set "socketPath"]
    (** default: 8192 *)
    (** default: 8192 *)
    val get_maxHeaderSize: t -> float [@@js.get "maxHeaderSize"]
    (** default: 8192 *)
    val set_maxHeaderSize: t -> float -> unit [@@js.set "maxHeaderSize"]
    val get_method: t -> string [@@js.get "method"]
    val set_method: t -> string -> unit [@@js.set "method"]
    val get_path: t -> string or_null [@@js.get "path"]
    val set_path: t -> string or_null -> unit [@@js.set "path"]
    val get_headers: t -> http_OutgoingHttpHeaders [@@js.get "headers"]
    val set_headers: t -> http_OutgoingHttpHeaders -> unit [@@js.set "headers"]
    val get_auth: t -> string or_null [@@js.get "auth"]
    val set_auth: t -> string or_null -> unit [@@js.set "auth"]
    val get_agent: t -> http_Agent or_boolean [@@js.get "agent"]
    val set_agent: t -> http_Agent or_boolean -> unit [@@js.set "agent"]
    val get__defaultAgent: t -> http_Agent [@@js.get "_defaultAgent"]
    val set__defaultAgent: t -> http_Agent -> unit [@@js.set "_defaultAgent"]
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    val get_setHost: t -> bool [@@js.get "setHost"]
    val set_setHost: t -> bool -> unit [@@js.set "setHost"]
    val createConnection: t -> options:t -> oncreate:(err:Error.t_0 -> socket:Socket.t_0 -> unit) -> Socket.t_0 [@@js.call "createConnection"]
  end
  module[@js.scope "ServerOptions"] ServerOptions : sig
    type t = http_ServerOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_IncomingMessage: t -> (* FIXME: unknown type 'typeof IncomingMessage' *)any [@@js.get "IncomingMessage"]
    val set_IncomingMessage: t -> (* FIXME: unknown type 'typeof IncomingMessage' *)any -> unit [@@js.set "IncomingMessage"]
    val get_ServerResponse: t -> (* FIXME: unknown type 'typeof ServerResponse' *)any [@@js.get "ServerResponse"]
    val set_ServerResponse: t -> (* FIXME: unknown type 'typeof ServerResponse' *)any -> unit [@@js.set "ServerResponse"]
    (**
      Optionally overrides the value of
      \[`--max-http-header-size`\]\[\] for requests received by this server, i.e.
      the maximum length of request headers in bytes.
      default: 8192
    *)
    (**
      Optionally overrides the value of
      \[`--max-http-header-size`\]\[\] for requests received by this server, i.e.
      the maximum length of request headers in bytes.
      default: 8192
    *)
    val get_maxHeaderSize: t -> float [@@js.get "maxHeaderSize"]
    (**
      Optionally overrides the value of
      \[`--max-http-header-size`\]\[\] for requests received by this server, i.e.
      the maximum length of request headers in bytes.
      default: 8192
    *)
    val set_maxHeaderSize: t -> float -> unit [@@js.set "maxHeaderSize"]
    (**
      Use an insecure HTTP parser that accepts invalid HTTP headers when true.
      Using the insecure parser should be avoided.
      See --insecure-http-parser for more information.
      default: false
    *)
    (**
      Use an insecure HTTP parser that accepts invalid HTTP headers when true.
      Using the insecure parser should be avoided.
      See --insecure-http-parser for more information.
      default: false
    *)
    val get_insecureHTTPParser: t -> bool [@@js.get "insecureHTTPParser"]
    (**
      Use an insecure HTTP parser that accepts invalid HTTP headers when true.
      Using the insecure parser should be avoided.
      See --insecure-http-parser for more information.
      default: false
    *)
    val set_insecureHTTPParser: t -> bool -> unit [@@js.set "insecureHTTPParser"]
  end
  module[@js.scope "RequestListener"] RequestListener : sig
    type t = http_RequestListener
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> req:http_IncomingMessage -> res:http_ServerResponse -> unit [@@js.apply]
  end
  module[@js.scope "HttpBase"] HttpBase : sig
    type t = http_HttpBase
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val setTimeout: t -> ?msecs:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    val setTimeout': t -> callback:(unit -> unit) -> t [@@js.call "setTimeout"]
    (**
      Limits maximum incoming headers count. If set to 0, no limit will be applied.
      default: 2000
      \{\@link https://nodejs.org/api/http.html#http_server_maxheaderscount\}
    *)
    (**
      Limits maximum incoming headers count. If set to 0, no limit will be applied.
      default: 2000
      \{\@link https://nodejs.org/api/http.html#http_server_maxheaderscount\}
    *)
    val get_maxHeadersCount: t -> float or_null [@@js.get "maxHeadersCount"]
    (**
      Limits maximum incoming headers count. If set to 0, no limit will be applied.
      default: 2000
      \{\@link https://nodejs.org/api/http.html#http_server_maxheaderscount\}
    *)
    val set_maxHeadersCount: t -> float or_null -> unit [@@js.set "maxHeadersCount"]
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    (**
      Limit the amount of time the parser will wait to receive the complete HTTP headers.
      default: 60000
      \{\@link https://nodejs.org/api/http.html#http_server_headerstimeout\}
    *)
    (**
      Limit the amount of time the parser will wait to receive the complete HTTP headers.
      default: 60000
      \{\@link https://nodejs.org/api/http.html#http_server_headerstimeout\}
    *)
    val get_headersTimeout: t -> float [@@js.get "headersTimeout"]
    (**
      Limit the amount of time the parser will wait to receive the complete HTTP headers.
      default: 60000
      \{\@link https://nodejs.org/api/http.html#http_server_headerstimeout\}
    *)
    val set_headersTimeout: t -> float -> unit [@@js.set "headersTimeout"]
    val get_keepAliveTimeout: t -> float [@@js.get "keepAliveTimeout"]
    val set_keepAliveTimeout: t -> float -> unit [@@js.set "keepAliveTimeout"]
    (**
      Sets the timeout value in milliseconds for receiving the entire request from the client.
      default: 0
      \{\@link https://nodejs.org/api/http.html#http_server_requesttimeout\}
    *)
    (**
      Sets the timeout value in milliseconds for receiving the entire request from the client.
      default: 0
      \{\@link https://nodejs.org/api/http.html#http_server_requesttimeout\}
    *)
    val get_requestTimeout: t -> float [@@js.get "requestTimeout"]
    (**
      Sets the timeout value in milliseconds for receiving the entire request from the client.
      default: 0
      \{\@link https://nodejs.org/api/http.html#http_server_requesttimeout\}
    *)
    val set_requestTimeout: t -> float -> unit [@@js.set "requestTimeout"]
  end
  module[@js.scope "Server"] Server : sig
    type t = http_Server
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?requestListener:http_RequestListener -> unit -> t [@@js.create]
    val create': options:http_ServerOptions -> ?requestListener:http_RequestListener -> unit -> t [@@js.create]
    val cast: t -> NetServer.t_0 [@@js.cast]
    val cast': t -> http_HttpBase [@@js.cast]
  end
  module[@js.scope "OutgoingMessage"] OutgoingMessage : sig
    type t = http_OutgoingMessage
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_upgrading: t -> bool [@@js.get "upgrading"]
    val set_upgrading: t -> bool -> unit [@@js.set "upgrading"]
    val get_chunkedEncoding: t -> bool [@@js.get "chunkedEncoding"]
    val set_chunkedEncoding: t -> bool -> unit [@@js.set "chunkedEncoding"]
    val get_shouldKeepAlive: t -> bool [@@js.get "shouldKeepAlive"]
    val set_shouldKeepAlive: t -> bool -> unit [@@js.set "shouldKeepAlive"]
    val get_useChunkedEncodingByDefault: t -> bool [@@js.get "useChunkedEncodingByDefault"]
    val set_useChunkedEncodingByDefault: t -> bool -> unit [@@js.set "useChunkedEncodingByDefault"]
    val get_sendDate: t -> bool [@@js.get "sendDate"]
    val set_sendDate: t -> bool -> unit [@@js.set "sendDate"]
    (** @deprecated Use `writableEnded` instead. *)
    (** @deprecated Use `writableEnded` instead. *)
    val get_finished: t -> bool [@@js.get "finished"]
    (** @deprecated Use `writableEnded` instead. *)
    val set_finished: t -> bool -> unit [@@js.set "finished"]
    val get_headersSent: t -> bool [@@js.get "headersSent"]
    val set_headersSent: t -> bool -> unit [@@js.set "headersSent"]
    (** deprecate: Use `socket` instead. *)
    (** deprecate: Use `socket` instead. *)
    val get_connection: t -> Socket.t_0 or_null [@@js.get "connection"]
    (** deprecate: Use `socket` instead. *)
    val set_connection: t -> Socket.t_0 or_null -> unit [@@js.set "connection"]
    val get_socket: t -> Socket.t_0 or_null [@@js.get "socket"]
    val set_socket: t -> Socket.t_0 or_null -> unit [@@js.set "socket"]
    val create: unit -> t [@@js.create]
    val setTimeout: t -> msecs:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    val setHeader: t -> name:string -> value:string list or_string or_number -> unit [@@js.call "setHeader"]
    val getHeader: t -> name:string -> string list or_string or_number or_undefined [@@js.call "getHeader"]
    val getHeaders: t -> http_OutgoingHttpHeaders [@@js.call "getHeaders"]
    val getHeaderNames: t -> string list [@@js.call "getHeaderNames"]
    val hasHeader: t -> name:string -> bool [@@js.call "hasHeader"]
    val removeHeader: t -> name:string -> unit [@@js.call "removeHeader"]
    val addTrailers: t -> headers:(http_OutgoingHttpHeaders, (string * string) list) union2 -> unit [@@js.call "addTrailers"]
    val flushHeaders: t -> unit [@@js.call "flushHeaders"]
    val cast: t -> Stream.Writable.t_0 [@@js.cast]
  end
  module[@js.scope "ServerResponse"] ServerResponse : sig
    type t = http_ServerResponse
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_statusCode: t -> float [@@js.get "statusCode"]
    val set_statusCode: t -> float -> unit [@@js.set "statusCode"]
    val get_statusMessage: t -> string [@@js.get "statusMessage"]
    val set_statusMessage: t -> string -> unit [@@js.set "statusMessage"]
    val create: req:http_IncomingMessage -> t [@@js.create]
    val assignSocket: t -> socket:Socket.t_0 -> unit [@@js.call "assignSocket"]
    val detachSocket: t -> socket:Socket.t_0 -> unit [@@js.call "detachSocket"]
    val writeContinue: t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "writeContinue"]
    val writeHead: t -> statusCode:float -> ?reasonPhrase:string -> ?headers:(http_OutgoingHttpHeaders, http_OutgoingHttpHeader) or_array -> unit -> t [@@js.call "writeHead"]
    val writeHead': t -> statusCode:float -> ?headers:(http_OutgoingHttpHeaders, http_OutgoingHttpHeader) or_array -> unit -> t [@@js.call "writeHead"]
    val writeProcessing: t -> unit [@@js.call "writeProcessing"]
    val cast: t -> http_OutgoingMessage [@@js.cast]
  end
  module[@js.scope "InformationEvent"] InformationEvent : sig
    type t = http_InformationEvent
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_statusCode: t -> float [@@js.get "statusCode"]
    val set_statusCode: t -> float -> unit [@@js.set "statusCode"]
    val get_statusMessage: t -> string [@@js.get "statusMessage"]
    val set_statusMessage: t -> string -> unit [@@js.set "statusMessage"]
    val get_httpVersion: t -> string [@@js.get "httpVersion"]
    val set_httpVersion: t -> string -> unit [@@js.set "httpVersion"]
    val get_httpVersionMajor: t -> float [@@js.get "httpVersionMajor"]
    val set_httpVersionMajor: t -> float -> unit [@@js.set "httpVersionMajor"]
    val get_httpVersionMinor: t -> float [@@js.get "httpVersionMinor"]
    val set_httpVersionMinor: t -> float -> unit [@@js.set "httpVersionMinor"]
    val get_headers: t -> http_IncomingHttpHeaders [@@js.get "headers"]
    val set_headers: t -> http_IncomingHttpHeaders -> unit [@@js.set "headers"]
    val get_rawHeaders: t -> string list [@@js.get "rawHeaders"]
    val set_rawHeaders: t -> string list -> unit [@@js.set "rawHeaders"]
  end
  module[@js.scope "ClientRequest"] ClientRequest : sig
    type t = http_ClientRequest
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_aborted: t -> bool [@@js.get "aborted"]
    val set_aborted: t -> bool -> unit [@@js.set "aborted"]
    val get_host: t -> string [@@js.get "host"]
    val set_host: t -> string -> unit [@@js.set "host"]
    val get_protocol: t -> string [@@js.get "protocol"]
    val set_protocol: t -> string -> unit [@@js.set "protocol"]
    val create: url:(http_ClientRequestArgs, URL.t_0) union2 or_string -> ?cb:(res:http_IncomingMessage -> unit) -> unit -> t [@@js.create]
    val get_method: t -> string [@@js.get "method"]
    val set_method: t -> string -> unit [@@js.set "method"]
    val get_path: t -> string [@@js.get "path"]
    val set_path: t -> string -> unit [@@js.set "path"]
    (** @deprecated since v14.1.0 Use `request.destroy()` instead. *)
    val abort: t -> unit [@@js.call "abort"]
    val onSocket: t -> socket:Socket.t_0 -> unit [@@js.call "onSocket"]
    val setTimeout: t -> timeout:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    val setNoDelay: t -> ?noDelay:bool -> unit -> unit [@@js.call "setNoDelay"]
    val setSocketKeepAlive: t -> ?enable:bool -> ?initialDelay:float -> unit -> unit [@@js.call "setSocketKeepAlive"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener: t -> event:([`L_s166_abort] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'': t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''': t -> event:([`L_s235_information] [@js.enum]) -> listener:(info:http_InformationEvent -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(response:http_IncomingMessage -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''': t -> event:([`L_s301_socket] [@js.enum]) -> listener:(socket:Socket.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''''': t -> event:([`L_s326_upgrade] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''''''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''''''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener''''''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. drain
      3. error
      4. finish
      5. pipe
      6. unpipe
    *)
    val addListener'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val on: t -> event:([`L_s166_abort] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s235_information] [@js.enum]) -> listener:(info:http_InformationEvent -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(response:http_IncomingMessage -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s301_socket] [@js.enum]) -> listener:(socket:Socket.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s326_upgrade] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''''''''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on''''''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "on"]
    val on'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s166_abort] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s235_information] [@js.enum]) -> listener:(info:http_InformationEvent -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(response:http_IncomingMessage -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s301_socket] [@js.enum]) -> listener:(socket:Socket.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s326_upgrade] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''''''''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once''''''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "once"]
    val once'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s166_abort] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s235_information] [@js.enum]) -> listener:(info:http_InformationEvent -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(response:http_IncomingMessage -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s301_socket] [@js.enum]) -> listener:(socket:Socket.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s326_upgrade] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s166_abort] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s195_continue] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s235_information] [@js.enum]) -> listener:(info:http_InformationEvent -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s289_response] [@js.enum]) -> listener:(response:http_IncomingMessage -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s301_socket] [@js.enum]) -> listener:(socket:Socket.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s326_upgrade] [@js.enum]) -> listener:(response:http_IncomingMessage -> socket:Socket.t_0 -> head:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''''''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:Stream.Readable.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> http_OutgoingMessage [@@js.cast]
  end
  module[@js.scope "IncomingMessage"] IncomingMessage : sig
    type t = http_IncomingMessage
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: socket:Socket.t_0 -> t [@@js.create]
    val get_aborted: t -> bool [@@js.get "aborted"]
    val set_aborted: t -> bool -> unit [@@js.set "aborted"]
    val get_httpVersion: t -> string [@@js.get "httpVersion"]
    val set_httpVersion: t -> string -> unit [@@js.set "httpVersion"]
    val get_httpVersionMajor: t -> float [@@js.get "httpVersionMajor"]
    val set_httpVersionMajor: t -> float -> unit [@@js.set "httpVersionMajor"]
    val get_httpVersionMinor: t -> float [@@js.get "httpVersionMinor"]
    val set_httpVersionMinor: t -> float -> unit [@@js.set "httpVersionMinor"]
    val get_complete: t -> bool [@@js.get "complete"]
    val set_complete: t -> bool -> unit [@@js.set "complete"]
    (** @deprecated since v13.0.0 - Use `socket` instead. *)
    (** @deprecated since v13.0.0 - Use `socket` instead. *)
    val get_connection: t -> Socket.t_0 [@@js.get "connection"]
    (** @deprecated since v13.0.0 - Use `socket` instead. *)
    val set_connection: t -> Socket.t_0 -> unit [@@js.set "connection"]
    val get_socket: t -> Socket.t_0 [@@js.get "socket"]
    val set_socket: t -> Socket.t_0 -> unit [@@js.set "socket"]
    val get_headers: t -> http_IncomingHttpHeaders [@@js.get "headers"]
    val set_headers: t -> http_IncomingHttpHeaders -> unit [@@js.set "headers"]
    val get_rawHeaders: t -> string list [@@js.get "rawHeaders"]
    val set_rawHeaders: t -> string list -> unit [@@js.set "rawHeaders"]
    val get_trailers: t -> string _NodeJS_Dict [@@js.get "trailers"]
    val set_trailers: t -> string _NodeJS_Dict -> unit [@@js.set "trailers"]
    val get_rawTrailers: t -> string list [@@js.get "rawTrailers"]
    val set_rawTrailers: t -> string list -> unit [@@js.set "rawTrailers"]
    val setTimeout: t -> msecs:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    (** Only valid for request obtained from http.Server. *)
    (** Only valid for request obtained from http.Server. *)
    val get_method: t -> string [@@js.get "method"]
    (** Only valid for request obtained from http.Server. *)
    val set_method: t -> string -> unit [@@js.set "method"]
    (** Only valid for request obtained from http.Server. *)
    (** Only valid for request obtained from http.Server. *)
    val get_url: t -> string [@@js.get "url"]
    (** Only valid for request obtained from http.Server. *)
    val set_url: t -> string -> unit [@@js.set "url"]
    (** Only valid for response obtained from http.ClientRequest. *)
    (** Only valid for response obtained from http.ClientRequest. *)
    val get_statusCode: t -> float [@@js.get "statusCode"]
    (** Only valid for response obtained from http.ClientRequest. *)
    val set_statusCode: t -> float -> unit [@@js.set "statusCode"]
    (** Only valid for response obtained from http.ClientRequest. *)
    (** Only valid for response obtained from http.ClientRequest. *)
    val get_statusMessage: t -> string [@@js.get "statusMessage"]
    (** Only valid for response obtained from http.ClientRequest. *)
    val set_statusMessage: t -> string -> unit [@@js.set "statusMessage"]
    val destroy: t -> ?error:Error.t_0 -> unit -> unit [@@js.call "destroy"]
    val cast: t -> Stream.Readable.t_0 [@@js.cast]
  end
  module[@js.scope "AgentOptions"] AgentOptions : sig
    type t = http_AgentOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Keep sockets around in a pool to be used by other requests in the future. Default = false *)
    (** Keep sockets around in a pool to be used by other requests in the future. Default = false *)
    val get_keepAlive: t -> bool [@@js.get "keepAlive"]
    (** Keep sockets around in a pool to be used by other requests in the future. Default = false *)
    val set_keepAlive: t -> bool -> unit [@@js.set "keepAlive"]
    (**
      When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
      Only relevant if keepAlive is set to true.
    *)
    (**
      When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
      Only relevant if keepAlive is set to true.
    *)
    val get_keepAliveMsecs: t -> float [@@js.get "keepAliveMsecs"]
    (**
      When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
      Only relevant if keepAlive is set to true.
    *)
    val set_keepAliveMsecs: t -> float -> unit [@@js.set "keepAliveMsecs"]
    (** Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity *)
    (** Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity *)
    val get_maxSockets: t -> float [@@js.get "maxSockets"]
    (** Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity *)
    val set_maxSockets: t -> float -> unit [@@js.set "maxSockets"]
    (** Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity. *)
    (** Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity. *)
    val get_maxTotalSockets: t -> float [@@js.get "maxTotalSockets"]
    (** Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity. *)
    val set_maxTotalSockets: t -> float -> unit [@@js.set "maxTotalSockets"]
    (** Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256. *)
    (** Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256. *)
    val get_maxFreeSockets: t -> float [@@js.get "maxFreeSockets"]
    (** Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256. *)
    val set_maxFreeSockets: t -> float -> unit [@@js.set "maxFreeSockets"]
    (** Socket timeout in milliseconds. This will set the timeout after the socket is connected. *)
    (** Socket timeout in milliseconds. This will set the timeout after the socket is connected. *)
    val get_timeout: t -> float [@@js.get "timeout"]
    (** Socket timeout in milliseconds. This will set the timeout after the socket is connected. *)
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    (** Scheduling strategy to apply when picking the next free socket to use. Default: 'fifo'. *)
    (** Scheduling strategy to apply when picking the next free socket to use. Default: 'fifo'. *)
    val get_scheduling: t -> ([`L_s215_fifo[@js "fifo"] | `L_s243_lifo[@js "lifo"]] [@js.enum]) [@@js.get "scheduling"]
    (** Scheduling strategy to apply when picking the next free socket to use. Default: 'fifo'. *)
    val set_scheduling: t -> ([`L_s215_fifo | `L_s243_lifo] [@js.enum]) -> unit [@@js.set "scheduling"]
  end
  module[@js.scope "Agent"] Agent : sig
    type t = http_Agent
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_maxFreeSockets: t -> float [@@js.get "maxFreeSockets"]
    val set_maxFreeSockets: t -> float -> unit [@@js.set "maxFreeSockets"]
    val get_maxSockets: t -> float [@@js.get "maxSockets"]
    val set_maxSockets: t -> float -> unit [@@js.set "maxSockets"]
    val get_maxTotalSockets: t -> float [@@js.get "maxTotalSockets"]
    val set_maxTotalSockets: t -> float -> unit [@@js.set "maxTotalSockets"]
    val get_freeSockets: t -> Socket.t_0 list _NodeJS_ReadOnlyDict [@@js.get "freeSockets"]
    val get_sockets: t -> Socket.t_0 list _NodeJS_ReadOnlyDict [@@js.get "sockets"]
    val get_requests: t -> http_IncomingMessage list _NodeJS_ReadOnlyDict [@@js.get "requests"]
    val create: ?opts:http_AgentOptions -> unit -> t [@@js.create]
    (**
      Destroy any sockets that are currently in use by the agent.
      It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled,
      then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise,
      sockets may hang open for quite a long time before the server terminates them.
    *)
    val destroy: t -> unit [@@js.call "destroy"]
  end
  val methods: string list [@@js.global "METHODS"]
  val status_codes: anonymous_interface_69 [@@js.global "STATUS_CODES"]
  val createServer: ?requestListener:http_RequestListener -> unit -> http_Server [@@js.global "createServer"]
  val createServer: options:http_ServerOptions -> ?requestListener:http_RequestListener -> unit -> http_Server [@@js.global "createServer"]
  module[@js.scope "RequestOptions"] RequestOptions : sig
    type t = http_RequestOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> http_ClientRequestArgs [@@js.cast]
  end
  val request: options:(http_RequestOptions, URL.t_0) union2 or_string -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "request"]
  val request: url:URL.t_0 or_string -> options:http_RequestOptions -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "request"]
  val get_: options:(http_RequestOptions, URL.t_0) union2 or_string -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "get"]
  val get_: url:URL.t_0 or_string -> options:http_RequestOptions -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "get"]
  val globalAgent: http_Agent [@@js.global "globalAgent"]
  (**
    Read-only property specifying the maximum allowed size of HTTP headers in bytes.
    Defaults to 16KB. Configurable using the \[`--max-http-header-size`\]\[\] CLI option.
  *)
  val maxHeaderSize: float [@@js.global "maxHeaderSize"]
end
module Node_https : sig
  (* export * from 'https'; *)
end
module[@js.scope "https"] Https : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:tls
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/https.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:http
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/https.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:url
    clause = ES6Import ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/https.d.ts } *)
  module ServerOptions : sig
    type t = https_ServerOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module RequestOptions : sig
    type t = https_RequestOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "AgentOptions"] AgentOptions : sig
    type t = https_AgentOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      If true the server will reject any connection which is not
      authorized with the list of supplied CAs. This option only has an
      effect if requestCert is true.
    *)
    (**
      If true the server will reject any connection which is not
      authorized with the list of supplied CAs. This option only has an
      effect if requestCert is true.
    *)
    val get_rejectUnauthorized: t -> bool [@@js.get "rejectUnauthorized"]
    (**
      If true the server will reject any connection which is not
      authorized with the list of supplied CAs. This option only has an
      effect if requestCert is true.
    *)
    val set_rejectUnauthorized: t -> bool -> unit [@@js.set "rejectUnauthorized"]
    val get_maxCachedSessions: t -> float [@@js.get "maxCachedSessions"]
    val set_maxCachedSessions: t -> float -> unit [@@js.set "maxCachedSessions"]
    val cast: t -> http_AgentOptions [@@js.cast]
    val cast': t -> tls_ConnectionOptions [@@js.cast]
  end
  module[@js.scope "Agent"] Agent : sig
    type t = https_Agent
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?options:https_AgentOptions -> unit -> t [@@js.create]
    val get_options: t -> https_AgentOptions [@@js.get "options"]
    val set_options: t -> https_AgentOptions -> unit [@@js.set "options"]
    val cast: t -> http_Agent [@@js.cast]
  end
  module[@js.scope "Server"] Server : sig
    type t = https_Server
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?requestListener:http_RequestListener -> unit -> t [@@js.create]
    val create': options:https_ServerOptions -> ?requestListener:http_RequestListener -> unit -> t [@@js.create]
    val cast: t -> tls_Server [@@js.cast]
    val cast': t -> http_HttpBase [@@js.cast]
  end
  val createServer: ?requestListener:http_RequestListener -> unit -> https_Server [@@js.global "createServer"]
  val createServer: options:https_ServerOptions -> ?requestListener:http_RequestListener -> unit -> https_Server [@@js.global "createServer"]
  val request: options:(https_RequestOptions, URL.t_0) union2 or_string -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "request"]
  val request: url:URL.t_0 or_string -> options:https_RequestOptions -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "request"]
  val get_: options:(https_RequestOptions, URL.t_0) union2 or_string -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "get"]
  val get_: url:URL.t_0 or_string -> options:https_RequestOptions -> ?callback:(res:http_IncomingMessage -> unit) -> unit -> http_ClientRequest [@@js.global "get"]
  val globalAgent: https_Agent [@@js.global "globalAgent"]
end
(** The inspector module provides an API for interacting with the V8 inspector. *)
module Node_inspector : sig
  (* export * from 'inspector'; *)
end
(** The inspector module provides an API for interacting with the V8 inspector. *)
module[@js.scope "inspector"] Inspector : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 21, col 5 of node_modules/@types/node/inspector.d.ts } *)
  module[@js.scope "InspectorNotification"] InspectorNotification : sig
    type 'T t = 'T inspector_InspectorNotification
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get_method: 'T t -> string [@@js.get "method"]
    val set_method: 'T t -> string -> unit [@@js.set "method"]
    val get_params: 'T t -> 'T [@@js.get "params"]
    val set_params: 'T t -> 'T -> unit [@@js.set "params"]
  end
  module[@js.scope "Schema"] Schema : sig
    (** Description of the protocol domain. *)
    module[@js.scope "Domain"] Domain : sig
      type t = inspector_Schema_Domain
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Domain name. *)
      (** Domain name. *)
      val get_name: t -> string [@@js.get "name"]
      (** Domain name. *)
      val set_name: t -> string -> unit [@@js.set "name"]
      (** Domain version. *)
      (** Domain version. *)
      val get_version: t -> string [@@js.get "version"]
      (** Domain version. *)
      val set_version: t -> string -> unit [@@js.set "version"]
    end
    module[@js.scope "GetDomainsReturnType"] GetDomainsReturnType : sig
      type t = inspector_Schema_GetDomainsReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** List of supported domains. *)
      (** List of supported domains. *)
      val get_domains: t -> inspector_Schema_Domain list [@@js.get "domains"]
      (** List of supported domains. *)
      val set_domains: t -> inspector_Schema_Domain list -> unit [@@js.set "domains"]
    end
  end
  module[@js.scope "Runtime"] Runtime : sig
    (** Unique script identifier. *)
    module ScriptId : sig
      type t = inspector_Runtime_ScriptId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Unique object identifier. *)
    module RemoteObjectId : sig
      type t = inspector_Runtime_RemoteObjectId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Primitive value which cannot be JSON-stringified. *)
    module UnserializableValue : sig
      type t = inspector_Runtime_UnserializableValue
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Mirror object referencing original JavaScript object. *)
    module[@js.scope "RemoteObject"] RemoteObject : sig
      type t = inspector_Runtime_RemoteObject
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Object type. *)
      (** Object type. *)
      val get_type: t -> string [@@js.get "type"]
      (** Object type. *)
      val set_type: t -> string -> unit [@@js.set "type"]
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      val get_subtype: t -> string [@@js.get "subtype"]
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      val set_subtype: t -> string -> unit [@@js.set "subtype"]
      (** Object class (constructor) name. Specified for <code>object</code> type values only. *)
      (** Object class (constructor) name. Specified for <code>object</code> type values only. *)
      val get_className: t -> string [@@js.get "className"]
      (** Object class (constructor) name. Specified for <code>object</code> type values only. *)
      val set_className: t -> string -> unit [@@js.set "className"]
      (** Remote object value in case of primitive values or JSON values (if it was requested). *)
      (** Remote object value in case of primitive values or JSON values (if it was requested). *)
      val get_value: t -> any [@@js.get "value"]
      (** Remote object value in case of primitive values or JSON values (if it was requested). *)
      val set_value: t -> any -> unit [@@js.set "value"]
      (** Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property. *)
      (** Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property. *)
      val get_unserializableValue: t -> inspector_Runtime_UnserializableValue [@@js.get "unserializableValue"]
      (** Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property. *)
      val set_unserializableValue: t -> inspector_Runtime_UnserializableValue -> unit [@@js.set "unserializableValue"]
      (** String representation of the object. *)
      (** String representation of the object. *)
      val get_description: t -> string [@@js.get "description"]
      (** String representation of the object. *)
      val set_description: t -> string -> unit [@@js.set "description"]
      (** Unique object identifier (for non-primitive values). *)
      (** Unique object identifier (for non-primitive values). *)
      val get_objectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "objectId"]
      (** Unique object identifier (for non-primitive values). *)
      val set_objectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "objectId"]
      (**
        Preview containing abbreviated property values. Specified for <code>object</code> type values only.
        experimental: 
      *)
      (**
        Preview containing abbreviated property values. Specified for <code>object</code> type values only.
        experimental: 
      *)
      val get_preview: t -> inspector_Runtime_ObjectPreview [@@js.get "preview"]
      (**
        Preview containing abbreviated property values. Specified for <code>object</code> type values only.
        experimental: 
      *)
      val set_preview: t -> inspector_Runtime_ObjectPreview -> unit [@@js.set "preview"]
      (** experimental:  *)
      (** experimental:  *)
      val get_customPreview: t -> inspector_Runtime_CustomPreview [@@js.get "customPreview"]
      (** experimental:  *)
      val set_customPreview: t -> inspector_Runtime_CustomPreview -> unit [@@js.set "customPreview"]
    end
    (** experimental:  *)
    module[@js.scope "CustomPreview"] CustomPreview : sig
      type t = inspector_Runtime_CustomPreview
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_header: t -> string [@@js.get "header"]
      val set_header: t -> string -> unit [@@js.set "header"]
      val get_hasBody: t -> bool [@@js.get "hasBody"]
      val set_hasBody: t -> bool -> unit [@@js.set "hasBody"]
      val get_formatterObjectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "formatterObjectId"]
      val set_formatterObjectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "formatterObjectId"]
      val get_bindRemoteObjectFunctionId: t -> inspector_Runtime_RemoteObjectId [@@js.get "bindRemoteObjectFunctionId"]
      val set_bindRemoteObjectFunctionId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "bindRemoteObjectFunctionId"]
      val get_configObjectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "configObjectId"]
      val set_configObjectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "configObjectId"]
    end
    (**
      Object containing abbreviated remote object value.
      experimental: 
    *)
    module[@js.scope "ObjectPreview"] ObjectPreview : sig
      type t = inspector_Runtime_ObjectPreview
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Object type. *)
      (** Object type. *)
      val get_type: t -> string [@@js.get "type"]
      (** Object type. *)
      val set_type: t -> string -> unit [@@js.set "type"]
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      val get_subtype: t -> string [@@js.get "subtype"]
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      val set_subtype: t -> string -> unit [@@js.set "subtype"]
      (** String representation of the object. *)
      (** String representation of the object. *)
      val get_description: t -> string [@@js.get "description"]
      (** String representation of the object. *)
      val set_description: t -> string -> unit [@@js.set "description"]
      (** True iff some of the properties or entries of the original object did not fit. *)
      (** True iff some of the properties or entries of the original object did not fit. *)
      val get_overflow: t -> bool [@@js.get "overflow"]
      (** True iff some of the properties or entries of the original object did not fit. *)
      val set_overflow: t -> bool -> unit [@@js.set "overflow"]
      (** List of the properties. *)
      (** List of the properties. *)
      val get_properties: t -> inspector_Runtime_PropertyPreview list [@@js.get "properties"]
      (** List of the properties. *)
      val set_properties: t -> inspector_Runtime_PropertyPreview list -> unit [@@js.set "properties"]
      (** List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only. *)
      (** List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only. *)
      val get_entries: t -> inspector_Runtime_EntryPreview list [@@js.get "entries"]
      (** List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only. *)
      val set_entries: t -> inspector_Runtime_EntryPreview list -> unit [@@js.set "entries"]
    end
    (** experimental:  *)
    module[@js.scope "PropertyPreview"] PropertyPreview : sig
      type t = inspector_Runtime_PropertyPreview
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Property name. *)
      (** Property name. *)
      val get_name: t -> string [@@js.get "name"]
      (** Property name. *)
      val set_name: t -> string -> unit [@@js.set "name"]
      (** Object type. Accessor means that the property itself is an accessor property. *)
      (** Object type. Accessor means that the property itself is an accessor property. *)
      val get_type: t -> string [@@js.get "type"]
      (** Object type. Accessor means that the property itself is an accessor property. *)
      val set_type: t -> string -> unit [@@js.set "type"]
      (** User-friendly property value string. *)
      (** User-friendly property value string. *)
      val get_value: t -> string [@@js.get "value"]
      (** User-friendly property value string. *)
      val set_value: t -> string -> unit [@@js.set "value"]
      (** Nested value preview. *)
      (** Nested value preview. *)
      val get_valuePreview: t -> inspector_Runtime_ObjectPreview [@@js.get "valuePreview"]
      (** Nested value preview. *)
      val set_valuePreview: t -> inspector_Runtime_ObjectPreview -> unit [@@js.set "valuePreview"]
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      val get_subtype: t -> string [@@js.get "subtype"]
      (** Object subtype hint. Specified for <code>object</code> type values only. *)
      val set_subtype: t -> string -> unit [@@js.set "subtype"]
    end
    (** experimental:  *)
    module[@js.scope "EntryPreview"] EntryPreview : sig
      type t = inspector_Runtime_EntryPreview
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Preview of the key. Specified for map-like collection entries. *)
      (** Preview of the key. Specified for map-like collection entries. *)
      val get_key: t -> inspector_Runtime_ObjectPreview [@@js.get "key"]
      (** Preview of the key. Specified for map-like collection entries. *)
      val set_key: t -> inspector_Runtime_ObjectPreview -> unit [@@js.set "key"]
      (** Preview of the value. *)
      (** Preview of the value. *)
      val get_value: t -> inspector_Runtime_ObjectPreview [@@js.get "value"]
      (** Preview of the value. *)
      val set_value: t -> inspector_Runtime_ObjectPreview -> unit [@@js.set "value"]
    end
    (** Object property descriptor. *)
    module[@js.scope "PropertyDescriptor"] PropertyDescriptor : sig
      type t = inspector_Runtime_PropertyDescriptor
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Property name or symbol description. *)
      (** Property name or symbol description. *)
      val get_name: t -> string [@@js.get "name"]
      (** Property name or symbol description. *)
      val set_name: t -> string -> unit [@@js.set "name"]
      (** The value associated with the property. *)
      (** The value associated with the property. *)
      val get_value: t -> inspector_Runtime_RemoteObject [@@js.get "value"]
      (** The value associated with the property. *)
      val set_value: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "value"]
      (** True if the value associated with the property may be changed (data descriptors only). *)
      (** True if the value associated with the property may be changed (data descriptors only). *)
      val get_writable: t -> bool [@@js.get "writable"]
      (** True if the value associated with the property may be changed (data descriptors only). *)
      val set_writable: t -> bool -> unit [@@js.set "writable"]
      (** A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only). *)
      (** A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only). *)
      val get_get: t -> inspector_Runtime_RemoteObject [@@js.get "get"]
      (** A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only). *)
      val set_get: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "get"]
      (** A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only). *)
      (** A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only). *)
      val get_set: t -> inspector_Runtime_RemoteObject [@@js.get "set"]
      (** A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only). *)
      val set_set: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "set"]
      (** True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object. *)
      (** True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object. *)
      val get_configurable: t -> bool [@@js.get "configurable"]
      (** True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object. *)
      val set_configurable: t -> bool -> unit [@@js.set "configurable"]
      (** True if this property shows up during enumeration of the properties on the corresponding object. *)
      (** True if this property shows up during enumeration of the properties on the corresponding object. *)
      val get_enumerable: t -> bool [@@js.get "enumerable"]
      (** True if this property shows up during enumeration of the properties on the corresponding object. *)
      val set_enumerable: t -> bool -> unit [@@js.set "enumerable"]
      (** True if the result was thrown during the evaluation. *)
      (** True if the result was thrown during the evaluation. *)
      val get_wasThrown: t -> bool [@@js.get "wasThrown"]
      (** True if the result was thrown during the evaluation. *)
      val set_wasThrown: t -> bool -> unit [@@js.set "wasThrown"]
      (** True if the property is owned for the object. *)
      (** True if the property is owned for the object. *)
      val get_isOwn: t -> bool [@@js.get "isOwn"]
      (** True if the property is owned for the object. *)
      val set_isOwn: t -> bool -> unit [@@js.set "isOwn"]
      (** Property symbol object, if the property is of the <code>symbol</code> type. *)
      (** Property symbol object, if the property is of the <code>symbol</code> type. *)
      val get_symbol: t -> inspector_Runtime_RemoteObject [@@js.get "symbol"]
      (** Property symbol object, if the property is of the <code>symbol</code> type. *)
      val set_symbol: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "symbol"]
    end
    (** Object internal property descriptor. This property isn't normally visible in JavaScript code. *)
    module[@js.scope "InternalPropertyDescriptor"] InternalPropertyDescriptor : sig
      type t = inspector_Runtime_InternalPropertyDescriptor
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Conventional property name. *)
      (** Conventional property name. *)
      val get_name: t -> string [@@js.get "name"]
      (** Conventional property name. *)
      val set_name: t -> string -> unit [@@js.set "name"]
      (** The value associated with the property. *)
      (** The value associated with the property. *)
      val get_value: t -> inspector_Runtime_RemoteObject [@@js.get "value"]
      (** The value associated with the property. *)
      val set_value: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "value"]
    end
    (** Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified. *)
    module[@js.scope "CallArgument"] CallArgument : sig
      type t = inspector_Runtime_CallArgument
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Primitive value or serializable javascript object. *)
      (** Primitive value or serializable javascript object. *)
      val get_value: t -> any [@@js.get "value"]
      (** Primitive value or serializable javascript object. *)
      val set_value: t -> any -> unit [@@js.set "value"]
      (** Primitive value which can not be JSON-stringified. *)
      (** Primitive value which can not be JSON-stringified. *)
      val get_unserializableValue: t -> inspector_Runtime_UnserializableValue [@@js.get "unserializableValue"]
      (** Primitive value which can not be JSON-stringified. *)
      val set_unserializableValue: t -> inspector_Runtime_UnserializableValue -> unit [@@js.set "unserializableValue"]
      (** Remote object handle. *)
      (** Remote object handle. *)
      val get_objectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "objectId"]
      (** Remote object handle. *)
      val set_objectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "objectId"]
    end
    (** Id of an execution context. *)
    module ExecutionContextId : sig
      type t = inspector_Runtime_ExecutionContextId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Description of an isolated world. *)
    module[@js.scope "ExecutionContextDescription"] ExecutionContextDescription : sig
      type t = inspector_Runtime_ExecutionContextDescription
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed. *)
      (** Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed. *)
      val get_id: t -> inspector_Runtime_ExecutionContextId [@@js.get "id"]
      (** Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed. *)
      val set_id: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "id"]
      (** Execution context origin. *)
      (** Execution context origin. *)
      val get_origin: t -> string [@@js.get "origin"]
      (** Execution context origin. *)
      val set_origin: t -> string -> unit [@@js.set "origin"]
      (** Human readable name describing given context. *)
      (** Human readable name describing given context. *)
      val get_name: t -> string [@@js.get "name"]
      (** Human readable name describing given context. *)
      val set_name: t -> string -> unit [@@js.set "name"]
      (** Embedder-specific auxiliary data. *)
      (** Embedder-specific auxiliary data. *)
      val get_auxData: t -> anonymous_interface_0 [@@js.get "auxData"]
      (** Embedder-specific auxiliary data. *)
      val set_auxData: t -> anonymous_interface_0 -> unit [@@js.set "auxData"]
    end
    (** Detailed information about exception (or error) that was thrown during script compilation or execution. *)
    module[@js.scope "ExceptionDetails"] ExceptionDetails : sig
      type t = inspector_Runtime_ExceptionDetails
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Exception id. *)
      (** Exception id. *)
      val get_exceptionId: t -> float [@@js.get "exceptionId"]
      (** Exception id. *)
      val set_exceptionId: t -> float -> unit [@@js.set "exceptionId"]
      (** Exception text, which should be used together with exception object when available. *)
      (** Exception text, which should be used together with exception object when available. *)
      val get_text: t -> string [@@js.get "text"]
      (** Exception text, which should be used together with exception object when available. *)
      val set_text: t -> string -> unit [@@js.set "text"]
      (** Line number of the exception location (0-based). *)
      (** Line number of the exception location (0-based). *)
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      (** Line number of the exception location (0-based). *)
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      (** Column number of the exception location (0-based). *)
      (** Column number of the exception location (0-based). *)
      val get_columnNumber: t -> float [@@js.get "columnNumber"]
      (** Column number of the exception location (0-based). *)
      val set_columnNumber: t -> float -> unit [@@js.set "columnNumber"]
      (** Script ID of the exception location. *)
      (** Script ID of the exception location. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Script ID of the exception location. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** URL of the exception location, to be used when the script was not reported. *)
      (** URL of the exception location, to be used when the script was not reported. *)
      val get_url: t -> string [@@js.get "url"]
      (** URL of the exception location, to be used when the script was not reported. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** JavaScript stack trace if available. *)
      (** JavaScript stack trace if available. *)
      val get_stackTrace: t -> inspector_Runtime_StackTrace [@@js.get "stackTrace"]
      (** JavaScript stack trace if available. *)
      val set_stackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "stackTrace"]
      (** Exception object if available. *)
      (** Exception object if available. *)
      val get_exception: t -> inspector_Runtime_RemoteObject [@@js.get "exception"]
      (** Exception object if available. *)
      val set_exception: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "exception"]
      (** Identifier of the context where exception happened. *)
      (** Identifier of the context where exception happened. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Identifier of the context where exception happened. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
    end
    (** Number of milliseconds since epoch. *)
    module Timestamp : sig
      type t = inspector_Runtime_Timestamp
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Stack entry for runtime errors and assertions. *)
    module[@js.scope "CallFrame"] CallFrame : sig
      type t = inspector_Runtime_CallFrame
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** JavaScript function name. *)
      (** JavaScript function name. *)
      val get_functionName: t -> string [@@js.get "functionName"]
      (** JavaScript function name. *)
      val set_functionName: t -> string -> unit [@@js.set "functionName"]
      (** JavaScript script id. *)
      (** JavaScript script id. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** JavaScript script id. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** JavaScript script name or url. *)
      (** JavaScript script name or url. *)
      val get_url: t -> string [@@js.get "url"]
      (** JavaScript script name or url. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** JavaScript script line number (0-based). *)
      (** JavaScript script line number (0-based). *)
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      (** JavaScript script line number (0-based). *)
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      (** JavaScript script column number (0-based). *)
      (** JavaScript script column number (0-based). *)
      val get_columnNumber: t -> float [@@js.get "columnNumber"]
      (** JavaScript script column number (0-based). *)
      val set_columnNumber: t -> float -> unit [@@js.set "columnNumber"]
    end
    (** Call frames for assertions or error messages. *)
    module[@js.scope "StackTrace"] StackTrace : sig
      type t = inspector_Runtime_StackTrace
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** String label of this stack trace. For async traces this may be a name of the function that initiated the async call. *)
      (** String label of this stack trace. For async traces this may be a name of the function that initiated the async call. *)
      val get_description: t -> string [@@js.get "description"]
      (** String label of this stack trace. For async traces this may be a name of the function that initiated the async call. *)
      val set_description: t -> string -> unit [@@js.set "description"]
      (** JavaScript function name. *)
      (** JavaScript function name. *)
      val get_callFrames: t -> inspector_Runtime_CallFrame list [@@js.get "callFrames"]
      (** JavaScript function name. *)
      val set_callFrames: t -> inspector_Runtime_CallFrame list -> unit [@@js.set "callFrames"]
      (** Asynchronous JavaScript stack trace that preceded this stack, if available. *)
      (** Asynchronous JavaScript stack trace that preceded this stack, if available. *)
      val get_parent: t -> t [@@js.get "parent"]
      (** Asynchronous JavaScript stack trace that preceded this stack, if available. *)
      val set_parent: t -> t -> unit [@@js.set "parent"]
      (**
        Asynchronous JavaScript stack trace that preceded this stack, if available.
        experimental: 
      *)
      (**
        Asynchronous JavaScript stack trace that preceded this stack, if available.
        experimental: 
      *)
      val get_parentId: t -> inspector_Runtime_StackTraceId [@@js.get "parentId"]
      (**
        Asynchronous JavaScript stack trace that preceded this stack, if available.
        experimental: 
      *)
      val set_parentId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "parentId"]
    end
    (**
      Unique identifier of current debugger.
      experimental: 
    *)
    module UniqueDebuggerId : sig
      type t = inspector_Runtime_UniqueDebuggerId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (**
      If <code>debuggerId</code> is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See <code>Runtime.StackTrace</code> and <code>Debugger.paused</code> for usages.
      experimental: 
    *)
    module[@js.scope "StackTraceId"] StackTraceId : sig
      type t = inspector_Runtime_StackTraceId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_id: t -> string [@@js.get "id"]
      val set_id: t -> string -> unit [@@js.set "id"]
      val get_debuggerId: t -> inspector_Runtime_UniqueDebuggerId [@@js.get "debuggerId"]
      val set_debuggerId: t -> inspector_Runtime_UniqueDebuggerId -> unit [@@js.set "debuggerId"]
    end
    module[@js.scope "EvaluateParameterType"] EvaluateParameterType : sig
      type t = inspector_Runtime_EvaluateParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Expression to evaluate. *)
      (** Expression to evaluate. *)
      val get_expression: t -> string [@@js.get "expression"]
      (** Expression to evaluate. *)
      val set_expression: t -> string -> unit [@@js.set "expression"]
      (** Symbolic group name that can be used to release multiple objects. *)
      (** Symbolic group name that can be used to release multiple objects. *)
      val get_objectGroup: t -> string [@@js.get "objectGroup"]
      (** Symbolic group name that can be used to release multiple objects. *)
      val set_objectGroup: t -> string -> unit [@@js.set "objectGroup"]
      (** Determines whether Command Line API should be available during the evaluation. *)
      (** Determines whether Command Line API should be available during the evaluation. *)
      val get_includeCommandLineAPI: t -> bool [@@js.get "includeCommandLineAPI"]
      (** Determines whether Command Line API should be available during the evaluation. *)
      val set_includeCommandLineAPI: t -> bool -> unit [@@js.set "includeCommandLineAPI"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val get_silent: t -> bool [@@js.get "silent"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val set_silent: t -> bool -> unit [@@js.set "silent"]
      (** Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      (** Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      val get_contextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "contextId"]
      (** Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      val set_contextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "contextId"]
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      val get_returnByValue: t -> bool [@@js.get "returnByValue"]
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      val set_returnByValue: t -> bool -> unit [@@js.set "returnByValue"]
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      val get_generatePreview: t -> bool [@@js.get "generatePreview"]
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      val set_generatePreview: t -> bool -> unit [@@js.set "generatePreview"]
      (** Whether execution should be treated as initiated by user in the UI. *)
      (** Whether execution should be treated as initiated by user in the UI. *)
      val get_userGesture: t -> bool [@@js.get "userGesture"]
      (** Whether execution should be treated as initiated by user in the UI. *)
      val set_userGesture: t -> bool -> unit [@@js.set "userGesture"]
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      val get_awaitPromise: t -> bool [@@js.get "awaitPromise"]
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      val set_awaitPromise: t -> bool -> unit [@@js.set "awaitPromise"]
    end
    module[@js.scope "AwaitPromiseParameterType"] AwaitPromiseParameterType : sig
      type t = inspector_Runtime_AwaitPromiseParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the promise. *)
      (** Identifier of the promise. *)
      val get_promiseObjectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "promiseObjectId"]
      (** Identifier of the promise. *)
      val set_promiseObjectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "promiseObjectId"]
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      val get_returnByValue: t -> bool [@@js.get "returnByValue"]
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      val set_returnByValue: t -> bool -> unit [@@js.set "returnByValue"]
      (** Whether preview should be generated for the result. *)
      (** Whether preview should be generated for the result. *)
      val get_generatePreview: t -> bool [@@js.get "generatePreview"]
      (** Whether preview should be generated for the result. *)
      val set_generatePreview: t -> bool -> unit [@@js.set "generatePreview"]
    end
    module[@js.scope "CallFunctionOnParameterType"] CallFunctionOnParameterType : sig
      type t = inspector_Runtime_CallFunctionOnParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Declaration of the function to call. *)
      (** Declaration of the function to call. *)
      val get_functionDeclaration: t -> string [@@js.get "functionDeclaration"]
      (** Declaration of the function to call. *)
      val set_functionDeclaration: t -> string -> unit [@@js.set "functionDeclaration"]
      (** Identifier of the object to call function on. Either objectId or executionContextId should be specified. *)
      (** Identifier of the object to call function on. Either objectId or executionContextId should be specified. *)
      val get_objectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "objectId"]
      (** Identifier of the object to call function on. Either objectId or executionContextId should be specified. *)
      val set_objectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "objectId"]
      (** Call arguments. All call arguments must belong to the same JavaScript world as the target object. *)
      (** Call arguments. All call arguments must belong to the same JavaScript world as the target object. *)
      val get_arguments: t -> inspector_Runtime_CallArgument list [@@js.get "arguments"]
      (** Call arguments. All call arguments must belong to the same JavaScript world as the target object. *)
      val set_arguments: t -> inspector_Runtime_CallArgument list -> unit [@@js.set "arguments"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val get_silent: t -> bool [@@js.get "silent"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val set_silent: t -> bool -> unit [@@js.set "silent"]
      (** Whether the result is expected to be a JSON object which should be sent by value. *)
      (** Whether the result is expected to be a JSON object which should be sent by value. *)
      val get_returnByValue: t -> bool [@@js.get "returnByValue"]
      (** Whether the result is expected to be a JSON object which should be sent by value. *)
      val set_returnByValue: t -> bool -> unit [@@js.set "returnByValue"]
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      val get_generatePreview: t -> bool [@@js.get "generatePreview"]
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      val set_generatePreview: t -> bool -> unit [@@js.set "generatePreview"]
      (** Whether execution should be treated as initiated by user in the UI. *)
      (** Whether execution should be treated as initiated by user in the UI. *)
      val get_userGesture: t -> bool [@@js.get "userGesture"]
      (** Whether execution should be treated as initiated by user in the UI. *)
      val set_userGesture: t -> bool -> unit [@@js.set "userGesture"]
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      val get_awaitPromise: t -> bool [@@js.get "awaitPromise"]
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      val set_awaitPromise: t -> bool -> unit [@@js.set "awaitPromise"]
      (** Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified. *)
      (** Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
      (** Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object. *)
      (** Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object. *)
      val get_objectGroup: t -> string [@@js.get "objectGroup"]
      (** Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object. *)
      val set_objectGroup: t -> string -> unit [@@js.set "objectGroup"]
    end
    module[@js.scope "GetPropertiesParameterType"] GetPropertiesParameterType : sig
      type t = inspector_Runtime_GetPropertiesParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the object to return properties for. *)
      (** Identifier of the object to return properties for. *)
      val get_objectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "objectId"]
      (** Identifier of the object to return properties for. *)
      val set_objectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "objectId"]
      (** If true, returns properties belonging only to the element itself, not to its prototype chain. *)
      (** If true, returns properties belonging only to the element itself, not to its prototype chain. *)
      val get_ownProperties: t -> bool [@@js.get "ownProperties"]
      (** If true, returns properties belonging only to the element itself, not to its prototype chain. *)
      val set_ownProperties: t -> bool -> unit [@@js.set "ownProperties"]
      (**
        If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
        experimental: 
      *)
      (**
        If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
        experimental: 
      *)
      val get_accessorPropertiesOnly: t -> bool [@@js.get "accessorPropertiesOnly"]
      (**
        If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
        experimental: 
      *)
      val set_accessorPropertiesOnly: t -> bool -> unit [@@js.set "accessorPropertiesOnly"]
      (**
        Whether preview should be generated for the results.
        experimental: 
      *)
      (**
        Whether preview should be generated for the results.
        experimental: 
      *)
      val get_generatePreview: t -> bool [@@js.get "generatePreview"]
      (**
        Whether preview should be generated for the results.
        experimental: 
      *)
      val set_generatePreview: t -> bool -> unit [@@js.set "generatePreview"]
    end
    module[@js.scope "ReleaseObjectParameterType"] ReleaseObjectParameterType : sig
      type t = inspector_Runtime_ReleaseObjectParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the object to release. *)
      (** Identifier of the object to release. *)
      val get_objectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "objectId"]
      (** Identifier of the object to release. *)
      val set_objectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "objectId"]
    end
    module[@js.scope "ReleaseObjectGroupParameterType"] ReleaseObjectGroupParameterType : sig
      type t = inspector_Runtime_ReleaseObjectGroupParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Symbolic object group name. *)
      (** Symbolic object group name. *)
      val get_objectGroup: t -> string [@@js.get "objectGroup"]
      (** Symbolic object group name. *)
      val set_objectGroup: t -> string -> unit [@@js.set "objectGroup"]
    end
    module[@js.scope "SetCustomObjectFormatterEnabledParameterType"] SetCustomObjectFormatterEnabledParameterType : sig
      type t = inspector_Runtime_SetCustomObjectFormatterEnabledParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_enabled: t -> bool [@@js.get "enabled"]
      val set_enabled: t -> bool -> unit [@@js.set "enabled"]
    end
    module[@js.scope "CompileScriptParameterType"] CompileScriptParameterType : sig
      type t = inspector_Runtime_CompileScriptParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Expression to compile. *)
      (** Expression to compile. *)
      val get_expression: t -> string [@@js.get "expression"]
      (** Expression to compile. *)
      val set_expression: t -> string -> unit [@@js.set "expression"]
      (** Source url to be set for the script. *)
      (** Source url to be set for the script. *)
      val get_sourceURL: t -> string [@@js.get "sourceURL"]
      (** Source url to be set for the script. *)
      val set_sourceURL: t -> string -> unit [@@js.set "sourceURL"]
      (** Specifies whether the compiled script should be persisted. *)
      (** Specifies whether the compiled script should be persisted. *)
      val get_persistScript: t -> bool [@@js.get "persistScript"]
      (** Specifies whether the compiled script should be persisted. *)
      val set_persistScript: t -> bool -> unit [@@js.set "persistScript"]
      (** Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      (** Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
    end
    module[@js.scope "RunScriptParameterType"] RunScriptParameterType : sig
      type t = inspector_Runtime_RunScriptParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the script to run. *)
      (** Id of the script to run. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Id of the script to run. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      (** Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
      (** Symbolic group name that can be used to release multiple objects. *)
      (** Symbolic group name that can be used to release multiple objects. *)
      val get_objectGroup: t -> string [@@js.get "objectGroup"]
      (** Symbolic group name that can be used to release multiple objects. *)
      val set_objectGroup: t -> string -> unit [@@js.set "objectGroup"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val get_silent: t -> bool [@@js.get "silent"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val set_silent: t -> bool -> unit [@@js.set "silent"]
      (** Determines whether Command Line API should be available during the evaluation. *)
      (** Determines whether Command Line API should be available during the evaluation. *)
      val get_includeCommandLineAPI: t -> bool [@@js.get "includeCommandLineAPI"]
      (** Determines whether Command Line API should be available during the evaluation. *)
      val set_includeCommandLineAPI: t -> bool -> unit [@@js.set "includeCommandLineAPI"]
      (** Whether the result is expected to be a JSON object which should be sent by value. *)
      (** Whether the result is expected to be a JSON object which should be sent by value. *)
      val get_returnByValue: t -> bool [@@js.get "returnByValue"]
      (** Whether the result is expected to be a JSON object which should be sent by value. *)
      val set_returnByValue: t -> bool -> unit [@@js.set "returnByValue"]
      (** Whether preview should be generated for the result. *)
      (** Whether preview should be generated for the result. *)
      val get_generatePreview: t -> bool [@@js.get "generatePreview"]
      (** Whether preview should be generated for the result. *)
      val set_generatePreview: t -> bool -> unit [@@js.set "generatePreview"]
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      val get_awaitPromise: t -> bool [@@js.get "awaitPromise"]
      (** Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved. *)
      val set_awaitPromise: t -> bool -> unit [@@js.set "awaitPromise"]
    end
    module[@js.scope "QueryObjectsParameterType"] QueryObjectsParameterType : sig
      type t = inspector_Runtime_QueryObjectsParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the prototype to return objects for. *)
      (** Identifier of the prototype to return objects for. *)
      val get_prototypeObjectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "prototypeObjectId"]
      (** Identifier of the prototype to return objects for. *)
      val set_prototypeObjectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "prototypeObjectId"]
    end
    module[@js.scope "GlobalLexicalScopeNamesParameterType"] GlobalLexicalScopeNamesParameterType : sig
      type t = inspector_Runtime_GlobalLexicalScopeNamesParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Specifies in which execution context to lookup global scope variables. *)
      (** Specifies in which execution context to lookup global scope variables. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Specifies in which execution context to lookup global scope variables. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
    end
    module[@js.scope "EvaluateReturnType"] EvaluateReturnType : sig
      type t = inspector_Runtime_EvaluateReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Evaluation result. *)
      (** Evaluation result. *)
      val get_result: t -> inspector_Runtime_RemoteObject [@@js.get "result"]
      (** Evaluation result. *)
      val set_result: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "result"]
      (** Exception details. *)
      (** Exception details. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "AwaitPromiseReturnType"] AwaitPromiseReturnType : sig
      type t = inspector_Runtime_AwaitPromiseReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Promise result. Will contain rejected value if promise was rejected. *)
      (** Promise result. Will contain rejected value if promise was rejected. *)
      val get_result: t -> inspector_Runtime_RemoteObject [@@js.get "result"]
      (** Promise result. Will contain rejected value if promise was rejected. *)
      val set_result: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "result"]
      (** Exception details if stack strace is available. *)
      (** Exception details if stack strace is available. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details if stack strace is available. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "CallFunctionOnReturnType"] CallFunctionOnReturnType : sig
      type t = inspector_Runtime_CallFunctionOnReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Call result. *)
      (** Call result. *)
      val get_result: t -> inspector_Runtime_RemoteObject [@@js.get "result"]
      (** Call result. *)
      val set_result: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "result"]
      (** Exception details. *)
      (** Exception details. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "GetPropertiesReturnType"] GetPropertiesReturnType : sig
      type t = inspector_Runtime_GetPropertiesReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Object properties. *)
      (** Object properties. *)
      val get_result: t -> inspector_Runtime_PropertyDescriptor list [@@js.get "result"]
      (** Object properties. *)
      val set_result: t -> inspector_Runtime_PropertyDescriptor list -> unit [@@js.set "result"]
      (** Internal object properties (only of the element itself). *)
      (** Internal object properties (only of the element itself). *)
      val get_internalProperties: t -> inspector_Runtime_InternalPropertyDescriptor list [@@js.get "internalProperties"]
      (** Internal object properties (only of the element itself). *)
      val set_internalProperties: t -> inspector_Runtime_InternalPropertyDescriptor list -> unit [@@js.set "internalProperties"]
      (** Exception details. *)
      (** Exception details. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "CompileScriptReturnType"] CompileScriptReturnType : sig
      type t = inspector_Runtime_CompileScriptReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the script. *)
      (** Id of the script. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Id of the script. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** Exception details. *)
      (** Exception details. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "RunScriptReturnType"] RunScriptReturnType : sig
      type t = inspector_Runtime_RunScriptReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Run result. *)
      (** Run result. *)
      val get_result: t -> inspector_Runtime_RemoteObject [@@js.get "result"]
      (** Run result. *)
      val set_result: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "result"]
      (** Exception details. *)
      (** Exception details. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "QueryObjectsReturnType"] QueryObjectsReturnType : sig
      type t = inspector_Runtime_QueryObjectsReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Array with objects. *)
      (** Array with objects. *)
      val get_objects: t -> inspector_Runtime_RemoteObject [@@js.get "objects"]
      (** Array with objects. *)
      val set_objects: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "objects"]
    end
    module[@js.scope "GlobalLexicalScopeNamesReturnType"] GlobalLexicalScopeNamesReturnType : sig
      type t = inspector_Runtime_GlobalLexicalScopeNamesReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_names: t -> string list [@@js.get "names"]
      val set_names: t -> string list -> unit [@@js.set "names"]
    end
    module[@js.scope "ExecutionContextCreatedEventDataType"] ExecutionContextCreatedEventDataType : sig
      type t = inspector_Runtime_ExecutionContextCreatedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** A newly created execution context. *)
      (** A newly created execution context. *)
      val get_context: t -> inspector_Runtime_ExecutionContextDescription [@@js.get "context"]
      (** A newly created execution context. *)
      val set_context: t -> inspector_Runtime_ExecutionContextDescription -> unit [@@js.set "context"]
    end
    module[@js.scope "ExecutionContextDestroyedEventDataType"] ExecutionContextDestroyedEventDataType : sig
      type t = inspector_Runtime_ExecutionContextDestroyedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the destroyed context *)
      (** Id of the destroyed context *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Id of the destroyed context *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
    end
    module[@js.scope "ExceptionThrownEventDataType"] ExceptionThrownEventDataType : sig
      type t = inspector_Runtime_ExceptionThrownEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Timestamp of the exception. *)
      (** Timestamp of the exception. *)
      val get_timestamp: t -> inspector_Runtime_Timestamp [@@js.get "timestamp"]
      (** Timestamp of the exception. *)
      val set_timestamp: t -> inspector_Runtime_Timestamp -> unit [@@js.set "timestamp"]
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "ExceptionRevokedEventDataType"] ExceptionRevokedEventDataType : sig
      type t = inspector_Runtime_ExceptionRevokedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Reason describing why exception was revoked. *)
      (** Reason describing why exception was revoked. *)
      val get_reason: t -> string [@@js.get "reason"]
      (** Reason describing why exception was revoked. *)
      val set_reason: t -> string -> unit [@@js.set "reason"]
      (** The id of revoked exception, as reported in <code>exceptionThrown</code>. *)
      (** The id of revoked exception, as reported in <code>exceptionThrown</code>. *)
      val get_exceptionId: t -> float [@@js.get "exceptionId"]
      (** The id of revoked exception, as reported in <code>exceptionThrown</code>. *)
      val set_exceptionId: t -> float -> unit [@@js.set "exceptionId"]
    end
    module[@js.scope "ConsoleAPICalledEventDataType"] ConsoleAPICalledEventDataType : sig
      type t = inspector_Runtime_ConsoleAPICalledEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Type of the call. *)
      (** Type of the call. *)
      val get_type: t -> string [@@js.get "type"]
      (** Type of the call. *)
      val set_type: t -> string -> unit [@@js.set "type"]
      (** Call arguments. *)
      (** Call arguments. *)
      val get_args: t -> inspector_Runtime_RemoteObject list [@@js.get "args"]
      (** Call arguments. *)
      val set_args: t -> inspector_Runtime_RemoteObject list -> unit [@@js.set "args"]
      (** Identifier of the context where the call was made. *)
      (** Identifier of the context where the call was made. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Identifier of the context where the call was made. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
      (** Call timestamp. *)
      (** Call timestamp. *)
      val get_timestamp: t -> inspector_Runtime_Timestamp [@@js.get "timestamp"]
      (** Call timestamp. *)
      val set_timestamp: t -> inspector_Runtime_Timestamp -> unit [@@js.set "timestamp"]
      (** Stack trace captured when the call was made. *)
      (** Stack trace captured when the call was made. *)
      val get_stackTrace: t -> inspector_Runtime_StackTrace [@@js.get "stackTrace"]
      (** Stack trace captured when the call was made. *)
      val set_stackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "stackTrace"]
      (**
        Console context descriptor for calls on non-default console context (not console.* ): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
        experimental: 
      *)
      (**
        Console context descriptor for calls on non-default console context (not console.* ): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
        experimental: 
      *)
      val get_context: t -> string [@@js.get "context"]
      (**
        Console context descriptor for calls on non-default console context (not console.* ): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
        experimental: 
      *)
      val set_context: t -> string -> unit [@@js.set "context"]
    end
    module[@js.scope "InspectRequestedEventDataType"] InspectRequestedEventDataType : sig
      type t = inspector_Runtime_InspectRequestedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_object: t -> inspector_Runtime_RemoteObject [@@js.get "object"]
      val set_object: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "object"]
      val get_hints: t -> anonymous_interface_0 [@@js.get "hints"]
      val set_hints: t -> anonymous_interface_0 -> unit [@@js.set "hints"]
    end
  end
  module[@js.scope "Debugger"] Debugger : sig
    (** Breakpoint identifier. *)
    module BreakpointId : sig
      type t = inspector_Debugger_BreakpointId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Call frame identifier. *)
    module CallFrameId : sig
      type t = inspector_Debugger_CallFrameId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Location in the source code. *)
    module[@js.scope "Location"] Location : sig
      type t = inspector_Debugger_Location
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Script identifier as reported in the <code>Debugger.scriptParsed</code>. *)
      (** Script identifier as reported in the <code>Debugger.scriptParsed</code>. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Script identifier as reported in the <code>Debugger.scriptParsed</code>. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** Line number in the script (0-based). *)
      (** Line number in the script (0-based). *)
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      (** Line number in the script (0-based). *)
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      (** Column number in the script (0-based). *)
      (** Column number in the script (0-based). *)
      val get_columnNumber: t -> float [@@js.get "columnNumber"]
      (** Column number in the script (0-based). *)
      val set_columnNumber: t -> float -> unit [@@js.set "columnNumber"]
    end
    (**
      Location in the source code.
      experimental: 
    *)
    module[@js.scope "ScriptPosition"] ScriptPosition : sig
      type t = inspector_Debugger_ScriptPosition
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      val get_columnNumber: t -> float [@@js.get "columnNumber"]
      val set_columnNumber: t -> float -> unit [@@js.set "columnNumber"]
    end
    (** JavaScript call frame. Array of call frames form the call stack. *)
    module[@js.scope "CallFrame"] CallFrame : sig
      type t = inspector_Debugger_CallFrame
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Call frame identifier. This identifier is only valid while the virtual machine is paused. *)
      (** Call frame identifier. This identifier is only valid while the virtual machine is paused. *)
      val get_callFrameId: t -> inspector_Debugger_CallFrameId [@@js.get "callFrameId"]
      (** Call frame identifier. This identifier is only valid while the virtual machine is paused. *)
      val set_callFrameId: t -> inspector_Debugger_CallFrameId -> unit [@@js.set "callFrameId"]
      (** Name of the JavaScript function called on this call frame. *)
      (** Name of the JavaScript function called on this call frame. *)
      val get_functionName: t -> string [@@js.get "functionName"]
      (** Name of the JavaScript function called on this call frame. *)
      val set_functionName: t -> string -> unit [@@js.set "functionName"]
      (** Location in the source code. *)
      (** Location in the source code. *)
      val get_functionLocation: t -> inspector_Debugger_Location [@@js.get "functionLocation"]
      (** Location in the source code. *)
      val set_functionLocation: t -> inspector_Debugger_Location -> unit [@@js.set "functionLocation"]
      (** Location in the source code. *)
      (** Location in the source code. *)
      val get_location: t -> inspector_Debugger_Location [@@js.get "location"]
      (** Location in the source code. *)
      val set_location: t -> inspector_Debugger_Location -> unit [@@js.set "location"]
      (** JavaScript script name or url. *)
      (** JavaScript script name or url. *)
      val get_url: t -> string [@@js.get "url"]
      (** JavaScript script name or url. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Scope chain for this call frame. *)
      (** Scope chain for this call frame. *)
      val get_scopeChain: t -> inspector_Debugger_Scope list [@@js.get "scopeChain"]
      (** Scope chain for this call frame. *)
      val set_scopeChain: t -> inspector_Debugger_Scope list -> unit [@@js.set "scopeChain"]
      (** <code>this</code> object for this call frame. *)
      (** <code>this</code> object for this call frame. *)
      val get_this: t -> inspector_Runtime_RemoteObject [@@js.get "this"]
      (** <code>this</code> object for this call frame. *)
      val set_this: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "this"]
      (** The value being returned, if the function is at return point. *)
      (** The value being returned, if the function is at return point. *)
      val get_returnValue: t -> inspector_Runtime_RemoteObject [@@js.get "returnValue"]
      (** The value being returned, if the function is at return point. *)
      val set_returnValue: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "returnValue"]
    end
    (** Scope description. *)
    module[@js.scope "Scope"] Scope : sig
      type t = inspector_Debugger_Scope
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Scope type. *)
      (** Scope type. *)
      val get_type: t -> string [@@js.get "type"]
      (** Scope type. *)
      val set_type: t -> string -> unit [@@js.set "type"]
      (** Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties. *)
      (** Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties. *)
      val get_object: t -> inspector_Runtime_RemoteObject [@@js.get "object"]
      (** Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties. *)
      val set_object: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "object"]
      val get_name: t -> string [@@js.get "name"]
      val set_name: t -> string -> unit [@@js.set "name"]
      (** Location in the source code where scope starts *)
      (** Location in the source code where scope starts *)
      val get_startLocation: t -> inspector_Debugger_Location [@@js.get "startLocation"]
      (** Location in the source code where scope starts *)
      val set_startLocation: t -> inspector_Debugger_Location -> unit [@@js.set "startLocation"]
      (** Location in the source code where scope ends *)
      (** Location in the source code where scope ends *)
      val get_endLocation: t -> inspector_Debugger_Location [@@js.get "endLocation"]
      (** Location in the source code where scope ends *)
      val set_endLocation: t -> inspector_Debugger_Location -> unit [@@js.set "endLocation"]
    end
    (** Search match for resource. *)
    module[@js.scope "SearchMatch"] SearchMatch : sig
      type t = inspector_Debugger_SearchMatch
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Line number in resource content. *)
      (** Line number in resource content. *)
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      (** Line number in resource content. *)
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      (** Line with match content. *)
      (** Line with match content. *)
      val get_lineContent: t -> string [@@js.get "lineContent"]
      (** Line with match content. *)
      val set_lineContent: t -> string -> unit [@@js.set "lineContent"]
    end
    module[@js.scope "BreakLocation"] BreakLocation : sig
      type t = inspector_Debugger_BreakLocation
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Script identifier as reported in the <code>Debugger.scriptParsed</code>. *)
      (** Script identifier as reported in the <code>Debugger.scriptParsed</code>. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Script identifier as reported in the <code>Debugger.scriptParsed</code>. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** Line number in the script (0-based). *)
      (** Line number in the script (0-based). *)
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      (** Line number in the script (0-based). *)
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      (** Column number in the script (0-based). *)
      (** Column number in the script (0-based). *)
      val get_columnNumber: t -> float [@@js.get "columnNumber"]
      (** Column number in the script (0-based). *)
      val set_columnNumber: t -> float -> unit [@@js.set "columnNumber"]
      val get_type: t -> string [@@js.get "type"]
      val set_type: t -> string -> unit [@@js.set "type"]
    end
    module[@js.scope "SetBreakpointsActiveParameterType"] SetBreakpointsActiveParameterType : sig
      type t = inspector_Debugger_SetBreakpointsActiveParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** New value for breakpoints active state. *)
      (** New value for breakpoints active state. *)
      val get_active: t -> bool [@@js.get "active"]
      (** New value for breakpoints active state. *)
      val set_active: t -> bool -> unit [@@js.set "active"]
    end
    module[@js.scope "SetSkipAllPausesParameterType"] SetSkipAllPausesParameterType : sig
      type t = inspector_Debugger_SetSkipAllPausesParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** New value for skip pauses state. *)
      (** New value for skip pauses state. *)
      val get_skip: t -> bool [@@js.get "skip"]
      (** New value for skip pauses state. *)
      val set_skip: t -> bool -> unit [@@js.set "skip"]
    end
    module[@js.scope "SetBreakpointByUrlParameterType"] SetBreakpointByUrlParameterType : sig
      type t = inspector_Debugger_SetBreakpointByUrlParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Line number to set breakpoint at. *)
      (** Line number to set breakpoint at. *)
      val get_lineNumber: t -> float [@@js.get "lineNumber"]
      (** Line number to set breakpoint at. *)
      val set_lineNumber: t -> float -> unit [@@js.set "lineNumber"]
      (** URL of the resources to set breakpoint on. *)
      (** URL of the resources to set breakpoint on. *)
      val get_url: t -> string [@@js.get "url"]
      (** URL of the resources to set breakpoint on. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified. *)
      (** Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified. *)
      val get_urlRegex: t -> string [@@js.get "urlRegex"]
      (** Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified. *)
      val set_urlRegex: t -> string -> unit [@@js.set "urlRegex"]
      (** Script hash of the resources to set breakpoint on. *)
      (** Script hash of the resources to set breakpoint on. *)
      val get_scriptHash: t -> string [@@js.get "scriptHash"]
      (** Script hash of the resources to set breakpoint on. *)
      val set_scriptHash: t -> string -> unit [@@js.set "scriptHash"]
      (** Offset in the line to set breakpoint at. *)
      (** Offset in the line to set breakpoint at. *)
      val get_columnNumber: t -> float [@@js.get "columnNumber"]
      (** Offset in the line to set breakpoint at. *)
      val set_columnNumber: t -> float -> unit [@@js.set "columnNumber"]
      (** Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. *)
      (** Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. *)
      val get_condition: t -> string [@@js.get "condition"]
      (** Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. *)
      val set_condition: t -> string -> unit [@@js.set "condition"]
    end
    module[@js.scope "SetBreakpointParameterType"] SetBreakpointParameterType : sig
      type t = inspector_Debugger_SetBreakpointParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Location to set breakpoint in. *)
      (** Location to set breakpoint in. *)
      val get_location: t -> inspector_Debugger_Location [@@js.get "location"]
      (** Location to set breakpoint in. *)
      val set_location: t -> inspector_Debugger_Location -> unit [@@js.set "location"]
      (** Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. *)
      (** Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. *)
      val get_condition: t -> string [@@js.get "condition"]
      (** Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. *)
      val set_condition: t -> string -> unit [@@js.set "condition"]
    end
    module[@js.scope "RemoveBreakpointParameterType"] RemoveBreakpointParameterType : sig
      type t = inspector_Debugger_RemoveBreakpointParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_breakpointId: t -> inspector_Debugger_BreakpointId [@@js.get "breakpointId"]
      val set_breakpointId: t -> inspector_Debugger_BreakpointId -> unit [@@js.set "breakpointId"]
    end
    module[@js.scope "GetPossibleBreakpointsParameterType"] GetPossibleBreakpointsParameterType : sig
      type t = inspector_Debugger_GetPossibleBreakpointsParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Start of range to search possible breakpoint locations in. *)
      (** Start of range to search possible breakpoint locations in. *)
      val get_start: t -> inspector_Debugger_Location [@@js.get "start"]
      (** Start of range to search possible breakpoint locations in. *)
      val set_start: t -> inspector_Debugger_Location -> unit [@@js.set "start"]
      (** End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range. *)
      (** End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range. *)
      val get_end: t -> inspector_Debugger_Location [@@js.get "end"]
      (** End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range. *)
      val set_end: t -> inspector_Debugger_Location -> unit [@@js.set "end"]
      (** Only consider locations which are in the same (non-nested) function as start. *)
      (** Only consider locations which are in the same (non-nested) function as start. *)
      val get_restrictToFunction: t -> bool [@@js.get "restrictToFunction"]
      (** Only consider locations which are in the same (non-nested) function as start. *)
      val set_restrictToFunction: t -> bool -> unit [@@js.set "restrictToFunction"]
    end
    module[@js.scope "ContinueToLocationParameterType"] ContinueToLocationParameterType : sig
      type t = inspector_Debugger_ContinueToLocationParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Location to continue to. *)
      (** Location to continue to. *)
      val get_location: t -> inspector_Debugger_Location [@@js.get "location"]
      (** Location to continue to. *)
      val set_location: t -> inspector_Debugger_Location -> unit [@@js.set "location"]
      val get_targetCallFrames: t -> string [@@js.get "targetCallFrames"]
      val set_targetCallFrames: t -> string -> unit [@@js.set "targetCallFrames"]
    end
    module[@js.scope "PauseOnAsyncCallParameterType"] PauseOnAsyncCallParameterType : sig
      type t = inspector_Debugger_PauseOnAsyncCallParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Debugger will pause when async call with given stack trace is started. *)
      (** Debugger will pause when async call with given stack trace is started. *)
      val get_parentStackTraceId: t -> inspector_Runtime_StackTraceId [@@js.get "parentStackTraceId"]
      (** Debugger will pause when async call with given stack trace is started. *)
      val set_parentStackTraceId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "parentStackTraceId"]
    end
    module[@js.scope "StepIntoParameterType"] StepIntoParameterType : sig
      type t = inspector_Debugger_StepIntoParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (**
        Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.
        experimental: 
      *)
      (**
        Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.
        experimental: 
      *)
      val get_breakOnAsyncCall: t -> bool [@@js.get "breakOnAsyncCall"]
      (**
        Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.
        experimental: 
      *)
      val set_breakOnAsyncCall: t -> bool -> unit [@@js.set "breakOnAsyncCall"]
    end
    module[@js.scope "GetStackTraceParameterType"] GetStackTraceParameterType : sig
      type t = inspector_Debugger_GetStackTraceParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_stackTraceId: t -> inspector_Runtime_StackTraceId [@@js.get "stackTraceId"]
      val set_stackTraceId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "stackTraceId"]
    end
    module[@js.scope "SearchInContentParameterType"] SearchInContentParameterType : sig
      type t = inspector_Debugger_SearchInContentParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the script to search in. *)
      (** Id of the script to search in. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Id of the script to search in. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** String to search for. *)
      (** String to search for. *)
      val get_query: t -> string [@@js.get "query"]
      (** String to search for. *)
      val set_query: t -> string -> unit [@@js.set "query"]
      (** If true, search is case sensitive. *)
      (** If true, search is case sensitive. *)
      val get_caseSensitive: t -> bool [@@js.get "caseSensitive"]
      (** If true, search is case sensitive. *)
      val set_caseSensitive: t -> bool -> unit [@@js.set "caseSensitive"]
      (** If true, treats string parameter as regex. *)
      (** If true, treats string parameter as regex. *)
      val get_isRegex: t -> bool [@@js.get "isRegex"]
      (** If true, treats string parameter as regex. *)
      val set_isRegex: t -> bool -> unit [@@js.set "isRegex"]
    end
    module[@js.scope "SetScriptSourceParameterType"] SetScriptSourceParameterType : sig
      type t = inspector_Debugger_SetScriptSourceParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the script to edit. *)
      (** Id of the script to edit. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Id of the script to edit. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** New content of the script. *)
      (** New content of the script. *)
      val get_scriptSource: t -> string [@@js.get "scriptSource"]
      (** New content of the script. *)
      val set_scriptSource: t -> string -> unit [@@js.set "scriptSource"]
      (** If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code. *)
      (** If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code. *)
      val get_dryRun: t -> bool [@@js.get "dryRun"]
      (** If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code. *)
      val set_dryRun: t -> bool -> unit [@@js.set "dryRun"]
    end
    module[@js.scope "RestartFrameParameterType"] RestartFrameParameterType : sig
      type t = inspector_Debugger_RestartFrameParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Call frame identifier to evaluate on. *)
      (** Call frame identifier to evaluate on. *)
      val get_callFrameId: t -> inspector_Debugger_CallFrameId [@@js.get "callFrameId"]
      (** Call frame identifier to evaluate on. *)
      val set_callFrameId: t -> inspector_Debugger_CallFrameId -> unit [@@js.set "callFrameId"]
    end
    module[@js.scope "GetScriptSourceParameterType"] GetScriptSourceParameterType : sig
      type t = inspector_Debugger_GetScriptSourceParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the script to get source for. *)
      (** Id of the script to get source for. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Id of the script to get source for. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
    end
    module[@js.scope "SetPauseOnExceptionsParameterType"] SetPauseOnExceptionsParameterType : sig
      type t = inspector_Debugger_SetPauseOnExceptionsParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Pause on exceptions mode. *)
      (** Pause on exceptions mode. *)
      val get_state: t -> string [@@js.get "state"]
      (** Pause on exceptions mode. *)
      val set_state: t -> string -> unit [@@js.set "state"]
    end
    module[@js.scope "EvaluateOnCallFrameParameterType"] EvaluateOnCallFrameParameterType : sig
      type t = inspector_Debugger_EvaluateOnCallFrameParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Call frame identifier to evaluate on. *)
      (** Call frame identifier to evaluate on. *)
      val get_callFrameId: t -> inspector_Debugger_CallFrameId [@@js.get "callFrameId"]
      (** Call frame identifier to evaluate on. *)
      val set_callFrameId: t -> inspector_Debugger_CallFrameId -> unit [@@js.set "callFrameId"]
      (** Expression to evaluate. *)
      (** Expression to evaluate. *)
      val get_expression: t -> string [@@js.get "expression"]
      (** Expression to evaluate. *)
      val set_expression: t -> string -> unit [@@js.set "expression"]
      (** String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>). *)
      (** String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>). *)
      val get_objectGroup: t -> string [@@js.get "objectGroup"]
      (** String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>). *)
      val set_objectGroup: t -> string -> unit [@@js.set "objectGroup"]
      (** Specifies whether command line API should be available to the evaluated expression, defaults to false. *)
      (** Specifies whether command line API should be available to the evaluated expression, defaults to false. *)
      val get_includeCommandLineAPI: t -> bool [@@js.get "includeCommandLineAPI"]
      (** Specifies whether command line API should be available to the evaluated expression, defaults to false. *)
      val set_includeCommandLineAPI: t -> bool -> unit [@@js.set "includeCommandLineAPI"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val get_silent: t -> bool [@@js.get "silent"]
      (** In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state. *)
      val set_silent: t -> bool -> unit [@@js.set "silent"]
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      val get_returnByValue: t -> bool [@@js.get "returnByValue"]
      (** Whether the result is expected to be a JSON object that should be sent by value. *)
      val set_returnByValue: t -> bool -> unit [@@js.set "returnByValue"]
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      val get_generatePreview: t -> bool [@@js.get "generatePreview"]
      (**
        Whether preview should be generated for the result.
        experimental: 
      *)
      val set_generatePreview: t -> bool -> unit [@@js.set "generatePreview"]
      (** Whether to throw an exception if side effect cannot be ruled out during evaluation. *)
      (** Whether to throw an exception if side effect cannot be ruled out during evaluation. *)
      val get_throwOnSideEffect: t -> bool [@@js.get "throwOnSideEffect"]
      (** Whether to throw an exception if side effect cannot be ruled out during evaluation. *)
      val set_throwOnSideEffect: t -> bool -> unit [@@js.set "throwOnSideEffect"]
    end
    module[@js.scope "SetVariableValueParameterType"] SetVariableValueParameterType : sig
      type t = inspector_Debugger_SetVariableValueParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually. *)
      (** 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually. *)
      val get_scopeNumber: t -> float [@@js.get "scopeNumber"]
      (** 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually. *)
      val set_scopeNumber: t -> float -> unit [@@js.set "scopeNumber"]
      (** Variable name. *)
      (** Variable name. *)
      val get_variableName: t -> string [@@js.get "variableName"]
      (** Variable name. *)
      val set_variableName: t -> string -> unit [@@js.set "variableName"]
      (** New variable value. *)
      (** New variable value. *)
      val get_newValue: t -> inspector_Runtime_CallArgument [@@js.get "newValue"]
      (** New variable value. *)
      val set_newValue: t -> inspector_Runtime_CallArgument -> unit [@@js.set "newValue"]
      (** Id of callframe that holds variable. *)
      (** Id of callframe that holds variable. *)
      val get_callFrameId: t -> inspector_Debugger_CallFrameId [@@js.get "callFrameId"]
      (** Id of callframe that holds variable. *)
      val set_callFrameId: t -> inspector_Debugger_CallFrameId -> unit [@@js.set "callFrameId"]
    end
    module[@js.scope "SetReturnValueParameterType"] SetReturnValueParameterType : sig
      type t = inspector_Debugger_SetReturnValueParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** New return value. *)
      (** New return value. *)
      val get_newValue: t -> inspector_Runtime_CallArgument [@@js.get "newValue"]
      (** New return value. *)
      val set_newValue: t -> inspector_Runtime_CallArgument -> unit [@@js.set "newValue"]
    end
    module[@js.scope "SetAsyncCallStackDepthParameterType"] SetAsyncCallStackDepthParameterType : sig
      type t = inspector_Debugger_SetAsyncCallStackDepthParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default). *)
      (** Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default). *)
      val get_maxDepth: t -> float [@@js.get "maxDepth"]
      (** Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default). *)
      val set_maxDepth: t -> float -> unit [@@js.set "maxDepth"]
    end
    module[@js.scope "SetBlackboxPatternsParameterType"] SetBlackboxPatternsParameterType : sig
      type t = inspector_Debugger_SetBlackboxPatternsParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Array of regexps that will be used to check script url for blackbox state. *)
      (** Array of regexps that will be used to check script url for blackbox state. *)
      val get_patterns: t -> string list [@@js.get "patterns"]
      (** Array of regexps that will be used to check script url for blackbox state. *)
      val set_patterns: t -> string list -> unit [@@js.set "patterns"]
    end
    module[@js.scope "SetBlackboxedRangesParameterType"] SetBlackboxedRangesParameterType : sig
      type t = inspector_Debugger_SetBlackboxedRangesParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the script. *)
      (** Id of the script. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Id of the script. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      val get_positions: t -> inspector_Debugger_ScriptPosition list [@@js.get "positions"]
      val set_positions: t -> inspector_Debugger_ScriptPosition list -> unit [@@js.set "positions"]
    end
    module[@js.scope "EnableReturnType"] EnableReturnType : sig
      type t = inspector_Debugger_EnableReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (**
        Unique identifier of the debugger.
        experimental: 
      *)
      (**
        Unique identifier of the debugger.
        experimental: 
      *)
      val get_debuggerId: t -> inspector_Runtime_UniqueDebuggerId [@@js.get "debuggerId"]
      (**
        Unique identifier of the debugger.
        experimental: 
      *)
      val set_debuggerId: t -> inspector_Runtime_UniqueDebuggerId -> unit [@@js.set "debuggerId"]
    end
    module[@js.scope "SetBreakpointByUrlReturnType"] SetBreakpointByUrlReturnType : sig
      type t = inspector_Debugger_SetBreakpointByUrlReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the created breakpoint for further reference. *)
      (** Id of the created breakpoint for further reference. *)
      val get_breakpointId: t -> inspector_Debugger_BreakpointId [@@js.get "breakpointId"]
      (** Id of the created breakpoint for further reference. *)
      val set_breakpointId: t -> inspector_Debugger_BreakpointId -> unit [@@js.set "breakpointId"]
      (** List of the locations this breakpoint resolved into upon addition. *)
      (** List of the locations this breakpoint resolved into upon addition. *)
      val get_locations: t -> inspector_Debugger_Location list [@@js.get "locations"]
      (** List of the locations this breakpoint resolved into upon addition. *)
      val set_locations: t -> inspector_Debugger_Location list -> unit [@@js.set "locations"]
    end
    module[@js.scope "SetBreakpointReturnType"] SetBreakpointReturnType : sig
      type t = inspector_Debugger_SetBreakpointReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the created breakpoint for further reference. *)
      (** Id of the created breakpoint for further reference. *)
      val get_breakpointId: t -> inspector_Debugger_BreakpointId [@@js.get "breakpointId"]
      (** Id of the created breakpoint for further reference. *)
      val set_breakpointId: t -> inspector_Debugger_BreakpointId -> unit [@@js.set "breakpointId"]
      (** Location this breakpoint resolved into. *)
      (** Location this breakpoint resolved into. *)
      val get_actualLocation: t -> inspector_Debugger_Location [@@js.get "actualLocation"]
      (** Location this breakpoint resolved into. *)
      val set_actualLocation: t -> inspector_Debugger_Location -> unit [@@js.set "actualLocation"]
    end
    module[@js.scope "GetPossibleBreakpointsReturnType"] GetPossibleBreakpointsReturnType : sig
      type t = inspector_Debugger_GetPossibleBreakpointsReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** List of the possible breakpoint locations. *)
      (** List of the possible breakpoint locations. *)
      val get_locations: t -> inspector_Debugger_BreakLocation list [@@js.get "locations"]
      (** List of the possible breakpoint locations. *)
      val set_locations: t -> inspector_Debugger_BreakLocation list -> unit [@@js.set "locations"]
    end
    module[@js.scope "GetStackTraceReturnType"] GetStackTraceReturnType : sig
      type t = inspector_Debugger_GetStackTraceReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_stackTrace: t -> inspector_Runtime_StackTrace [@@js.get "stackTrace"]
      val set_stackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "stackTrace"]
    end
    module[@js.scope "SearchInContentReturnType"] SearchInContentReturnType : sig
      type t = inspector_Debugger_SearchInContentReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** List of search matches. *)
      (** List of search matches. *)
      val get_result: t -> inspector_Debugger_SearchMatch list [@@js.get "result"]
      (** List of search matches. *)
      val set_result: t -> inspector_Debugger_SearchMatch list -> unit [@@js.set "result"]
    end
    module[@js.scope "SetScriptSourceReturnType"] SetScriptSourceReturnType : sig
      type t = inspector_Debugger_SetScriptSourceReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** New stack trace in case editing has happened while VM was stopped. *)
      (** New stack trace in case editing has happened while VM was stopped. *)
      val get_callFrames: t -> inspector_Debugger_CallFrame list [@@js.get "callFrames"]
      (** New stack trace in case editing has happened while VM was stopped. *)
      val set_callFrames: t -> inspector_Debugger_CallFrame list -> unit [@@js.set "callFrames"]
      (** Whether current call stack  was modified after applying the changes. *)
      (** Whether current call stack  was modified after applying the changes. *)
      val get_stackChanged: t -> bool [@@js.get "stackChanged"]
      (** Whether current call stack  was modified after applying the changes. *)
      val set_stackChanged: t -> bool -> unit [@@js.set "stackChanged"]
      (** Async stack trace, if any. *)
      (** Async stack trace, if any. *)
      val get_asyncStackTrace: t -> inspector_Runtime_StackTrace [@@js.get "asyncStackTrace"]
      (** Async stack trace, if any. *)
      val set_asyncStackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "asyncStackTrace"]
      (**
        Async stack trace, if any.
        experimental: 
      *)
      (**
        Async stack trace, if any.
        experimental: 
      *)
      val get_asyncStackTraceId: t -> inspector_Runtime_StackTraceId [@@js.get "asyncStackTraceId"]
      (**
        Async stack trace, if any.
        experimental: 
      *)
      val set_asyncStackTraceId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "asyncStackTraceId"]
      (** Exception details if any. *)
      (** Exception details if any. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details if any. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "RestartFrameReturnType"] RestartFrameReturnType : sig
      type t = inspector_Debugger_RestartFrameReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** New stack trace. *)
      (** New stack trace. *)
      val get_callFrames: t -> inspector_Debugger_CallFrame list [@@js.get "callFrames"]
      (** New stack trace. *)
      val set_callFrames: t -> inspector_Debugger_CallFrame list -> unit [@@js.set "callFrames"]
      (** Async stack trace, if any. *)
      (** Async stack trace, if any. *)
      val get_asyncStackTrace: t -> inspector_Runtime_StackTrace [@@js.get "asyncStackTrace"]
      (** Async stack trace, if any. *)
      val set_asyncStackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "asyncStackTrace"]
      (**
        Async stack trace, if any.
        experimental: 
      *)
      (**
        Async stack trace, if any.
        experimental: 
      *)
      val get_asyncStackTraceId: t -> inspector_Runtime_StackTraceId [@@js.get "asyncStackTraceId"]
      (**
        Async stack trace, if any.
        experimental: 
      *)
      val set_asyncStackTraceId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "asyncStackTraceId"]
    end
    module[@js.scope "GetScriptSourceReturnType"] GetScriptSourceReturnType : sig
      type t = inspector_Debugger_GetScriptSourceReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Script source. *)
      (** Script source. *)
      val get_scriptSource: t -> string [@@js.get "scriptSource"]
      (** Script source. *)
      val set_scriptSource: t -> string -> unit [@@js.set "scriptSource"]
    end
    module[@js.scope "EvaluateOnCallFrameReturnType"] EvaluateOnCallFrameReturnType : sig
      type t = inspector_Debugger_EvaluateOnCallFrameReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Object wrapper for the evaluation result. *)
      (** Object wrapper for the evaluation result. *)
      val get_result: t -> inspector_Runtime_RemoteObject [@@js.get "result"]
      (** Object wrapper for the evaluation result. *)
      val set_result: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "result"]
      (** Exception details. *)
      (** Exception details. *)
      val get_exceptionDetails: t -> inspector_Runtime_ExceptionDetails [@@js.get "exceptionDetails"]
      (** Exception details. *)
      val set_exceptionDetails: t -> inspector_Runtime_ExceptionDetails -> unit [@@js.set "exceptionDetails"]
    end
    module[@js.scope "ScriptParsedEventDataType"] ScriptParsedEventDataType : sig
      type t = inspector_Debugger_ScriptParsedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the script parsed. *)
      (** Identifier of the script parsed. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Identifier of the script parsed. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** URL or name of the script parsed (if any). *)
      (** URL or name of the script parsed (if any). *)
      val get_url: t -> string [@@js.get "url"]
      (** URL or name of the script parsed (if any). *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Line offset of the script within the resource with given URL (for script tags). *)
      (** Line offset of the script within the resource with given URL (for script tags). *)
      val get_startLine: t -> float [@@js.get "startLine"]
      (** Line offset of the script within the resource with given URL (for script tags). *)
      val set_startLine: t -> float -> unit [@@js.set "startLine"]
      (** Column offset of the script within the resource with given URL. *)
      (** Column offset of the script within the resource with given URL. *)
      val get_startColumn: t -> float [@@js.get "startColumn"]
      (** Column offset of the script within the resource with given URL. *)
      val set_startColumn: t -> float -> unit [@@js.set "startColumn"]
      (** Last line of the script. *)
      (** Last line of the script. *)
      val get_endLine: t -> float [@@js.get "endLine"]
      (** Last line of the script. *)
      val set_endLine: t -> float -> unit [@@js.set "endLine"]
      (** Length of the last line of the script. *)
      (** Length of the last line of the script. *)
      val get_endColumn: t -> float [@@js.get "endColumn"]
      (** Length of the last line of the script. *)
      val set_endColumn: t -> float -> unit [@@js.set "endColumn"]
      (** Specifies script creation context. *)
      (** Specifies script creation context. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Specifies script creation context. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
      (** Content hash of the script. *)
      (** Content hash of the script. *)
      val get_hash: t -> string [@@js.get "hash"]
      (** Content hash of the script. *)
      val set_hash: t -> string -> unit [@@js.set "hash"]
      (** Embedder-specific auxiliary data. *)
      (** Embedder-specific auxiliary data. *)
      val get_executionContextAuxData: t -> anonymous_interface_0 [@@js.get "executionContextAuxData"]
      (** Embedder-specific auxiliary data. *)
      val set_executionContextAuxData: t -> anonymous_interface_0 -> unit [@@js.set "executionContextAuxData"]
      (**
        True, if this script is generated as a result of the live edit operation.
        experimental: 
      *)
      (**
        True, if this script is generated as a result of the live edit operation.
        experimental: 
      *)
      val get_isLiveEdit: t -> bool [@@js.get "isLiveEdit"]
      (**
        True, if this script is generated as a result of the live edit operation.
        experimental: 
      *)
      val set_isLiveEdit: t -> bool -> unit [@@js.set "isLiveEdit"]
      (** URL of source map associated with script (if any). *)
      (** URL of source map associated with script (if any). *)
      val get_sourceMapURL: t -> string [@@js.get "sourceMapURL"]
      (** URL of source map associated with script (if any). *)
      val set_sourceMapURL: t -> string -> unit [@@js.set "sourceMapURL"]
      (** True, if this script has sourceURL. *)
      (** True, if this script has sourceURL. *)
      val get_hasSourceURL: t -> bool [@@js.get "hasSourceURL"]
      (** True, if this script has sourceURL. *)
      val set_hasSourceURL: t -> bool -> unit [@@js.set "hasSourceURL"]
      (** True, if this script is ES6 module. *)
      (** True, if this script is ES6 module. *)
      val get_isModule: t -> bool [@@js.get "isModule"]
      (** True, if this script is ES6 module. *)
      val set_isModule: t -> bool -> unit [@@js.set "isModule"]
      (** This script length. *)
      (** This script length. *)
      val get_length: t -> float [@@js.get "length"]
      (** This script length. *)
      val set_length: t -> float -> unit [@@js.set "length"]
      (**
        JavaScript top stack frame of where the script parsed event was triggered if available.
        experimental: 
      *)
      (**
        JavaScript top stack frame of where the script parsed event was triggered if available.
        experimental: 
      *)
      val get_stackTrace: t -> inspector_Runtime_StackTrace [@@js.get "stackTrace"]
      (**
        JavaScript top stack frame of where the script parsed event was triggered if available.
        experimental: 
      *)
      val set_stackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "stackTrace"]
    end
    module[@js.scope "ScriptFailedToParseEventDataType"] ScriptFailedToParseEventDataType : sig
      type t = inspector_Debugger_ScriptFailedToParseEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the script parsed. *)
      (** Identifier of the script parsed. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** Identifier of the script parsed. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** URL or name of the script parsed (if any). *)
      (** URL or name of the script parsed (if any). *)
      val get_url: t -> string [@@js.get "url"]
      (** URL or name of the script parsed (if any). *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Line offset of the script within the resource with given URL (for script tags). *)
      (** Line offset of the script within the resource with given URL (for script tags). *)
      val get_startLine: t -> float [@@js.get "startLine"]
      (** Line offset of the script within the resource with given URL (for script tags). *)
      val set_startLine: t -> float -> unit [@@js.set "startLine"]
      (** Column offset of the script within the resource with given URL. *)
      (** Column offset of the script within the resource with given URL. *)
      val get_startColumn: t -> float [@@js.get "startColumn"]
      (** Column offset of the script within the resource with given URL. *)
      val set_startColumn: t -> float -> unit [@@js.set "startColumn"]
      (** Last line of the script. *)
      (** Last line of the script. *)
      val get_endLine: t -> float [@@js.get "endLine"]
      (** Last line of the script. *)
      val set_endLine: t -> float -> unit [@@js.set "endLine"]
      (** Length of the last line of the script. *)
      (** Length of the last line of the script. *)
      val get_endColumn: t -> float [@@js.get "endColumn"]
      (** Length of the last line of the script. *)
      val set_endColumn: t -> float -> unit [@@js.set "endColumn"]
      (** Specifies script creation context. *)
      (** Specifies script creation context. *)
      val get_executionContextId: t -> inspector_Runtime_ExecutionContextId [@@js.get "executionContextId"]
      (** Specifies script creation context. *)
      val set_executionContextId: t -> inspector_Runtime_ExecutionContextId -> unit [@@js.set "executionContextId"]
      (** Content hash of the script. *)
      (** Content hash of the script. *)
      val get_hash: t -> string [@@js.get "hash"]
      (** Content hash of the script. *)
      val set_hash: t -> string -> unit [@@js.set "hash"]
      (** Embedder-specific auxiliary data. *)
      (** Embedder-specific auxiliary data. *)
      val get_executionContextAuxData: t -> anonymous_interface_0 [@@js.get "executionContextAuxData"]
      (** Embedder-specific auxiliary data. *)
      val set_executionContextAuxData: t -> anonymous_interface_0 -> unit [@@js.set "executionContextAuxData"]
      (** URL of source map associated with script (if any). *)
      (** URL of source map associated with script (if any). *)
      val get_sourceMapURL: t -> string [@@js.get "sourceMapURL"]
      (** URL of source map associated with script (if any). *)
      val set_sourceMapURL: t -> string -> unit [@@js.set "sourceMapURL"]
      (** True, if this script has sourceURL. *)
      (** True, if this script has sourceURL. *)
      val get_hasSourceURL: t -> bool [@@js.get "hasSourceURL"]
      (** True, if this script has sourceURL. *)
      val set_hasSourceURL: t -> bool -> unit [@@js.set "hasSourceURL"]
      (** True, if this script is ES6 module. *)
      (** True, if this script is ES6 module. *)
      val get_isModule: t -> bool [@@js.get "isModule"]
      (** True, if this script is ES6 module. *)
      val set_isModule: t -> bool -> unit [@@js.set "isModule"]
      (** This script length. *)
      (** This script length. *)
      val get_length: t -> float [@@js.get "length"]
      (** This script length. *)
      val set_length: t -> float -> unit [@@js.set "length"]
      (**
        JavaScript top stack frame of where the script parsed event was triggered if available.
        experimental: 
      *)
      (**
        JavaScript top stack frame of where the script parsed event was triggered if available.
        experimental: 
      *)
      val get_stackTrace: t -> inspector_Runtime_StackTrace [@@js.get "stackTrace"]
      (**
        JavaScript top stack frame of where the script parsed event was triggered if available.
        experimental: 
      *)
      val set_stackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "stackTrace"]
    end
    module[@js.scope "BreakpointResolvedEventDataType"] BreakpointResolvedEventDataType : sig
      type t = inspector_Debugger_BreakpointResolvedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Breakpoint unique identifier. *)
      (** Breakpoint unique identifier. *)
      val get_breakpointId: t -> inspector_Debugger_BreakpointId [@@js.get "breakpointId"]
      (** Breakpoint unique identifier. *)
      val set_breakpointId: t -> inspector_Debugger_BreakpointId -> unit [@@js.set "breakpointId"]
      (** Actual breakpoint location. *)
      (** Actual breakpoint location. *)
      val get_location: t -> inspector_Debugger_Location [@@js.get "location"]
      (** Actual breakpoint location. *)
      val set_location: t -> inspector_Debugger_Location -> unit [@@js.set "location"]
    end
    module[@js.scope "PausedEventDataType"] PausedEventDataType : sig
      type t = inspector_Debugger_PausedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Call stack the virtual machine stopped on. *)
      (** Call stack the virtual machine stopped on. *)
      val get_callFrames: t -> inspector_Debugger_CallFrame list [@@js.get "callFrames"]
      (** Call stack the virtual machine stopped on. *)
      val set_callFrames: t -> inspector_Debugger_CallFrame list -> unit [@@js.set "callFrames"]
      (** Pause reason. *)
      (** Pause reason. *)
      val get_reason: t -> string [@@js.get "reason"]
      (** Pause reason. *)
      val set_reason: t -> string -> unit [@@js.set "reason"]
      (** Object containing break-specific auxiliary properties. *)
      (** Object containing break-specific auxiliary properties. *)
      val get_data: t -> anonymous_interface_0 [@@js.get "data"]
      (** Object containing break-specific auxiliary properties. *)
      val set_data: t -> anonymous_interface_0 -> unit [@@js.set "data"]
      (** Hit breakpoints IDs *)
      (** Hit breakpoints IDs *)
      val get_hitBreakpoints: t -> string list [@@js.get "hitBreakpoints"]
      (** Hit breakpoints IDs *)
      val set_hitBreakpoints: t -> string list -> unit [@@js.set "hitBreakpoints"]
      (** Async stack trace, if any. *)
      (** Async stack trace, if any. *)
      val get_asyncStackTrace: t -> inspector_Runtime_StackTrace [@@js.get "asyncStackTrace"]
      (** Async stack trace, if any. *)
      val set_asyncStackTrace: t -> inspector_Runtime_StackTrace -> unit [@@js.set "asyncStackTrace"]
      (**
        Async stack trace, if any.
        experimental: 
      *)
      (**
        Async stack trace, if any.
        experimental: 
      *)
      val get_asyncStackTraceId: t -> inspector_Runtime_StackTraceId [@@js.get "asyncStackTraceId"]
      (**
        Async stack trace, if any.
        experimental: 
      *)
      val set_asyncStackTraceId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "asyncStackTraceId"]
      (**
        Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.
        experimental: 
      *)
      (**
        Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.
        experimental: 
      *)
      val get_asyncCallStackTraceId: t -> inspector_Runtime_StackTraceId [@@js.get "asyncCallStackTraceId"]
      (**
        Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.
        experimental: 
      *)
      val set_asyncCallStackTraceId: t -> inspector_Runtime_StackTraceId -> unit [@@js.set "asyncCallStackTraceId"]
    end
  end
  module[@js.scope "Console"] Console : sig
    (** Console message. *)
    module[@js.scope "ConsoleMessage"] ConsoleMessage : sig
      type t = inspector_Console_ConsoleMessage
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Message source. *)
      (** Message source. *)
      val get_source: t -> string [@@js.get "source"]
      (** Message source. *)
      val set_source: t -> string -> unit [@@js.set "source"]
      (** Message severity. *)
      (** Message severity. *)
      val get_level: t -> string [@@js.get "level"]
      (** Message severity. *)
      val set_level: t -> string -> unit [@@js.set "level"]
      (** Message text. *)
      (** Message text. *)
      val get_text: t -> string [@@js.get "text"]
      (** Message text. *)
      val set_text: t -> string -> unit [@@js.set "text"]
      (** URL of the message origin. *)
      (** URL of the message origin. *)
      val get_url: t -> string [@@js.get "url"]
      (** URL of the message origin. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Line number in the resource that generated this message (1-based). *)
      (** Line number in the resource that generated this message (1-based). *)
      val get_line: t -> float [@@js.get "line"]
      (** Line number in the resource that generated this message (1-based). *)
      val set_line: t -> float -> unit [@@js.set "line"]
      (** Column number in the resource that generated this message (1-based). *)
      (** Column number in the resource that generated this message (1-based). *)
      val get_column: t -> float [@@js.get "column"]
      (** Column number in the resource that generated this message (1-based). *)
      val set_column: t -> float -> unit [@@js.set "column"]
    end
    module[@js.scope "MessageAddedEventDataType"] MessageAddedEventDataType : sig
      type t = inspector_Console_MessageAddedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Console message that has been added. *)
      (** Console message that has been added. *)
      val get_message: t -> inspector_Console_ConsoleMessage [@@js.get "message"]
      (** Console message that has been added. *)
      val set_message: t -> inspector_Console_ConsoleMessage -> unit [@@js.set "message"]
    end
  end
  module[@js.scope "Profiler"] Profiler : sig
    (** Profile node. Holds callsite information, execution statistics and child nodes. *)
    module[@js.scope "ProfileNode"] ProfileNode : sig
      type t = inspector_Profiler_ProfileNode
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Unique id of the node. *)
      (** Unique id of the node. *)
      val get_id: t -> float [@@js.get "id"]
      (** Unique id of the node. *)
      val set_id: t -> float -> unit [@@js.set "id"]
      (** Function location. *)
      (** Function location. *)
      val get_callFrame: t -> inspector_Runtime_CallFrame [@@js.get "callFrame"]
      (** Function location. *)
      val set_callFrame: t -> inspector_Runtime_CallFrame -> unit [@@js.set "callFrame"]
      (** Number of samples where this node was on top of the call stack. *)
      (** Number of samples where this node was on top of the call stack. *)
      val get_hitCount: t -> float [@@js.get "hitCount"]
      (** Number of samples where this node was on top of the call stack. *)
      val set_hitCount: t -> float -> unit [@@js.set "hitCount"]
      (** Child node ids. *)
      (** Child node ids. *)
      val get_children: t -> float list [@@js.get "children"]
      (** Child node ids. *)
      val set_children: t -> float list -> unit [@@js.set "children"]
      (** The reason of being not optimized. The function may be deoptimized or marked as don't optimize. *)
      (** The reason of being not optimized. The function may be deoptimized or marked as don't optimize. *)
      val get_deoptReason: t -> string [@@js.get "deoptReason"]
      (** The reason of being not optimized. The function may be deoptimized or marked as don't optimize. *)
      val set_deoptReason: t -> string -> unit [@@js.set "deoptReason"]
      (** An array of source position ticks. *)
      (** An array of source position ticks. *)
      val get_positionTicks: t -> inspector_Profiler_PositionTickInfo list [@@js.get "positionTicks"]
      (** An array of source position ticks. *)
      val set_positionTicks: t -> inspector_Profiler_PositionTickInfo list -> unit [@@js.set "positionTicks"]
    end
    (** Profile. *)
    module[@js.scope "Profile"] Profile : sig
      type t = inspector_Profiler_Profile
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** The list of profile nodes. First item is the root node. *)
      (** The list of profile nodes. First item is the root node. *)
      val get_nodes: t -> inspector_Profiler_ProfileNode list [@@js.get "nodes"]
      (** The list of profile nodes. First item is the root node. *)
      val set_nodes: t -> inspector_Profiler_ProfileNode list -> unit [@@js.set "nodes"]
      (** Profiling start timestamp in microseconds. *)
      (** Profiling start timestamp in microseconds. *)
      val get_startTime: t -> float [@@js.get "startTime"]
      (** Profiling start timestamp in microseconds. *)
      val set_startTime: t -> float -> unit [@@js.set "startTime"]
      (** Profiling end timestamp in microseconds. *)
      (** Profiling end timestamp in microseconds. *)
      val get_endTime: t -> float [@@js.get "endTime"]
      (** Profiling end timestamp in microseconds. *)
      val set_endTime: t -> float -> unit [@@js.set "endTime"]
      (** Ids of samples top nodes. *)
      (** Ids of samples top nodes. *)
      val get_samples: t -> float list [@@js.get "samples"]
      (** Ids of samples top nodes. *)
      val set_samples: t -> float list -> unit [@@js.set "samples"]
      (** Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime. *)
      (** Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime. *)
      val get_timeDeltas: t -> float list [@@js.get "timeDeltas"]
      (** Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime. *)
      val set_timeDeltas: t -> float list -> unit [@@js.set "timeDeltas"]
    end
    (** Specifies a number of samples attributed to a certain source position. *)
    module[@js.scope "PositionTickInfo"] PositionTickInfo : sig
      type t = inspector_Profiler_PositionTickInfo
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Source line number (1-based). *)
      (** Source line number (1-based). *)
      val get_line: t -> float [@@js.get "line"]
      (** Source line number (1-based). *)
      val set_line: t -> float -> unit [@@js.set "line"]
      (** Number of samples attributed to the source line. *)
      (** Number of samples attributed to the source line. *)
      val get_ticks: t -> float [@@js.get "ticks"]
      (** Number of samples attributed to the source line. *)
      val set_ticks: t -> float -> unit [@@js.set "ticks"]
    end
    (** Coverage data for a source range. *)
    module[@js.scope "CoverageRange"] CoverageRange : sig
      type t = inspector_Profiler_CoverageRange
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** JavaScript script source offset for the range start. *)
      (** JavaScript script source offset for the range start. *)
      val get_startOffset: t -> float [@@js.get "startOffset"]
      (** JavaScript script source offset for the range start. *)
      val set_startOffset: t -> float -> unit [@@js.set "startOffset"]
      (** JavaScript script source offset for the range end. *)
      (** JavaScript script source offset for the range end. *)
      val get_endOffset: t -> float [@@js.get "endOffset"]
      (** JavaScript script source offset for the range end. *)
      val set_endOffset: t -> float -> unit [@@js.set "endOffset"]
      (** Collected execution count of the source range. *)
      (** Collected execution count of the source range. *)
      val get_count: t -> float [@@js.get "count"]
      (** Collected execution count of the source range. *)
      val set_count: t -> float -> unit [@@js.set "count"]
    end
    (** Coverage data for a JavaScript function. *)
    module[@js.scope "FunctionCoverage"] FunctionCoverage : sig
      type t = inspector_Profiler_FunctionCoverage
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** JavaScript function name. *)
      (** JavaScript function name. *)
      val get_functionName: t -> string [@@js.get "functionName"]
      (** JavaScript function name. *)
      val set_functionName: t -> string -> unit [@@js.set "functionName"]
      (** Source ranges inside the function with coverage data. *)
      (** Source ranges inside the function with coverage data. *)
      val get_ranges: t -> inspector_Profiler_CoverageRange list [@@js.get "ranges"]
      (** Source ranges inside the function with coverage data. *)
      val set_ranges: t -> inspector_Profiler_CoverageRange list -> unit [@@js.set "ranges"]
      (** Whether coverage data for this function has block granularity. *)
      (** Whether coverage data for this function has block granularity. *)
      val get_isBlockCoverage: t -> bool [@@js.get "isBlockCoverage"]
      (** Whether coverage data for this function has block granularity. *)
      val set_isBlockCoverage: t -> bool -> unit [@@js.set "isBlockCoverage"]
    end
    (** Coverage data for a JavaScript script. *)
    module[@js.scope "ScriptCoverage"] ScriptCoverage : sig
      type t = inspector_Profiler_ScriptCoverage
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** JavaScript script id. *)
      (** JavaScript script id. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** JavaScript script id. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** JavaScript script name or url. *)
      (** JavaScript script name or url. *)
      val get_url: t -> string [@@js.get "url"]
      (** JavaScript script name or url. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Functions contained in the script that has coverage data. *)
      (** Functions contained in the script that has coverage data. *)
      val get_functions: t -> inspector_Profiler_FunctionCoverage list [@@js.get "functions"]
      (** Functions contained in the script that has coverage data. *)
      val set_functions: t -> inspector_Profiler_FunctionCoverage list -> unit [@@js.set "functions"]
    end
    (**
      Describes a type collected during runtime.
      experimental: 
    *)
    module[@js.scope "TypeObject"] TypeObject : sig
      type t = inspector_Profiler_TypeObject
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Name of a type collected with type profiling. *)
      (** Name of a type collected with type profiling. *)
      val get_name: t -> string [@@js.get "name"]
      (** Name of a type collected with type profiling. *)
      val set_name: t -> string -> unit [@@js.set "name"]
    end
    (**
      Source offset and types for a parameter or return value.
      experimental: 
    *)
    module[@js.scope "TypeProfileEntry"] TypeProfileEntry : sig
      type t = inspector_Profiler_TypeProfileEntry
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Source offset of the parameter or end of function for return values. *)
      (** Source offset of the parameter or end of function for return values. *)
      val get_offset: t -> float [@@js.get "offset"]
      (** Source offset of the parameter or end of function for return values. *)
      val set_offset: t -> float -> unit [@@js.set "offset"]
      (** The types for this parameter or return value. *)
      (** The types for this parameter or return value. *)
      val get_types: t -> inspector_Profiler_TypeObject list [@@js.get "types"]
      (** The types for this parameter or return value. *)
      val set_types: t -> inspector_Profiler_TypeObject list -> unit [@@js.set "types"]
    end
    (**
      Type profile data collected during runtime for a JavaScript script.
      experimental: 
    *)
    module[@js.scope "ScriptTypeProfile"] ScriptTypeProfile : sig
      type t = inspector_Profiler_ScriptTypeProfile
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** JavaScript script id. *)
      (** JavaScript script id. *)
      val get_scriptId: t -> inspector_Runtime_ScriptId [@@js.get "scriptId"]
      (** JavaScript script id. *)
      val set_scriptId: t -> inspector_Runtime_ScriptId -> unit [@@js.set "scriptId"]
      (** JavaScript script name or url. *)
      (** JavaScript script name or url. *)
      val get_url: t -> string [@@js.get "url"]
      (** JavaScript script name or url. *)
      val set_url: t -> string -> unit [@@js.set "url"]
      (** Type profile entries for parameters and return values of the functions in the script. *)
      (** Type profile entries for parameters and return values of the functions in the script. *)
      val get_entries: t -> inspector_Profiler_TypeProfileEntry list [@@js.get "entries"]
      (** Type profile entries for parameters and return values of the functions in the script. *)
      val set_entries: t -> inspector_Profiler_TypeProfileEntry list -> unit [@@js.set "entries"]
    end
    module[@js.scope "SetSamplingIntervalParameterType"] SetSamplingIntervalParameterType : sig
      type t = inspector_Profiler_SetSamplingIntervalParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** New sampling interval in microseconds. *)
      (** New sampling interval in microseconds. *)
      val get_interval: t -> float [@@js.get "interval"]
      (** New sampling interval in microseconds. *)
      val set_interval: t -> float -> unit [@@js.set "interval"]
    end
    module[@js.scope "StartPreciseCoverageParameterType"] StartPreciseCoverageParameterType : sig
      type t = inspector_Profiler_StartPreciseCoverageParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Collect accurate call counts beyond simple 'covered' or 'not covered'. *)
      (** Collect accurate call counts beyond simple 'covered' or 'not covered'. *)
      val get_callCount: t -> bool [@@js.get "callCount"]
      (** Collect accurate call counts beyond simple 'covered' or 'not covered'. *)
      val set_callCount: t -> bool -> unit [@@js.set "callCount"]
      (** Collect block-based coverage. *)
      (** Collect block-based coverage. *)
      val get_detailed: t -> bool [@@js.get "detailed"]
      (** Collect block-based coverage. *)
      val set_detailed: t -> bool -> unit [@@js.set "detailed"]
    end
    module[@js.scope "StopReturnType"] StopReturnType : sig
      type t = inspector_Profiler_StopReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Recorded profile. *)
      (** Recorded profile. *)
      val get_profile: t -> inspector_Profiler_Profile [@@js.get "profile"]
      (** Recorded profile. *)
      val set_profile: t -> inspector_Profiler_Profile -> unit [@@js.set "profile"]
    end
    module[@js.scope "TakePreciseCoverageReturnType"] TakePreciseCoverageReturnType : sig
      type t = inspector_Profiler_TakePreciseCoverageReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Coverage data for the current isolate. *)
      (** Coverage data for the current isolate. *)
      val get_result: t -> inspector_Profiler_ScriptCoverage list [@@js.get "result"]
      (** Coverage data for the current isolate. *)
      val set_result: t -> inspector_Profiler_ScriptCoverage list -> unit [@@js.set "result"]
    end
    module[@js.scope "GetBestEffortCoverageReturnType"] GetBestEffortCoverageReturnType : sig
      type t = inspector_Profiler_GetBestEffortCoverageReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Coverage data for the current isolate. *)
      (** Coverage data for the current isolate. *)
      val get_result: t -> inspector_Profiler_ScriptCoverage list [@@js.get "result"]
      (** Coverage data for the current isolate. *)
      val set_result: t -> inspector_Profiler_ScriptCoverage list -> unit [@@js.set "result"]
    end
    module[@js.scope "TakeTypeProfileReturnType"] TakeTypeProfileReturnType : sig
      type t = inspector_Profiler_TakeTypeProfileReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Type profile for all scripts since startTypeProfile() was turned on. *)
      (** Type profile for all scripts since startTypeProfile() was turned on. *)
      val get_result: t -> inspector_Profiler_ScriptTypeProfile list [@@js.get "result"]
      (** Type profile for all scripts since startTypeProfile() was turned on. *)
      val set_result: t -> inspector_Profiler_ScriptTypeProfile list -> unit [@@js.set "result"]
    end
    module[@js.scope "ConsoleProfileStartedEventDataType"] ConsoleProfileStartedEventDataType : sig
      type t = inspector_Profiler_ConsoleProfileStartedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_id: t -> string [@@js.get "id"]
      val set_id: t -> string -> unit [@@js.set "id"]
      (** Location of console.profile(). *)
      (** Location of console.profile(). *)
      val get_location: t -> inspector_Debugger_Location [@@js.get "location"]
      (** Location of console.profile(). *)
      val set_location: t -> inspector_Debugger_Location -> unit [@@js.set "location"]
      (** Profile title passed as an argument to console.profile(). *)
      (** Profile title passed as an argument to console.profile(). *)
      val get_title: t -> string [@@js.get "title"]
      (** Profile title passed as an argument to console.profile(). *)
      val set_title: t -> string -> unit [@@js.set "title"]
    end
    module[@js.scope "ConsoleProfileFinishedEventDataType"] ConsoleProfileFinishedEventDataType : sig
      type t = inspector_Profiler_ConsoleProfileFinishedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_id: t -> string [@@js.get "id"]
      val set_id: t -> string -> unit [@@js.set "id"]
      (** Location of console.profileEnd(). *)
      (** Location of console.profileEnd(). *)
      val get_location: t -> inspector_Debugger_Location [@@js.get "location"]
      (** Location of console.profileEnd(). *)
      val set_location: t -> inspector_Debugger_Location -> unit [@@js.set "location"]
      val get_profile: t -> inspector_Profiler_Profile [@@js.get "profile"]
      val set_profile: t -> inspector_Profiler_Profile -> unit [@@js.set "profile"]
      (** Profile title passed as an argument to console.profile(). *)
      (** Profile title passed as an argument to console.profile(). *)
      val get_title: t -> string [@@js.get "title"]
      (** Profile title passed as an argument to console.profile(). *)
      val set_title: t -> string -> unit [@@js.set "title"]
    end
  end
  module[@js.scope "HeapProfiler"] HeapProfiler : sig
    (** Heap snapshot object id. *)
    module HeapSnapshotObjectId : sig
      type t = inspector_HeapProfiler_HeapSnapshotObjectId
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes. *)
    module[@js.scope "SamplingHeapProfileNode"] SamplingHeapProfileNode : sig
      type t = inspector_HeapProfiler_SamplingHeapProfileNode
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Function location. *)
      (** Function location. *)
      val get_callFrame: t -> inspector_Runtime_CallFrame [@@js.get "callFrame"]
      (** Function location. *)
      val set_callFrame: t -> inspector_Runtime_CallFrame -> unit [@@js.set "callFrame"]
      (** Allocations size in bytes for the node excluding children. *)
      (** Allocations size in bytes for the node excluding children. *)
      val get_selfSize: t -> float [@@js.get "selfSize"]
      (** Allocations size in bytes for the node excluding children. *)
      val set_selfSize: t -> float -> unit [@@js.set "selfSize"]
      (** Child nodes. *)
      (** Child nodes. *)
      val get_children: t -> t list [@@js.get "children"]
      (** Child nodes. *)
      val set_children: t -> t list -> unit [@@js.set "children"]
    end
    (** Profile. *)
    module[@js.scope "SamplingHeapProfile"] SamplingHeapProfile : sig
      type t = inspector_HeapProfiler_SamplingHeapProfile
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_head: t -> inspector_HeapProfiler_SamplingHeapProfileNode [@@js.get "head"]
      val set_head: t -> inspector_HeapProfiler_SamplingHeapProfileNode -> unit [@@js.set "head"]
    end
    module[@js.scope "StartTrackingHeapObjectsParameterType"] StartTrackingHeapObjectsParameterType : sig
      type t = inspector_HeapProfiler_StartTrackingHeapObjectsParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_trackAllocations: t -> bool [@@js.get "trackAllocations"]
      val set_trackAllocations: t -> bool -> unit [@@js.set "trackAllocations"]
    end
    module[@js.scope "StopTrackingHeapObjectsParameterType"] StopTrackingHeapObjectsParameterType : sig
      type t = inspector_HeapProfiler_StopTrackingHeapObjectsParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped. *)
      (** If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped. *)
      val get_reportProgress: t -> bool [@@js.get "reportProgress"]
      (** If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped. *)
      val set_reportProgress: t -> bool -> unit [@@js.set "reportProgress"]
    end
    module[@js.scope "TakeHeapSnapshotParameterType"] TakeHeapSnapshotParameterType : sig
      type t = inspector_HeapProfiler_TakeHeapSnapshotParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken. *)
      (** If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken. *)
      val get_reportProgress: t -> bool [@@js.get "reportProgress"]
      (** If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken. *)
      val set_reportProgress: t -> bool -> unit [@@js.set "reportProgress"]
    end
    module[@js.scope "GetObjectByHeapObjectIdParameterType"] GetObjectByHeapObjectIdParameterType : sig
      type t = inspector_HeapProfiler_GetObjectByHeapObjectIdParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_objectId: t -> inspector_HeapProfiler_HeapSnapshotObjectId [@@js.get "objectId"]
      val set_objectId: t -> inspector_HeapProfiler_HeapSnapshotObjectId -> unit [@@js.set "objectId"]
      (** Symbolic group name that can be used to release multiple objects. *)
      (** Symbolic group name that can be used to release multiple objects. *)
      val get_objectGroup: t -> string [@@js.get "objectGroup"]
      (** Symbolic group name that can be used to release multiple objects. *)
      val set_objectGroup: t -> string -> unit [@@js.set "objectGroup"]
    end
    module[@js.scope "AddInspectedHeapObjectParameterType"] AddInspectedHeapObjectParameterType : sig
      type t = inspector_HeapProfiler_AddInspectedHeapObjectParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Heap snapshot object id to be accessible by means of $x command line API. *)
      (** Heap snapshot object id to be accessible by means of $x command line API. *)
      val get_heapObjectId: t -> inspector_HeapProfiler_HeapSnapshotObjectId [@@js.get "heapObjectId"]
      (** Heap snapshot object id to be accessible by means of $x command line API. *)
      val set_heapObjectId: t -> inspector_HeapProfiler_HeapSnapshotObjectId -> unit [@@js.set "heapObjectId"]
    end
    module[@js.scope "GetHeapObjectIdParameterType"] GetHeapObjectIdParameterType : sig
      type t = inspector_HeapProfiler_GetHeapObjectIdParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of the object to get heap object id for. *)
      (** Identifier of the object to get heap object id for. *)
      val get_objectId: t -> inspector_Runtime_RemoteObjectId [@@js.get "objectId"]
      (** Identifier of the object to get heap object id for. *)
      val set_objectId: t -> inspector_Runtime_RemoteObjectId -> unit [@@js.set "objectId"]
    end
    module[@js.scope "StartSamplingParameterType"] StartSamplingParameterType : sig
      type t = inspector_HeapProfiler_StartSamplingParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes. *)
      (** Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes. *)
      val get_samplingInterval: t -> float [@@js.get "samplingInterval"]
      (** Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes. *)
      val set_samplingInterval: t -> float -> unit [@@js.set "samplingInterval"]
    end
    module[@js.scope "GetObjectByHeapObjectIdReturnType"] GetObjectByHeapObjectIdReturnType : sig
      type t = inspector_HeapProfiler_GetObjectByHeapObjectIdReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Evaluation result. *)
      (** Evaluation result. *)
      val get_result: t -> inspector_Runtime_RemoteObject [@@js.get "result"]
      (** Evaluation result. *)
      val set_result: t -> inspector_Runtime_RemoteObject -> unit [@@js.set "result"]
    end
    module[@js.scope "GetHeapObjectIdReturnType"] GetHeapObjectIdReturnType : sig
      type t = inspector_HeapProfiler_GetHeapObjectIdReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Id of the heap snapshot object corresponding to the passed remote object id. *)
      (** Id of the heap snapshot object corresponding to the passed remote object id. *)
      val get_heapSnapshotObjectId: t -> inspector_HeapProfiler_HeapSnapshotObjectId [@@js.get "heapSnapshotObjectId"]
      (** Id of the heap snapshot object corresponding to the passed remote object id. *)
      val set_heapSnapshotObjectId: t -> inspector_HeapProfiler_HeapSnapshotObjectId -> unit [@@js.set "heapSnapshotObjectId"]
    end
    module[@js.scope "StopSamplingReturnType"] StopSamplingReturnType : sig
      type t = inspector_HeapProfiler_StopSamplingReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Recorded sampling heap profile. *)
      (** Recorded sampling heap profile. *)
      val get_profile: t -> inspector_HeapProfiler_SamplingHeapProfile [@@js.get "profile"]
      (** Recorded sampling heap profile. *)
      val set_profile: t -> inspector_HeapProfiler_SamplingHeapProfile -> unit [@@js.set "profile"]
    end
    module[@js.scope "GetSamplingProfileReturnType"] GetSamplingProfileReturnType : sig
      type t = inspector_HeapProfiler_GetSamplingProfileReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Return the sampling profile being collected. *)
      (** Return the sampling profile being collected. *)
      val get_profile: t -> inspector_HeapProfiler_SamplingHeapProfile [@@js.get "profile"]
      (** Return the sampling profile being collected. *)
      val set_profile: t -> inspector_HeapProfiler_SamplingHeapProfile -> unit [@@js.set "profile"]
    end
    module[@js.scope "AddHeapSnapshotChunkEventDataType"] AddHeapSnapshotChunkEventDataType : sig
      type t = inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_chunk: t -> string [@@js.get "chunk"]
      val set_chunk: t -> string -> unit [@@js.set "chunk"]
    end
    module[@js.scope "ReportHeapSnapshotProgressEventDataType"] ReportHeapSnapshotProgressEventDataType : sig
      type t = inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_done: t -> float [@@js.get "done"]
      val set_done: t -> float -> unit [@@js.set "done"]
      val get_total: t -> float [@@js.get "total"]
      val set_total: t -> float -> unit [@@js.set "total"]
      val get_finished: t -> bool [@@js.get "finished"]
      val set_finished: t -> bool -> unit [@@js.set "finished"]
    end
    module[@js.scope "LastSeenObjectIdEventDataType"] LastSeenObjectIdEventDataType : sig
      type t = inspector_HeapProfiler_LastSeenObjectIdEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_lastSeenObjectId: t -> float [@@js.get "lastSeenObjectId"]
      val set_lastSeenObjectId: t -> float -> unit [@@js.set "lastSeenObjectId"]
      val get_timestamp: t -> float [@@js.get "timestamp"]
      val set_timestamp: t -> float -> unit [@@js.set "timestamp"]
    end
    module[@js.scope "HeapStatsUpdateEventDataType"] HeapStatsUpdateEventDataType : sig
      type t = inspector_HeapProfiler_HeapStatsUpdateEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment. *)
      (** An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment. *)
      val get_statsUpdate: t -> float list [@@js.get "statsUpdate"]
      (** An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment. *)
      val set_statsUpdate: t -> float list -> unit [@@js.set "statsUpdate"]
    end
  end
  module[@js.scope "NodeTracing"] NodeTracing : sig
    module[@js.scope "TraceConfig"] TraceConfig : sig
      type t = inspector_NodeTracing_TraceConfig
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Controls how the trace buffer stores data. *)
      (** Controls how the trace buffer stores data. *)
      val get_recordMode: t -> string [@@js.get "recordMode"]
      (** Controls how the trace buffer stores data. *)
      val set_recordMode: t -> string -> unit [@@js.set "recordMode"]
      (** Included category filters. *)
      (** Included category filters. *)
      val get_includedCategories: t -> string list [@@js.get "includedCategories"]
      (** Included category filters. *)
      val set_includedCategories: t -> string list -> unit [@@js.set "includedCategories"]
    end
    module[@js.scope "StartParameterType"] StartParameterType : sig
      type t = inspector_NodeTracing_StartParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_traceConfig: t -> inspector_NodeTracing_TraceConfig [@@js.get "traceConfig"]
      val set_traceConfig: t -> inspector_NodeTracing_TraceConfig -> unit [@@js.set "traceConfig"]
    end
    module[@js.scope "GetCategoriesReturnType"] GetCategoriesReturnType : sig
      type t = inspector_NodeTracing_GetCategoriesReturnType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** A list of supported tracing categories. *)
      (** A list of supported tracing categories. *)
      val get_categories: t -> string list [@@js.get "categories"]
      (** A list of supported tracing categories. *)
      val set_categories: t -> string list -> unit [@@js.set "categories"]
    end
    module[@js.scope "DataCollectedEventDataType"] DataCollectedEventDataType : sig
      type t = inspector_NodeTracing_DataCollectedEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_value: t -> anonymous_interface_0 list [@@js.get "value"]
      val set_value: t -> anonymous_interface_0 list -> unit [@@js.set "value"]
    end
  end
  module[@js.scope "NodeWorker"] NodeWorker : sig
    module WorkerID : sig
      type t = inspector_NodeWorker_WorkerID
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    (** Unique identifier of attached debugging session. *)
    module SessionID : sig
      type t = inspector_NodeWorker_SessionID
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
    end
    module[@js.scope "WorkerInfo"] WorkerInfo : sig
      type t = inspector_NodeWorker_WorkerInfo
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_workerId: t -> inspector_NodeWorker_WorkerID [@@js.get "workerId"]
      val set_workerId: t -> inspector_NodeWorker_WorkerID -> unit [@@js.set "workerId"]
      val get_type: t -> string [@@js.get "type"]
      val set_type: t -> string -> unit [@@js.set "type"]
      val get_title: t -> string [@@js.get "title"]
      val set_title: t -> string -> unit [@@js.set "title"]
      val get_url: t -> string [@@js.get "url"]
      val set_url: t -> string -> unit [@@js.set "url"]
    end
    module[@js.scope "SendMessageToWorkerParameterType"] SendMessageToWorkerParameterType : sig
      type t = inspector_NodeWorker_SendMessageToWorkerParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_message: t -> string [@@js.get "message"]
      val set_message: t -> string -> unit [@@js.set "message"]
      (** Identifier of the session. *)
      (** Identifier of the session. *)
      val get_sessionId: t -> inspector_NodeWorker_SessionID [@@js.get "sessionId"]
      (** Identifier of the session. *)
      val set_sessionId: t -> inspector_NodeWorker_SessionID -> unit [@@js.set "sessionId"]
    end
    module[@js.scope "EnableParameterType"] EnableParameterType : sig
      type t = inspector_NodeWorker_EnableParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (**
        Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`
        message to run them.
      *)
      (**
        Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`
        message to run them.
      *)
      val get_waitForDebuggerOnStart: t -> bool [@@js.get "waitForDebuggerOnStart"]
      (**
        Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`
        message to run them.
      *)
      val set_waitForDebuggerOnStart: t -> bool -> unit [@@js.set "waitForDebuggerOnStart"]
    end
    module[@js.scope "DetachParameterType"] DetachParameterType : sig
      type t = inspector_NodeWorker_DetachParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_sessionId: t -> inspector_NodeWorker_SessionID [@@js.get "sessionId"]
      val set_sessionId: t -> inspector_NodeWorker_SessionID -> unit [@@js.set "sessionId"]
    end
    module[@js.scope "AttachedToWorkerEventDataType"] AttachedToWorkerEventDataType : sig
      type t = inspector_NodeWorker_AttachedToWorkerEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier assigned to the session used to send/receive messages. *)
      (** Identifier assigned to the session used to send/receive messages. *)
      val get_sessionId: t -> inspector_NodeWorker_SessionID [@@js.get "sessionId"]
      (** Identifier assigned to the session used to send/receive messages. *)
      val set_sessionId: t -> inspector_NodeWorker_SessionID -> unit [@@js.set "sessionId"]
      val get_workerInfo: t -> inspector_NodeWorker_WorkerInfo [@@js.get "workerInfo"]
      val set_workerInfo: t -> inspector_NodeWorker_WorkerInfo -> unit [@@js.set "workerInfo"]
      val get_waitingForDebugger: t -> bool [@@js.get "waitingForDebugger"]
      val set_waitingForDebugger: t -> bool -> unit [@@js.set "waitingForDebugger"]
    end
    module[@js.scope "DetachedFromWorkerEventDataType"] DetachedFromWorkerEventDataType : sig
      type t = inspector_NodeWorker_DetachedFromWorkerEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Detached session identifier. *)
      (** Detached session identifier. *)
      val get_sessionId: t -> inspector_NodeWorker_SessionID [@@js.get "sessionId"]
      (** Detached session identifier. *)
      val set_sessionId: t -> inspector_NodeWorker_SessionID -> unit [@@js.set "sessionId"]
    end
    module[@js.scope "ReceivedMessageFromWorkerEventDataType"] ReceivedMessageFromWorkerEventDataType : sig
      type t = inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** Identifier of a session which sends a message. *)
      (** Identifier of a session which sends a message. *)
      val get_sessionId: t -> inspector_NodeWorker_SessionID [@@js.get "sessionId"]
      (** Identifier of a session which sends a message. *)
      val set_sessionId: t -> inspector_NodeWorker_SessionID -> unit [@@js.set "sessionId"]
      val get_message: t -> string [@@js.get "message"]
      val set_message: t -> string -> unit [@@js.set "message"]
    end
  end
  module[@js.scope "NodeRuntime"] NodeRuntime : sig
    module[@js.scope "NotifyWhenWaitingForDisconnectParameterType"] NotifyWhenWaitingForDisconnectParameterType : sig
      type t = inspector_NodeRuntime_NotifyWhenWaitingForDisconnectParameterType
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_enabled: t -> bool [@@js.get "enabled"]
      val set_enabled: t -> bool -> unit [@@js.set "enabled"]
    end
  end
  (** The inspector.Session is used for dispatching messages to the V8 inspector back-end and receiving message responses and notifications. *)
  module[@js.scope "Session"] Session : sig
    type t = inspector_Session
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Create a new instance of the inspector.Session class.
      The inspector session needs to be connected through session.connect() before the messages can be dispatched to the inspector backend.
    *)
    val create: unit -> t [@@js.create]
    (**
      Connects a session to the inspector back-end.
      An exception will be thrown if there is already a connected session established either
      through the API or by a front-end connected to the Inspector WebSocket port.
    *)
    val connect: t -> unit [@@js.call "connect"]
    (**
      Immediately close the session. All pending message callbacks will be called with an error.
      session.connect() will need to be called to be able to send messages again.
      Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
    *)
    val disconnect: t -> unit [@@js.call "disconnect"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
    *)
    val post: t -> method_:string -> ?params:anonymous_interface_0 -> ?callback:(err:Error.t_0 or_null -> ?params:anonymous_interface_0 -> unit -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post': t -> method_:string -> ?callback:(err:Error.t_0 or_null -> ?params:anonymous_interface_0 -> unit -> unit) -> unit -> unit [@@js.call "post"]
    (** Returns supported domains. *)
    val post'': t -> method_:([`L_s160_Schema_getDomains] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Schema_GetDomainsReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Evaluates expression on global object. *)
    val post''': t -> method_:([`L_s106_Runtime_evaluate] [@js.enum]) -> ?params:inspector_Runtime_EvaluateParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_EvaluateReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''': t -> method_:([`L_s106_Runtime_evaluate] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_EvaluateReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Add handler to promise with given promise object id. *)
    val post''''': t -> method_:([`L_s99_Runtime_awaitPromise] [@js.enum]) -> ?params:inspector_Runtime_AwaitPromiseParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_AwaitPromiseReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''': t -> method_:([`L_s99_Runtime_awaitPromise] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_AwaitPromiseReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Calls function with given declaration on the given object. Object group of the result is inherited from the target object. *)
    val post''''''': t -> method_:([`L_s100_Runtime_callFunctionOn] [@js.enum]) -> ?params:inspector_Runtime_CallFunctionOnParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_CallFunctionOnReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''': t -> method_:([`L_s100_Runtime_callFunctionOn] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_CallFunctionOnReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Returns properties of a given object. Object group of the result is inherited from the target object. *)
    val post''''''''': t -> method_:([`L_s112_Runtime_getProperties] [@js.enum]) -> ?params:inspector_Runtime_GetPropertiesParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_GetPropertiesReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''': t -> method_:([`L_s112_Runtime_getProperties] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_GetPropertiesReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Releases remote object with given id. *)
    val post''''''''''': t -> method_:([`L_s116_Runtime_releaseObject] [@js.enum]) -> ?params:inspector_Runtime_ReleaseObjectParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''': t -> method_:([`L_s116_Runtime_releaseObject] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Releases all remote objects that belong to a given group. *)
    val post''''''''''''': t -> method_:([`L_s117_Runtime_releaseObjectGroup] [@js.enum]) -> ?params:inspector_Runtime_ReleaseObjectGroupParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''': t -> method_:([`L_s117_Runtime_releaseObjectGroup] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Tells inspected instance to run if it was waiting for debugger to attach. *)
    val post''''''''''''''': t -> method_:([`L_s118_Runtime_runIfWaitingForDebugger] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context. *)
    val post'''''''''''''''': t -> method_:([`L_s105_Runtime_enable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Disables reporting of execution contexts creation. *)
    val post''''''''''''''''': t -> method_:([`L_s103_Runtime_disable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Discards collected exceptions and console API calls. *)
    val post'''''''''''''''''': t -> method_:([`L_s104_Runtime_discardConsoleEntries] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** experimental:  *)
    val post''''''''''''''''''': t -> method_:([`L_s120_Runtime_setCustomObjectFormatterEnabled] [@js.enum]) -> ?params:inspector_Runtime_SetCustomObjectFormatterEnabledParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''': t -> method_:([`L_s120_Runtime_setCustomObjectFormatterEnabled] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Compiles expression. *)
    val post''''''''''''''''''''': t -> method_:([`L_s101_Runtime_compileScript] [@js.enum]) -> ?params:inspector_Runtime_CompileScriptParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_CompileScriptReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''': t -> method_:([`L_s101_Runtime_compileScript] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_CompileScriptReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Runs script with given id in a given context. *)
    val post''''''''''''''''''''''': t -> method_:([`L_s119_Runtime_runScript] [@js.enum]) -> ?params:inspector_Runtime_RunScriptParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_RunScriptReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''': t -> method_:([`L_s119_Runtime_runScript] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_RunScriptReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''': t -> method_:([`L_s115_Runtime_queryObjects] [@js.enum]) -> ?params:inspector_Runtime_QueryObjectsParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_QueryObjectsReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''': t -> method_:([`L_s115_Runtime_queryObjects] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_QueryObjectsReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Returns all let, const and class variables from global scope. *)
    val post''''''''''''''''''''''''''': t -> method_:([`L_s113_Runtime_globalLexicalScopeNames] [@js.enum]) -> ?params:inspector_Runtime_GlobalLexicalScopeNamesParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_GlobalLexicalScopeNamesReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''': t -> method_:([`L_s113_Runtime_globalLexicalScopeNames] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Runtime_GlobalLexicalScopeNamesReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received. *)
    val post''''''''''''''''''''''''''''': t -> method_:([`L_s14_Debugger_enable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_EnableReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Disables debugger for given page. *)
    val post'''''''''''''''''''''''''''''': t -> method_:([`L_s13_Debugger_disable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Activates / deactivates all breakpoints on the page. *)
    val post''''''''''''''''''''''''''''''': t -> method_:([`L_s35_Debugger_setBreakpointsActive] [@js.enum]) -> ?params:inspector_Debugger_SetBreakpointsActiveParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''': t -> method_:([`L_s35_Debugger_setBreakpointsActive] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). *)
    val post''''''''''''''''''''''''''''''''': t -> method_:([`L_s39_Debugger_setSkipAllPauses] [@js.enum]) -> ?params:inspector_Debugger_SetSkipAllPausesParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''': t -> method_:([`L_s39_Debugger_setSkipAllPauses] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads. *)
    val post''''''''''''''''''''''''''''''''''': t -> method_:([`L_s34_Debugger_setBreakpointByUrl] [@js.enum]) -> ?params:inspector_Debugger_SetBreakpointByUrlParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SetBreakpointByUrlReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''': t -> method_:([`L_s34_Debugger_setBreakpointByUrl] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SetBreakpointByUrlReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Sets JavaScript breakpoint at a given location. *)
    val post''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s33_Debugger_setBreakpoint] [@js.enum]) -> ?params:inspector_Debugger_SetBreakpointParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SetBreakpointReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s33_Debugger_setBreakpoint] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SetBreakpointReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Removes JavaScript breakpoint. *)
    val post''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s22_Debugger_removeBreakpoint] [@js.enum]) -> ?params:inspector_Debugger_RemoveBreakpointParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s22_Debugger_removeBreakpoint] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Returns possible locations for breakpoint. scriptId in start and end range locations should be the same. *)
    val post''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s16_Debugger_getPossibleBreakpoints] [@js.enum]) -> ?params:inspector_Debugger_GetPossibleBreakpointsParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_GetPossibleBreakpointsReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s16_Debugger_getPossibleBreakpoints] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_GetPossibleBreakpointsReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Continues execution until specific location is reached. *)
    val post''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s12_Debugger_continueToLocation] [@js.enum]) -> ?params:inspector_Debugger_ContinueToLocationParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s12_Debugger_continueToLocation] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** experimental:  *)
    val post''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s20_Debugger_pauseOnAsyncCall] [@js.enum]) -> ?params:inspector_Debugger_PauseOnAsyncCallParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s20_Debugger_pauseOnAsyncCall] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Steps over the statement. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s43_Debugger_stepOver] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Steps into the function call. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s41_Debugger_stepInto] [@js.enum]) -> ?params:inspector_Debugger_StepIntoParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s41_Debugger_stepInto] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Steps out of the function call. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s42_Debugger_stepOut] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Stops on the next JavaScript statement. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s19_Debugger_pause] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s26_Debugger_scheduleStepIntoAsync] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Resumes JavaScript execution. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s24_Debugger_resume] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Returns stack trace with given <code>stackTraceId</code>.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s18_Debugger_getStackTrace] [@js.enum]) -> ?params:inspector_Debugger_GetStackTraceParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_GetStackTraceReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s18_Debugger_getStackTrace] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_GetStackTraceReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Searches for given string in script content. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s29_Debugger_searchInContent] [@js.enum]) -> ?params:inspector_Debugger_SearchInContentParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SearchInContentReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s29_Debugger_searchInContent] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SearchInContentReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Edits JavaScript source live. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s38_Debugger_setScriptSource] [@js.enum]) -> ?params:inspector_Debugger_SetScriptSourceParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SetScriptSourceReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s38_Debugger_setScriptSource] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_SetScriptSourceReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Restarts particular call frame from the beginning. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s23_Debugger_restartFrame] [@js.enum]) -> ?params:inspector_Debugger_RestartFrameParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_RestartFrameReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s23_Debugger_restartFrame] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_RestartFrameReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Returns source for the script with given id. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s17_Debugger_getScriptSource] [@js.enum]) -> ?params:inspector_Debugger_GetScriptSourceParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_GetScriptSourceReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s17_Debugger_getScriptSource] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_GetScriptSourceReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s36_Debugger_setPauseOnExceptions] [@js.enum]) -> ?params:inspector_Debugger_SetPauseOnExceptionsParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s36_Debugger_setPauseOnExceptions] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Evaluates expression on a given call frame. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s15_Debugger_evaluateOnCallFrame] [@js.enum]) -> ?params:inspector_Debugger_EvaluateOnCallFrameParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_EvaluateOnCallFrameReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s15_Debugger_evaluateOnCallFrame] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Debugger_EvaluateOnCallFrameReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s40_Debugger_setVariableValue] [@js.enum]) -> ?params:inspector_Debugger_SetVariableValueParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s40_Debugger_setVariableValue] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Changes return value in top frame. Available only at return break position.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s37_Debugger_setReturnValue] [@js.enum]) -> ?params:inspector_Debugger_SetReturnValueParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s37_Debugger_setReturnValue] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Enables or disables async call stacks tracking. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s30_Debugger_setAsyncCallStackDepth] [@js.enum]) -> ?params:inspector_Debugger_SetAsyncCallStackDepthParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s30_Debugger_setAsyncCallStackDepth] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s31_Debugger_setBlackboxPatterns] [@js.enum]) -> ?params:inspector_Debugger_SetBlackboxPatternsParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s31_Debugger_setBlackboxPatterns] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s32_Debugger_setBlackboxedRanges] [@js.enum]) -> ?params:inspector_Debugger_SetBlackboxedRangesParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s32_Debugger_setBlackboxedRanges] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s9_Console_enable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Disables console domain, prevents further console messages from being reported to the client. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s8_Console_disable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Does nothing. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s7_Console_clearMessages] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s88_Profiler_enable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s87_Profiler_disable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s90_Profiler_setSamplingInterval] [@js.enum]) -> ?params:inspector_Profiler_SetSamplingIntervalParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s90_Profiler_setSamplingInterval] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s91_Profiler_start] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s94_Profiler_stop] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Profiler_StopReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s92_Profiler_startPreciseCoverage] [@js.enum]) -> ?params:inspector_Profiler_StartPreciseCoverageParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s92_Profiler_startPreciseCoverage] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s95_Profiler_stopPreciseCoverage] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s97_Profiler_takePreciseCoverage] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Profiler_TakePreciseCoverageReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s89_Profiler_getBestEffortCoverage] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Profiler_GetBestEffortCoverageReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Enable type profile.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s93_Profiler_startTypeProfile] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Disable type profile. Disabling releases type profile data collected so far.
      experimental: 
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s96_Profiler_stopTypeProfile] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Collect type profile.
      experimental: 
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s98_Profiler_takeTypeProfile] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_Profiler_TakeTypeProfileReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s49_HeapProfiler_enable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s48_HeapProfiler_disable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s58_HeapProfiler_startTrackingHeapObjects] [@js.enum]) -> ?params:inspector_HeapProfiler_StartTrackingHeapObjectsParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s58_HeapProfiler_startTrackingHeapObjects] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s60_HeapProfiler_stopTrackingHeapObjects] [@js.enum]) -> ?params:inspector_HeapProfiler_StopTrackingHeapObjectsParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s60_HeapProfiler_stopTrackingHeapObjects] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s61_HeapProfiler_takeHeapSnapshot] [@js.enum]) -> ?params:inspector_HeapProfiler_TakeHeapSnapshotParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s61_HeapProfiler_takeHeapSnapshot] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s47_HeapProfiler_collectGarbage] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s51_HeapProfiler_getObjectByHeapObjectId] [@js.enum]) -> ?params:inspector_HeapProfiler_GetObjectByHeapObjectIdParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_HeapProfiler_GetObjectByHeapObjectIdReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s51_HeapProfiler_getObjectByHeapObjectId] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_HeapProfiler_GetObjectByHeapObjectIdReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions). *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s46_HeapProfiler_addInspectedHeapObject] [@js.enum]) -> ?params:inspector_HeapProfiler_AddInspectedHeapObjectParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s46_HeapProfiler_addInspectedHeapObject] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s50_HeapProfiler_getHeapObjectId] [@js.enum]) -> ?params:inspector_HeapProfiler_GetHeapObjectIdParameterType -> ?callback:(err:Error.t_0 or_null -> params:inspector_HeapProfiler_GetHeapObjectIdReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s50_HeapProfiler_getHeapObjectId] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_HeapProfiler_GetHeapObjectIdReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s57_HeapProfiler_startSampling] [@js.enum]) -> ?params:inspector_HeapProfiler_StartSamplingParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s57_HeapProfiler_startSampling] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s59_HeapProfiler_stopSampling] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_HeapProfiler_StopSamplingReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s52_HeapProfiler_getSamplingProfile] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_HeapProfiler_GetSamplingProfileReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Gets supported tracing categories. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s71_NodeTracing_getCategories] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> params:inspector_NodeTracing_GetCategoriesReturnType -> unit) -> unit -> unit [@@js.call "post"]
    (** Start trace events collection. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s72_NodeTracing_start] [@js.enum]) -> ?params:inspector_NodeTracing_StartParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s72_NodeTracing_start] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s73_NodeTracing_stop] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Sends protocol message over session with given id. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s81_NodeWorker_sendMessageToWorker] [@js.enum]) -> ?params:inspector_NodeWorker_SendMessageToWorkerParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s81_NodeWorker_sendMessageToWorker] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s79_NodeWorker_enable] [@js.enum]) -> ?params:inspector_NodeWorker_EnableParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s79_NodeWorker_enable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Detaches from all running workers and disables attaching to new workers as they are started. *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s78_NodeWorker_disable] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Detached from the worker with given sessionId. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s76_NodeWorker_detach] [@js.enum]) -> ?params:inspector_NodeWorker_DetachParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s76_NodeWorker_detach] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (** Enable the `NodeRuntime.waitingForDisconnect`. *)
    val post''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s68_NodeRuntime_notifyWhenWaitingForDisconnect] [@js.enum]) -> ?params:inspector_NodeRuntime_NotifyWhenWaitingForDisconnectParameterType -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Posts a message to the inspector back-end. callback will be notified when a response is received.
      callback is a function that accepts two optional arguments - error and message-specific result.
      
      
      Returns supported domains.
      
      
      Evaluates expression on global object.
      
      
      Add handler to promise with given promise object id.
      
      
      Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
      
      
      Returns properties of a given object. Object group of the result is inherited from the target object.
      
      
      Releases remote object with given id.
      
      
      Releases all remote objects that belong to a given group.
      
      
      Tells inspected instance to run if it was waiting for debugger to attach.
      
      
      Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
      
      
      Disables reporting of execution contexts creation.
      
      
      Discards collected exceptions and console API calls.
      
      
      Compiles expression.
      
      
      Runs script with given id in a given context.
      
      
      Returns all let, const and class variables from global scope.
      
      
      Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
      
      
      Disables debugger for given page.
      
      
      Activates / deactivates all breakpoints on the page.
      
      
      Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
      
      
      Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
      
      
      Sets JavaScript breakpoint at a given location.
      
      
      Removes JavaScript breakpoint.
      
      
      Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
      
      
      Continues execution until specific location is reached.
      
      
      Steps over the statement.
      
      
      Steps into the function call.
      
      
      Steps out of the function call.
      
      
      Stops on the next JavaScript statement.
      
      
      This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
      
      
      Resumes JavaScript execution.
      
      
      Returns stack trace with given <code>stackTraceId</code>.
      
      
      Searches for given string in script content.
      
      
      Edits JavaScript source live.
      
      
      Restarts particular call frame from the beginning.
      
      
      Returns source for the script with given id.
      
      
      Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
      
      
      Evaluates expression on a given call frame.
      
      
      Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
      
      
      Changes return value in top frame. Available only at return break position.
      
      
      Enables or disables async call stacks tracking.
      
      
      Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
      
      
      Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
      
      
      Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
      
      
      Disables console domain, prevents further console messages from being reported to the client.
      
      
      Does nothing.
      
      
      Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
      
      
      Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
      
      
      Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
      
      
      Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
      
      
      Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
      
      
      Enable type profile.
      
      
      Disable type profile. Disabling releases type profile data collected so far.
      
      
      Collect type profile.
      
      
      Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
      
      
      Gets supported tracing categories.
      
      
      Start trace events collection.
      
      
      Stop trace events collection. Remaining collected events will be sent as a sequence of
      dataCollected events followed by tracingComplete event.
      
      
      Sends protocol message over session with given id.
      
      
      Instructs the inspector to attach to running workers. Will also attach to new workers
      as they start
      
      
      Detaches from all running workers and disables attaching to new workers as they are started.
      
      
      Detached from the worker with given sessionId.
      
      
      Enable the `NodeRuntime.waitingForDisconnect`.
    *)
    val post'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''': t -> method_:([`L_s68_NodeRuntime_notifyWhenWaitingForDisconnect] [@js.enum]) -> ?callback:(err:Error.t_0 or_null -> unit) -> unit -> unit [@@js.call "post"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (** Emitted when any notification from the V8 Inspector is received. *)
    val addListener': t -> event:([`L_s237_inspectorNotification] [@js.enum]) -> listener:(message:anonymous_interface_0 inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when new execution context is created. *)
    val addListener'': t -> event:([`L_s109_Runtime_executionContextCreated] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextCreatedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when execution context is destroyed. *)
    val addListener''': t -> event:([`L_s110_Runtime_executionContextDestroyed] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextDestroyedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when all executionContexts were cleared in browser *)
    val addListener'''': t -> event:([`L_s111_Runtime_executionContextsCleared] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (** Issued when exception was thrown and unhandled. *)
    val addListener''''': t -> event:([`L_s108_Runtime_exceptionThrown] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionThrownEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when unhandled exception was revoked. *)
    val addListener'''''': t -> event:([`L_s107_Runtime_exceptionRevoked] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionRevokedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when console API was called. *)
    val addListener''''''': t -> event:([`L_s102_Runtime_consoleAPICalled] [@js.enum]) -> listener:(message:inspector_Runtime_ConsoleAPICalledEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when object should be inspected (for example, as a result of inspect() command line API call). *)
    val addListener'''''''': t -> event:([`L_s114_Runtime_inspectRequested] [@js.enum]) -> listener:(message:inspector_Runtime_InspectRequestedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. *)
    val addListener''''''''': t -> event:([`L_s28_Debugger_scriptParsed] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptParsedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Fired when virtual machine fails to parse the script. *)
    val addListener'''''''''': t -> event:([`L_s27_Debugger_scriptFailedToParse] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptFailedToParseEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Fired when breakpoint is resolved to an actual script and location. *)
    val addListener''''''''''': t -> event:([`L_s11_Debugger_breakpointResolved] [@js.enum]) -> listener:(message:inspector_Debugger_BreakpointResolvedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. *)
    val addListener'''''''''''': t -> event:([`L_s21_Debugger_paused] [@js.enum]) -> listener:(message:inspector_Debugger_PausedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Fired when the virtual machine resumed execution. *)
    val addListener''''''''''''': t -> event:([`L_s25_Debugger_resumed] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (** Issued when new console message is added. *)
    val addListener'''''''''''''': t -> event:([`L_s10_Console_messageAdded] [@js.enum]) -> listener:(message:inspector_Console_MessageAddedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Sent when new profile recording is started using console.profile() call. *)
    val addListener''''''''''''''': t -> event:([`L_s86_Profiler_consoleProfileStarted] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileStartedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val addListener'''''''''''''''': t -> event:([`L_s85_Profiler_consoleProfileFinished] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileFinishedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val addListener''''''''''''''''': t -> event:([`L_s45_HeapProfiler_addHeapSnapshotChunk] [@js.enum]) -> listener:(message:inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val addListener'''''''''''''''''': t -> event:([`L_s56_HeapProfiler_resetProfiles] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val addListener''''''''''''''''''': t -> event:([`L_s55_HeapProfiler_reportHeapSnapshotProgress] [@js.enum]) -> listener:(message:inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. *)
    val addListener'''''''''''''''''''': t -> event:([`L_s54_HeapProfiler_lastSeenObjectId] [@js.enum]) -> listener:(message:inspector_HeapProfiler_LastSeenObjectIdEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** If heap objects tracking has been started then backend may send update for one or more fragments *)
    val addListener''''''''''''''''''''': t -> event:([`L_s53_HeapProfiler_heapStatsUpdate] [@js.enum]) -> listener:(message:inspector_HeapProfiler_HeapStatsUpdateEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Contains an bucket of collected trace events. *)
    val addListener'''''''''''''''''''''': t -> event:([`L_s70_NodeTracing_dataCollected] [@js.enum]) -> listener:(message:inspector_NodeTracing_DataCollectedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (**
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
    *)
    val addListener''''''''''''''''''''''': t -> event:([`L_s74_NodeTracing_tracingComplete] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (** Issued when attached to a worker. *)
    val addListener'''''''''''''''''''''''': t -> event:([`L_s75_NodeWorker_attachedToWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_AttachedToWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (** Issued when detached from the worker. *)
    val addListener''''''''''''''''''''''''': t -> event:([`L_s77_NodeWorker_detachedFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_DetachedFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (**
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
    *)
    val addListener'''''''''''''''''''''''''': t -> event:([`L_s80_NodeWorker_receivedMessageFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "addListener"]
    (**
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val addListener''''''''''''''''''''''''''': t -> event:([`L_s69_NodeRuntime_waitingForDisconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s237_inspectorNotification] [@js.enum]) -> message:anonymous_interface_0 inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s109_Runtime_executionContextCreated] [@js.enum]) -> message:inspector_Runtime_ExecutionContextCreatedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s110_Runtime_executionContextDestroyed] [@js.enum]) -> message:inspector_Runtime_ExecutionContextDestroyedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s111_Runtime_executionContextsCleared] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s108_Runtime_exceptionThrown] [@js.enum]) -> message:inspector_Runtime_ExceptionThrownEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s107_Runtime_exceptionRevoked] [@js.enum]) -> message:inspector_Runtime_ExceptionRevokedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s102_Runtime_consoleAPICalled] [@js.enum]) -> message:inspector_Runtime_ConsoleAPICalledEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''': t -> event:([`L_s114_Runtime_inspectRequested] [@js.enum]) -> message:inspector_Runtime_InspectRequestedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''': t -> event:([`L_s28_Debugger_scriptParsed] [@js.enum]) -> message:inspector_Debugger_ScriptParsedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''': t -> event:([`L_s27_Debugger_scriptFailedToParse] [@js.enum]) -> message:inspector_Debugger_ScriptFailedToParseEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''': t -> event:([`L_s11_Debugger_breakpointResolved] [@js.enum]) -> message:inspector_Debugger_BreakpointResolvedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''''': t -> event:([`L_s21_Debugger_paused] [@js.enum]) -> message:inspector_Debugger_PausedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''': t -> event:([`L_s25_Debugger_resumed] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''''''''''': t -> event:([`L_s10_Console_messageAdded] [@js.enum]) -> message:inspector_Console_MessageAddedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''''': t -> event:([`L_s86_Profiler_consoleProfileStarted] [@js.enum]) -> message:inspector_Profiler_ConsoleProfileStartedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''''''''': t -> event:([`L_s85_Profiler_consoleProfileFinished] [@js.enum]) -> message:inspector_Profiler_ConsoleProfileFinishedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''''''': t -> event:([`L_s45_HeapProfiler_addHeapSnapshotChunk] [@js.enum]) -> message:inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''''''''''': t -> event:([`L_s56_HeapProfiler_resetProfiles] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''''''''''''''''': t -> event:([`L_s55_HeapProfiler_reportHeapSnapshotProgress] [@js.enum]) -> message:inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''''''''''''': t -> event:([`L_s54_HeapProfiler_lastSeenObjectId] [@js.enum]) -> message:inspector_HeapProfiler_LastSeenObjectIdEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''''''''''': t -> event:([`L_s53_HeapProfiler_heapStatsUpdate] [@js.enum]) -> message:inspector_HeapProfiler_HeapStatsUpdateEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''''''''''''''': t -> event:([`L_s70_NodeTracing_dataCollected] [@js.enum]) -> message:inspector_NodeTracing_DataCollectedEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''''''''''''': t -> event:([`L_s74_NodeTracing_tracingComplete] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''''''''''''''''''''': t -> event:([`L_s75_NodeWorker_attachedToWorker] [@js.enum]) -> message:inspector_NodeWorker_AttachedToWorkerEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''''''''''''''': t -> event:([`L_s77_NodeWorker_detachedFromWorker] [@js.enum]) -> message:inspector_NodeWorker_DetachedFromWorkerEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit'''''''''''''''''''''''''': t -> event:([`L_s80_NodeWorker_receivedMessageFromWorker] [@js.enum]) -> message:inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType inspector_InspectorNotification -> bool [@@js.call "emit"]
    val emit''''''''''''''''''''''''''': t -> event:([`L_s69_NodeRuntime_waitingForDisconnect] [@js.enum]) -> bool [@@js.call "emit"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    (** Emitted when any notification from the V8 Inspector is received. *)
    val on': t -> event:([`L_s237_inspectorNotification] [@js.enum]) -> listener:(message:anonymous_interface_0 inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when new execution context is created. *)
    val on'': t -> event:([`L_s109_Runtime_executionContextCreated] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextCreatedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when execution context is destroyed. *)
    val on''': t -> event:([`L_s110_Runtime_executionContextDestroyed] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextDestroyedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when all executionContexts were cleared in browser *)
    val on'''': t -> event:([`L_s111_Runtime_executionContextsCleared] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    (** Issued when exception was thrown and unhandled. *)
    val on''''': t -> event:([`L_s108_Runtime_exceptionThrown] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionThrownEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when unhandled exception was revoked. *)
    val on'''''': t -> event:([`L_s107_Runtime_exceptionRevoked] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionRevokedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when console API was called. *)
    val on''''''': t -> event:([`L_s102_Runtime_consoleAPICalled] [@js.enum]) -> listener:(message:inspector_Runtime_ConsoleAPICalledEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when object should be inspected (for example, as a result of inspect() command line API call). *)
    val on'''''''': t -> event:([`L_s114_Runtime_inspectRequested] [@js.enum]) -> listener:(message:inspector_Runtime_InspectRequestedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. *)
    val on''''''''': t -> event:([`L_s28_Debugger_scriptParsed] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptParsedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Fired when virtual machine fails to parse the script. *)
    val on'''''''''': t -> event:([`L_s27_Debugger_scriptFailedToParse] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptFailedToParseEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Fired when breakpoint is resolved to an actual script and location. *)
    val on''''''''''': t -> event:([`L_s11_Debugger_breakpointResolved] [@js.enum]) -> listener:(message:inspector_Debugger_BreakpointResolvedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. *)
    val on'''''''''''': t -> event:([`L_s21_Debugger_paused] [@js.enum]) -> listener:(message:inspector_Debugger_PausedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Fired when the virtual machine resumed execution. *)
    val on''''''''''''': t -> event:([`L_s25_Debugger_resumed] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    (** Issued when new console message is added. *)
    val on'''''''''''''': t -> event:([`L_s10_Console_messageAdded] [@js.enum]) -> listener:(message:inspector_Console_MessageAddedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Sent when new profile recording is started using console.profile() call. *)
    val on''''''''''''''': t -> event:([`L_s86_Profiler_consoleProfileStarted] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileStartedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val on'''''''''''''''': t -> event:([`L_s85_Profiler_consoleProfileFinished] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileFinishedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val on''''''''''''''''': t -> event:([`L_s45_HeapProfiler_addHeapSnapshotChunk] [@js.enum]) -> listener:(message:inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val on'''''''''''''''''': t -> event:([`L_s56_HeapProfiler_resetProfiles] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val on''''''''''''''''''': t -> event:([`L_s55_HeapProfiler_reportHeapSnapshotProgress] [@js.enum]) -> listener:(message:inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. *)
    val on'''''''''''''''''''': t -> event:([`L_s54_HeapProfiler_lastSeenObjectId] [@js.enum]) -> listener:(message:inspector_HeapProfiler_LastSeenObjectIdEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** If heap objects tracking has been started then backend may send update for one or more fragments *)
    val on''''''''''''''''''''': t -> event:([`L_s53_HeapProfiler_heapStatsUpdate] [@js.enum]) -> listener:(message:inspector_HeapProfiler_HeapStatsUpdateEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Contains an bucket of collected trace events. *)
    val on'''''''''''''''''''''': t -> event:([`L_s70_NodeTracing_dataCollected] [@js.enum]) -> listener:(message:inspector_NodeTracing_DataCollectedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (**
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
    *)
    val on''''''''''''''''''''''': t -> event:([`L_s74_NodeTracing_tracingComplete] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    (** Issued when attached to a worker. *)
    val on'''''''''''''''''''''''': t -> event:([`L_s75_NodeWorker_attachedToWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_AttachedToWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (** Issued when detached from the worker. *)
    val on''''''''''''''''''''''''': t -> event:([`L_s77_NodeWorker_detachedFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_DetachedFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (**
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
    *)
    val on'''''''''''''''''''''''''': t -> event:([`L_s80_NodeWorker_receivedMessageFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "on"]
    (**
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val on''''''''''''''''''''''''''': t -> event:([`L_s69_NodeRuntime_waitingForDisconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    (** Emitted when any notification from the V8 Inspector is received. *)
    val once': t -> event:([`L_s237_inspectorNotification] [@js.enum]) -> listener:(message:anonymous_interface_0 inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when new execution context is created. *)
    val once'': t -> event:([`L_s109_Runtime_executionContextCreated] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextCreatedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when execution context is destroyed. *)
    val once''': t -> event:([`L_s110_Runtime_executionContextDestroyed] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextDestroyedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when all executionContexts were cleared in browser *)
    val once'''': t -> event:([`L_s111_Runtime_executionContextsCleared] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    (** Issued when exception was thrown and unhandled. *)
    val once''''': t -> event:([`L_s108_Runtime_exceptionThrown] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionThrownEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when unhandled exception was revoked. *)
    val once'''''': t -> event:([`L_s107_Runtime_exceptionRevoked] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionRevokedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when console API was called. *)
    val once''''''': t -> event:([`L_s102_Runtime_consoleAPICalled] [@js.enum]) -> listener:(message:inspector_Runtime_ConsoleAPICalledEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when object should be inspected (for example, as a result of inspect() command line API call). *)
    val once'''''''': t -> event:([`L_s114_Runtime_inspectRequested] [@js.enum]) -> listener:(message:inspector_Runtime_InspectRequestedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. *)
    val once''''''''': t -> event:([`L_s28_Debugger_scriptParsed] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptParsedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Fired when virtual machine fails to parse the script. *)
    val once'''''''''': t -> event:([`L_s27_Debugger_scriptFailedToParse] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptFailedToParseEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Fired when breakpoint is resolved to an actual script and location. *)
    val once''''''''''': t -> event:([`L_s11_Debugger_breakpointResolved] [@js.enum]) -> listener:(message:inspector_Debugger_BreakpointResolvedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. *)
    val once'''''''''''': t -> event:([`L_s21_Debugger_paused] [@js.enum]) -> listener:(message:inspector_Debugger_PausedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Fired when the virtual machine resumed execution. *)
    val once''''''''''''': t -> event:([`L_s25_Debugger_resumed] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    (** Issued when new console message is added. *)
    val once'''''''''''''': t -> event:([`L_s10_Console_messageAdded] [@js.enum]) -> listener:(message:inspector_Console_MessageAddedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Sent when new profile recording is started using console.profile() call. *)
    val once''''''''''''''': t -> event:([`L_s86_Profiler_consoleProfileStarted] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileStartedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val once'''''''''''''''': t -> event:([`L_s85_Profiler_consoleProfileFinished] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileFinishedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val once''''''''''''''''': t -> event:([`L_s45_HeapProfiler_addHeapSnapshotChunk] [@js.enum]) -> listener:(message:inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val once'''''''''''''''''': t -> event:([`L_s56_HeapProfiler_resetProfiles] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val once''''''''''''''''''': t -> event:([`L_s55_HeapProfiler_reportHeapSnapshotProgress] [@js.enum]) -> listener:(message:inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. *)
    val once'''''''''''''''''''': t -> event:([`L_s54_HeapProfiler_lastSeenObjectId] [@js.enum]) -> listener:(message:inspector_HeapProfiler_LastSeenObjectIdEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** If heap objects tracking has been started then backend may send update for one or more fragments *)
    val once''''''''''''''''''''': t -> event:([`L_s53_HeapProfiler_heapStatsUpdate] [@js.enum]) -> listener:(message:inspector_HeapProfiler_HeapStatsUpdateEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Contains an bucket of collected trace events. *)
    val once'''''''''''''''''''''': t -> event:([`L_s70_NodeTracing_dataCollected] [@js.enum]) -> listener:(message:inspector_NodeTracing_DataCollectedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (**
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
    *)
    val once''''''''''''''''''''''': t -> event:([`L_s74_NodeTracing_tracingComplete] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    (** Issued when attached to a worker. *)
    val once'''''''''''''''''''''''': t -> event:([`L_s75_NodeWorker_attachedToWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_AttachedToWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (** Issued when detached from the worker. *)
    val once''''''''''''''''''''''''': t -> event:([`L_s77_NodeWorker_detachedFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_DetachedFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (**
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
    *)
    val once'''''''''''''''''''''''''': t -> event:([`L_s80_NodeWorker_receivedMessageFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "once"]
    (**
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val once''''''''''''''''''''''''''': t -> event:([`L_s69_NodeRuntime_waitingForDisconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    (** Emitted when any notification from the V8 Inspector is received. *)
    val prependListener': t -> event:([`L_s237_inspectorNotification] [@js.enum]) -> listener:(message:anonymous_interface_0 inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when new execution context is created. *)
    val prependListener'': t -> event:([`L_s109_Runtime_executionContextCreated] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextCreatedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when execution context is destroyed. *)
    val prependListener''': t -> event:([`L_s110_Runtime_executionContextDestroyed] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextDestroyedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when all executionContexts were cleared in browser *)
    val prependListener'''': t -> event:([`L_s111_Runtime_executionContextsCleared] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    (** Issued when exception was thrown and unhandled. *)
    val prependListener''''': t -> event:([`L_s108_Runtime_exceptionThrown] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionThrownEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when unhandled exception was revoked. *)
    val prependListener'''''': t -> event:([`L_s107_Runtime_exceptionRevoked] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionRevokedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when console API was called. *)
    val prependListener''''''': t -> event:([`L_s102_Runtime_consoleAPICalled] [@js.enum]) -> listener:(message:inspector_Runtime_ConsoleAPICalledEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when object should be inspected (for example, as a result of inspect() command line API call). *)
    val prependListener'''''''': t -> event:([`L_s114_Runtime_inspectRequested] [@js.enum]) -> listener:(message:inspector_Runtime_InspectRequestedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. *)
    val prependListener''''''''': t -> event:([`L_s28_Debugger_scriptParsed] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptParsedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Fired when virtual machine fails to parse the script. *)
    val prependListener'''''''''': t -> event:([`L_s27_Debugger_scriptFailedToParse] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptFailedToParseEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Fired when breakpoint is resolved to an actual script and location. *)
    val prependListener''''''''''': t -> event:([`L_s11_Debugger_breakpointResolved] [@js.enum]) -> listener:(message:inspector_Debugger_BreakpointResolvedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. *)
    val prependListener'''''''''''': t -> event:([`L_s21_Debugger_paused] [@js.enum]) -> listener:(message:inspector_Debugger_PausedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Fired when the virtual machine resumed execution. *)
    val prependListener''''''''''''': t -> event:([`L_s25_Debugger_resumed] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    (** Issued when new console message is added. *)
    val prependListener'''''''''''''': t -> event:([`L_s10_Console_messageAdded] [@js.enum]) -> listener:(message:inspector_Console_MessageAddedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Sent when new profile recording is started using console.profile() call. *)
    val prependListener''''''''''''''': t -> event:([`L_s86_Profiler_consoleProfileStarted] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileStartedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependListener'''''''''''''''': t -> event:([`L_s85_Profiler_consoleProfileFinished] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileFinishedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependListener''''''''''''''''': t -> event:([`L_s45_HeapProfiler_addHeapSnapshotChunk] [@js.enum]) -> listener:(message:inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependListener'''''''''''''''''': t -> event:([`L_s56_HeapProfiler_resetProfiles] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependListener''''''''''''''''''': t -> event:([`L_s55_HeapProfiler_reportHeapSnapshotProgress] [@js.enum]) -> listener:(message:inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. *)
    val prependListener'''''''''''''''''''': t -> event:([`L_s54_HeapProfiler_lastSeenObjectId] [@js.enum]) -> listener:(message:inspector_HeapProfiler_LastSeenObjectIdEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** If heap objects tracking has been started then backend may send update for one or more fragments *)
    val prependListener''''''''''''''''''''': t -> event:([`L_s53_HeapProfiler_heapStatsUpdate] [@js.enum]) -> listener:(message:inspector_HeapProfiler_HeapStatsUpdateEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Contains an bucket of collected trace events. *)
    val prependListener'''''''''''''''''''''': t -> event:([`L_s70_NodeTracing_dataCollected] [@js.enum]) -> listener:(message:inspector_NodeTracing_DataCollectedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (**
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
    *)
    val prependListener''''''''''''''''''''''': t -> event:([`L_s74_NodeTracing_tracingComplete] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    (** Issued when attached to a worker. *)
    val prependListener'''''''''''''''''''''''': t -> event:([`L_s75_NodeWorker_attachedToWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_AttachedToWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (** Issued when detached from the worker. *)
    val prependListener''''''''''''''''''''''''': t -> event:([`L_s77_NodeWorker_detachedFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_DetachedFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (**
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
    *)
    val prependListener'''''''''''''''''''''''''': t -> event:([`L_s80_NodeWorker_receivedMessageFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependListener"]
    (**
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependListener''''''''''''''''''''''''''': t -> event:([`L_s69_NodeRuntime_waitingForDisconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    (** Emitted when any notification from the V8 Inspector is received. *)
    val prependOnceListener': t -> event:([`L_s237_inspectorNotification] [@js.enum]) -> listener:(message:anonymous_interface_0 inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when new execution context is created. *)
    val prependOnceListener'': t -> event:([`L_s109_Runtime_executionContextCreated] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextCreatedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when execution context is destroyed. *)
    val prependOnceListener''': t -> event:([`L_s110_Runtime_executionContextDestroyed] [@js.enum]) -> listener:(message:inspector_Runtime_ExecutionContextDestroyedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when all executionContexts were cleared in browser *)
    val prependOnceListener'''': t -> event:([`L_s111_Runtime_executionContextsCleared] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when exception was thrown and unhandled. *)
    val prependOnceListener''''': t -> event:([`L_s108_Runtime_exceptionThrown] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionThrownEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when unhandled exception was revoked. *)
    val prependOnceListener'''''': t -> event:([`L_s107_Runtime_exceptionRevoked] [@js.enum]) -> listener:(message:inspector_Runtime_ExceptionRevokedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when console API was called. *)
    val prependOnceListener''''''': t -> event:([`L_s102_Runtime_consoleAPICalled] [@js.enum]) -> listener:(message:inspector_Runtime_ConsoleAPICalledEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when object should be inspected (for example, as a result of inspect() command line API call). *)
    val prependOnceListener'''''''': t -> event:([`L_s114_Runtime_inspectRequested] [@js.enum]) -> listener:(message:inspector_Runtime_InspectRequestedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. *)
    val prependOnceListener''''''''': t -> event:([`L_s28_Debugger_scriptParsed] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptParsedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Fired when virtual machine fails to parse the script. *)
    val prependOnceListener'''''''''': t -> event:([`L_s27_Debugger_scriptFailedToParse] [@js.enum]) -> listener:(message:inspector_Debugger_ScriptFailedToParseEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Fired when breakpoint is resolved to an actual script and location. *)
    val prependOnceListener''''''''''': t -> event:([`L_s11_Debugger_breakpointResolved] [@js.enum]) -> listener:(message:inspector_Debugger_BreakpointResolvedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. *)
    val prependOnceListener'''''''''''': t -> event:([`L_s21_Debugger_paused] [@js.enum]) -> listener:(message:inspector_Debugger_PausedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Fired when the virtual machine resumed execution. *)
    val prependOnceListener''''''''''''': t -> event:([`L_s25_Debugger_resumed] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when new console message is added. *)
    val prependOnceListener'''''''''''''': t -> event:([`L_s10_Console_messageAdded] [@js.enum]) -> listener:(message:inspector_Console_MessageAddedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Sent when new profile recording is started using console.profile() call. *)
    val prependOnceListener''''''''''''''': t -> event:([`L_s86_Profiler_consoleProfileStarted] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileStartedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependOnceListener'''''''''''''''': t -> event:([`L_s85_Profiler_consoleProfileFinished] [@js.enum]) -> listener:(message:inspector_Profiler_ConsoleProfileFinishedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependOnceListener''''''''''''''''': t -> event:([`L_s45_HeapProfiler_addHeapSnapshotChunk] [@js.enum]) -> listener:(message:inspector_HeapProfiler_AddHeapSnapshotChunkEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependOnceListener'''''''''''''''''': t -> event:([`L_s56_HeapProfiler_resetProfiles] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      Emitted when any notification from the V8 Inspector is received.
      
      
      Issued when new execution context is created.
      
      
      Issued when execution context is destroyed.
      
      
      Issued when all executionContexts were cleared in browser
      
      
      Issued when exception was thrown and unhandled.
      
      
      Issued when unhandled exception was revoked.
      
      
      Issued when console API was called.
      
      
      Issued when object should be inspected (for example, as a result of inspect() command line API call).
      
      
      Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
      
      
      Fired when virtual machine fails to parse the script.
      
      
      Fired when breakpoint is resolved to an actual script and location.
      
      
      Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
      
      
      Fired when the virtual machine resumed execution.
      
      
      Issued when new console message is added.
      
      
      Sent when new profile recording is started using console.profile() call.
      
      
      If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
      
      
      If heap objects tracking has been started then backend may send update for one or more fragments
      
      
      Contains an bucket of collected trace events.
      
      
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
      
      
      Issued when attached to a worker.
      
      
      Issued when detached from the worker.
      
      
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
      
      
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependOnceListener''''''''''''''''''': t -> event:([`L_s55_HeapProfiler_reportHeapSnapshotProgress] [@js.enum]) -> listener:(message:inspector_HeapProfiler_ReportHeapSnapshotProgressEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. *)
    val prependOnceListener'''''''''''''''''''': t -> event:([`L_s54_HeapProfiler_lastSeenObjectId] [@js.enum]) -> listener:(message:inspector_HeapProfiler_LastSeenObjectIdEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** If heap objects tracking has been started then backend may send update for one or more fragments *)
    val prependOnceListener''''''''''''''''''''': t -> event:([`L_s53_HeapProfiler_heapStatsUpdate] [@js.enum]) -> listener:(message:inspector_HeapProfiler_HeapStatsUpdateEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Contains an bucket of collected trace events. *)
    val prependOnceListener'''''''''''''''''''''': t -> event:([`L_s70_NodeTracing_dataCollected] [@js.enum]) -> listener:(message:inspector_NodeTracing_DataCollectedEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      Signals that tracing is stopped and there is no trace buffers pending flush, all data were
      delivered via dataCollected events.
    *)
    val prependOnceListener''''''''''''''''''''''': t -> event:([`L_s74_NodeTracing_tracingComplete] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when attached to a worker. *)
    val prependOnceListener'''''''''''''''''''''''': t -> event:([`L_s75_NodeWorker_attachedToWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_AttachedToWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (** Issued when detached from the worker. *)
    val prependOnceListener''''''''''''''''''''''''': t -> event:([`L_s77_NodeWorker_detachedFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_DetachedFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      Notifies about a new protocol message received from the session
      (session ID is provided in attachedToWorker notification).
    *)
    val prependOnceListener'''''''''''''''''''''''''': t -> event:([`L_s80_NodeWorker_receivedMessageFromWorker] [@js.enum]) -> listener:(message:inspector_NodeWorker_ReceivedMessageFromWorkerEventDataType inspector_InspectorNotification -> unit) -> t [@@js.call "prependOnceListener"]
    (**
      This event is fired instead of `Runtime.executionContextDestroyed` when
      enabled.
      It is fired when the Node process finished all code execution and is
      waiting for all frontends to disconnect.
    *)
    val prependOnceListener''''''''''''''''''''''''''': t -> event:([`L_s69_NodeRuntime_waitingForDisconnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  (**
    Activate inspector on host and port. Equivalent to node --inspect=\[\[host:\]port\], but can be done programatically after node has started.
    If wait is true, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.
    @param port Port to listen on for inspector connections. Optional, defaults to what was specified on the CLI.
    @param host Host to listen on for inspector connections. Optional, defaults to what was specified on the CLI.
    @param wait Block until a client has connected. Optional, defaults to false.
  *)
  val open_: ?port:float -> ?host:string -> ?wait:bool -> unit -> unit [@@js.global "open"]
  (** Deactivate the inspector. Blocks until there are no active connections. *)
  val close: unit -> unit [@@js.global "close"]
  (** Return the URL of the active inspector, or `undefined` if there is none. *)
  val url: unit -> string or_undefined [@@js.global "url"]
  (**
    Blocks until a client (existing or connected later) has sent
    `Runtime.runIfWaitingForDebugger` command.
    An exception will be thrown if there is no active inspector.
  *)
  val waitForDebugger: unit -> unit [@@js.global "waitForDebugger"]
end
module Node_module : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = module
    clause = NamespaceImport ([object Object])
    loc = line 2, col 5 of node_modules/@types/node/module.d.ts } *)
  (* CommonJsExport ({ name = [Module]
    fullName = undefined
    loc = line 3, col 14 of node_modules/@types/node/module.d.ts }) *)
end
module[@js.scope "module"] Module : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:url
    clause = ES6Import ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/module.d.ts } *)
  module[@js.scope "Module"] Module : sig
    (**
      Updates all the live bindings for builtin ES Modules to match the properties of the CommonJS exports.
      It does not add or remove exported names from the ES Modules.
    *)
    val syncBuiltinESMExports: unit -> unit [@@js.global "syncBuiltinESMExports"]
    val findSourceMap: path:string -> ?error:Error.t_0 -> unit -> module_Module_SourceMap [@@js.global "findSourceMap"]
    module[@js.scope "SourceMapPayload"] SourceMapPayload : sig
      type t = module_Module_SourceMapPayload
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_file: t -> string [@@js.get "file"]
      val set_file: t -> string -> unit [@@js.set "file"]
      val get_version: t -> float [@@js.get "version"]
      val set_version: t -> float -> unit [@@js.set "version"]
      val get_sources: t -> string list [@@js.get "sources"]
      val set_sources: t -> string list -> unit [@@js.set "sources"]
      val get_sourcesContent: t -> string list [@@js.get "sourcesContent"]
      val set_sourcesContent: t -> string list -> unit [@@js.set "sourcesContent"]
      val get_names: t -> string list [@@js.get "names"]
      val set_names: t -> string list -> unit [@@js.set "names"]
      val get_mappings: t -> string [@@js.get "mappings"]
      val set_mappings: t -> string -> unit [@@js.set "mappings"]
      val get_sourceRoot: t -> string [@@js.get "sourceRoot"]
      val set_sourceRoot: t -> string -> unit [@@js.set "sourceRoot"]
    end
    module[@js.scope "SourceMapping"] SourceMapping : sig
      type t = module_Module_SourceMapping
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_generatedLine: t -> float [@@js.get "generatedLine"]
      val set_generatedLine: t -> float -> unit [@@js.set "generatedLine"]
      val get_generatedColumn: t -> float [@@js.get "generatedColumn"]
      val set_generatedColumn: t -> float -> unit [@@js.set "generatedColumn"]
      val get_originalSource: t -> string [@@js.get "originalSource"]
      val set_originalSource: t -> string -> unit [@@js.set "originalSource"]
      val get_originalLine: t -> float [@@js.get "originalLine"]
      val set_originalLine: t -> float -> unit [@@js.set "originalLine"]
      val get_originalColumn: t -> float [@@js.get "originalColumn"]
      val set_originalColumn: t -> float -> unit [@@js.set "originalColumn"]
    end
    module[@js.scope "SourceMap"] SourceMap : sig
      type t = module_Module_SourceMap
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_payload: t -> module_Module_SourceMapPayload [@@js.get "payload"]
      val create: payload:module_Module_SourceMapPayload -> t [@@js.create]
      val findEntry: t -> line:float -> column:float -> module_Module_SourceMapping [@@js.call "findEntry"]
    end
  end
  module[@js.scope "Module"] Module : sig
    type t = module_Module
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val runMain: unit -> unit [@@js.global "runMain"]
    val wrap: code:string -> string [@@js.global "wrap"]
    (** @deprecated Deprecated since: v12.2.0. Please use createRequire() instead. *)
    val createRequireFromPath: path:string -> _NodeRequire [@@js.global "createRequireFromPath"]
    val createRequire: path:URL.t_0 or_string -> _NodeRequire [@@js.global "createRequire"]
    val get_builtinModules: unit -> string list [@@js.get "builtinModules"]
    val set_builtinModules: string list -> unit [@@js.set "builtinModules"]
    val get_Module: unit -> (* FIXME: unknown type 'typeof Module' *)any [@@js.get "Module"]
    val set_Module: (* FIXME: unknown type 'typeof Module' *)any -> unit [@@js.set "Module"]
    val create: id:string -> ?parent:t -> unit -> t [@@js.create]
    val cast: t -> _NodeModule [@@js.cast]
  end
  (* CommonJsExport ({ name = [Module]
    fullName = [module; Module]
    loc = line 56, col 14 of node_modules/@types/node/module.d.ts }) *)
end
module Node_net : sig
  (* export * from 'net'; *)
end
module[@js.scope "net"] Net : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/net.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/net.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:dns
    clause = NamespaceImport ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/net.d.ts } *)
  module[@js.scope "LookupFunction"] LookupFunction : sig
    type t = net_LookupFunction
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> hostname:string -> options:dns_LookupOneOptions -> callback:(err:_NodeJS_ErrnoException or_null -> address:string -> family:float -> unit) -> unit [@@js.apply]
  end
  module[@js.scope "AddressInfo"] AddressInfo : sig
    type t = net_AddressInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_family: t -> string [@@js.get "family"]
    val set_family: t -> string -> unit [@@js.set "family"]
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
  end
  module[@js.scope "SocketConstructorOpts"] SocketConstructorOpts : sig
    type t = net_SocketConstructorOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_fd: t -> float [@@js.get "fd"]
    val set_fd: t -> float -> unit [@@js.set "fd"]
    val get_allowHalfOpen: t -> bool [@@js.get "allowHalfOpen"]
    val set_allowHalfOpen: t -> bool -> unit [@@js.set "allowHalfOpen"]
    val get_readable: t -> bool [@@js.get "readable"]
    val set_readable: t -> bool -> unit [@@js.set "readable"]
    val get_writable: t -> bool [@@js.get "writable"]
    val set_writable: t -> bool -> unit [@@js.set "writable"]
  end
  module[@js.scope "OnReadOpts"] OnReadOpts : sig
    type t = net_OnReadOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_buffer: t -> (Uint8Array.t_0, (unit -> Uint8Array.t_0)) union2 [@@js.get "buffer"]
    val set_buffer: t -> (Uint8Array.t_0, (unit -> Uint8Array.t_0)) union2 -> unit [@@js.set "buffer"]
    (**
      This function is called for every chunk of incoming data.
      Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer.
      Return false from this function to implicitly pause() the socket.
    *)
    val callback: t -> bytesWritten:float -> buf:Uint8Array.t_0 -> bool [@@js.call "callback"]
  end
  module[@js.scope "ConnectOpts"] ConnectOpts : sig
    type t = net_ConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.
      Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will
      still be emitted as normal and methods like pause() and resume() will also behave as expected.
    *)
    (**
      If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.
      Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will
      still be emitted as normal and methods like pause() and resume() will also behave as expected.
    *)
    val get_onread: t -> net_OnReadOpts [@@js.get "onread"]
    (**
      If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.
      Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will
      still be emitted as normal and methods like pause() and resume() will also behave as expected.
    *)
    val set_onread: t -> net_OnReadOpts -> unit [@@js.set "onread"]
  end
  module[@js.scope "TcpSocketConnectOpts"] TcpSocketConnectOpts : sig
    type t = net_TcpSocketConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_host: t -> string [@@js.get "host"]
    val set_host: t -> string -> unit [@@js.set "host"]
    val get_localAddress: t -> string [@@js.get "localAddress"]
    val set_localAddress: t -> string -> unit [@@js.set "localAddress"]
    val get_localPort: t -> float [@@js.get "localPort"]
    val set_localPort: t -> float -> unit [@@js.set "localPort"]
    val get_hints: t -> float [@@js.get "hints"]
    val set_hints: t -> float -> unit [@@js.set "hints"]
    val get_family: t -> float [@@js.get "family"]
    val set_family: t -> float -> unit [@@js.set "family"]
    val get_lookup: t -> net_LookupFunction [@@js.get "lookup"]
    val set_lookup: t -> net_LookupFunction -> unit [@@js.set "lookup"]
    val cast: t -> net_ConnectOpts [@@js.cast]
  end
  module[@js.scope "IpcSocketConnectOpts"] IpcSocketConnectOpts : sig
    type t = net_IpcSocketConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_path: t -> string [@@js.get "path"]
    val set_path: t -> string -> unit [@@js.set "path"]
    val cast: t -> net_ConnectOpts [@@js.cast]
  end
  module SocketConnectOpts : sig
    type t = net_SocketConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "Socket"] Socket : sig
    type t = net_Socket
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?options:net_SocketConstructorOpts -> unit -> t [@@js.create]
    val write: t -> buffer:Uint8Array.t_0 or_string -> ?cb:(?err:Error.t_0 -> unit -> unit) -> unit -> bool [@@js.call "write"]
    val write': t -> str:Uint8Array.t_0 or_string -> ?encoding:_BufferEncoding -> ?cb:(?err:Error.t_0 -> unit -> unit) -> unit -> bool [@@js.call "write"]
    val connect: t -> options:net_SocketConnectOpts -> ?connectionListener:(unit -> unit) -> unit -> t [@@js.call "connect"]
    val connect': t -> port:float -> host:string -> ?connectionListener:(unit -> unit) -> unit -> t [@@js.call "connect"]
    val connect'': t -> port:float -> ?connectionListener:(unit -> unit) -> unit -> t [@@js.call "connect"]
    val connect''': t -> path:string -> ?connectionListener:(unit -> unit) -> unit -> t [@@js.call "connect"]
    val setEncoding: t -> ?encoding:_BufferEncoding -> unit -> t [@@js.call "setEncoding"]
    val pause: t -> t [@@js.call "pause"]
    val resume: t -> t [@@js.call "resume"]
    val setTimeout: t -> timeout:float -> ?callback:(unit -> unit) -> unit -> t [@@js.call "setTimeout"]
    val setNoDelay: t -> ?noDelay:bool -> unit -> t [@@js.call "setNoDelay"]
    val setKeepAlive: t -> ?enable:bool -> ?initialDelay:float -> unit -> t [@@js.call "setKeepAlive"]
    val address: t -> (net_AddressInfo, anonymous_interface_0) union2 [@@js.call "address"]
    val unref: t -> t [@@js.call "unref"]
    val ref: t -> t [@@js.call "ref"]
    (** @deprecated since v14.6.0 - Use `writableLength` instead. *)
    val get_bufferSize: t -> float [@@js.get "bufferSize"]
    val get_bytesRead: t -> float [@@js.get "bytesRead"]
    val get_bytesWritten: t -> float [@@js.get "bytesWritten"]
    val get_connecting: t -> bool [@@js.get "connecting"]
    val get_destroyed: t -> bool [@@js.get "destroyed"]
    val get_localAddress: t -> string [@@js.get "localAddress"]
    val get_localPort: t -> float [@@js.get "localPort"]
    val get_remoteAddress: t -> string [@@js.get "remoteAddress"]
    val get_remoteFamily: t -> string [@@js.get "remoteFamily"]
    val get_remotePort: t -> float [@@js.get "remotePort"]
    val end_: t -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val end_': t -> buffer:Uint8Array.t_0 or_string -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
    val end_'': t -> str:Uint8Array.t_0 or_string -> ?encoding:_BufferEncoding -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(had_error:bool -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''': t -> event:([`L_s198_data] [@js.enum]) -> listener:(data:_Buffer -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener''''''': t -> event:([`L_s248_lookup] [@js.enum]) -> listener:(err:Error.t_0 -> address:string -> family:string or_number -> host:string -> unit) -> t [@@js.call "addListener"]
    (**
      Event emitter
      The defined events on documents including:
      1. close
      2. data
      3. end
      4. error
      5. pause
      6. readable
      7. resume
    *)
    val addListener'''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> had_error:bool -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s193_connect] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s198_data] [@js.enum]) -> data:_Buffer -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s206_drain] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s211_end] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s248_lookup] [@js.enum]) -> err:Error.t_0 -> address:string -> family:string or_number -> host:string -> bool [@@js.call "emit"]
    val emit'''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(had_error:bool -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s198_data] [@js.enum]) -> listener:(data:_Buffer -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s248_lookup] [@js.enum]) -> listener:(err:Error.t_0 -> address:string -> family:string or_number -> host:string -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(had_error:bool -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s198_data] [@js.enum]) -> listener:(data:_Buffer -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s248_lookup] [@js.enum]) -> listener:(err:Error.t_0 -> address:string -> family:string or_number -> host:string -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(had_error:bool -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s198_data] [@js.enum]) -> listener:(data:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s248_lookup] [@js.enum]) -> listener:(err:Error.t_0 -> address:string -> family:string or_number -> host:string -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(had_error:bool -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s193_connect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s198_data] [@js.enum]) -> listener:(data:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s248_lookup] [@js.enum]) -> listener:(err:Error.t_0 -> address:string -> family:string or_number -> host:string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:([`L_s312_timeout] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Stream.Duplex.t_0 [@@js.cast]
  end
  module[@js.scope "ListenOptions"] ListenOptions : sig
    type t = net_ListenOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_host: t -> string [@@js.get "host"]
    val set_host: t -> string -> unit [@@js.set "host"]
    val get_backlog: t -> float [@@js.get "backlog"]
    val set_backlog: t -> float -> unit [@@js.set "backlog"]
    val get_path: t -> string [@@js.get "path"]
    val set_path: t -> string -> unit [@@js.set "path"]
    val get_exclusive: t -> bool [@@js.get "exclusive"]
    val set_exclusive: t -> bool -> unit [@@js.set "exclusive"]
    val get_readableAll: t -> bool [@@js.get "readableAll"]
    val set_readableAll: t -> bool -> unit [@@js.set "readableAll"]
    val get_writableAll: t -> bool [@@js.get "writableAll"]
    val set_writableAll: t -> bool -> unit [@@js.set "writableAll"]
    (** default: false *)
    (** default: false *)
    val get_ipv6Only: t -> bool [@@js.get "ipv6Only"]
    (** default: false *)
    val set_ipv6Only: t -> bool -> unit [@@js.set "ipv6Only"]
  end
  module[@js.scope "ServerOpts"] ServerOpts : sig
    type t = net_ServerOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Indicates whether half-opened TCP connections are allowed. __Default:__ `false`. *)
    (** Indicates whether half-opened TCP connections are allowed. __Default:__ `false`. *)
    val get_allowHalfOpen: t -> bool [@@js.get "allowHalfOpen"]
    (** Indicates whether half-opened TCP connections are allowed. __Default:__ `false`. *)
    val set_allowHalfOpen: t -> bool -> unit [@@js.set "allowHalfOpen"]
    (** Indicates whether the socket should be paused on incoming connections. __Default:__ `false`. *)
    (** Indicates whether the socket should be paused on incoming connections. __Default:__ `false`. *)
    val get_pauseOnConnect: t -> bool [@@js.get "pauseOnConnect"]
    (** Indicates whether the socket should be paused on incoming connections. __Default:__ `false`. *)
    val set_pauseOnConnect: t -> bool -> unit [@@js.set "pauseOnConnect"]
  end
  module[@js.scope "Server"] Server : sig
    type t = net_Server
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?connectionListener:(socket:net_Socket -> unit) -> unit -> t [@@js.create]
    val create': ?options:net_ServerOpts -> ?connectionListener:(socket:net_Socket -> unit) -> unit -> t [@@js.create]
    val listen: t -> ?port:float -> ?hostname:string -> ?backlog:float -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen': t -> ?port:float -> ?hostname:string -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen'': t -> ?port:float -> ?backlog:float -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen''': t -> ?port:float -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen'''': t -> path:string -> ?backlog:float -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen''''': t -> path:string -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen'''''': t -> options:net_ListenOptions -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen''''''': t -> handle:any -> ?backlog:float -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val listen'''''''': t -> handle:any -> ?listeningListener:(unit -> unit) -> unit -> t [@@js.call "listen"]
    val close: t -> ?callback:(?err:Error.t_0 -> unit -> unit) -> unit -> t [@@js.call "close"]
    val address: t -> net_AddressInfo or_string or_null [@@js.call "address"]
    val getConnections: t -> cb:(error:Error.t_0 or_null -> count:float -> unit) -> unit [@@js.call "getConnections"]
    val ref: t -> t [@@js.call "ref"]
    val unref: t -> t [@@js.call "unref"]
    val get_maxConnections: t -> float [@@js.get "maxConnections"]
    val set_maxConnections: t -> float -> unit [@@js.set "maxConnections"]
    val get_connections: t -> float [@@js.get "connections"]
    val set_connections: t -> float -> unit [@@js.set "connections"]
    val get_listening: t -> bool [@@js.get "listening"]
    val set_listening: t -> bool -> unit [@@js.set "listening"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'': t -> event:([`L_s194_connection] [@js.enum]) -> listener:(socket:net_Socket -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s194_connection] [@js.enum]) -> socket:net_Socket -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s246_listening] [@js.enum]) -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s194_connection] [@js.enum]) -> listener:(socket:net_Socket -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s194_connection] [@js.enum]) -> listener:(socket:net_Socket -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s194_connection] [@js.enum]) -> listener:(socket:net_Socket -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s194_connection] [@js.enum]) -> listener:(socket:net_Socket -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s246_listening] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "TcpNetConnectOpts"] TcpNetConnectOpts : sig
    type t = net_TcpNetConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    val cast: t -> net_TcpSocketConnectOpts [@@js.cast]
    val cast': t -> net_SocketConstructorOpts [@@js.cast]
  end
  module[@js.scope "IpcNetConnectOpts"] IpcNetConnectOpts : sig
    type t = net_IpcNetConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    val cast: t -> net_IpcSocketConnectOpts [@@js.cast]
    val cast': t -> net_SocketConstructorOpts [@@js.cast]
  end
  module NetConnectOpts : sig
    type t = net_NetConnectOpts
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  val createServer: ?connectionListener:(socket:net_Socket -> unit) -> unit -> net_Server [@@js.global "createServer"]
  val createServer: ?options:net_ServerOpts -> ?connectionListener:(socket:net_Socket -> unit) -> unit -> net_Server [@@js.global "createServer"]
  val connect: options:net_NetConnectOpts -> ?connectionListener:(unit -> unit) -> unit -> net_Socket [@@js.global "connect"]
  val connect: port:float -> ?host:string -> ?connectionListener:(unit -> unit) -> unit -> net_Socket [@@js.global "connect"]
  val connect: path:string -> ?connectionListener:(unit -> unit) -> unit -> net_Socket [@@js.global "connect"]
  val createConnection: options:net_NetConnectOpts -> ?connectionListener:(unit -> unit) -> unit -> net_Socket [@@js.global "createConnection"]
  val createConnection: port:float -> ?host:string -> ?connectionListener:(unit -> unit) -> unit -> net_Socket [@@js.global "createConnection"]
  val createConnection: path:string -> ?connectionListener:(unit -> unit) -> unit -> net_Socket [@@js.global "createConnection"]
  val isIP: input:string -> float [@@js.global "isIP"]
  val isIPv4: input:string -> bool [@@js.global "isIPv4"]
  val isIPv6: input:string -> bool [@@js.global "isIPv6"]
end
module Node_os : sig
  (* export * from 'os'; *)
end
module[@js.scope "os"] Os : sig
  module[@js.scope "CpuInfo"] CpuInfo : sig
    type t = os_CpuInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_model: t -> string [@@js.get "model"]
    val set_model: t -> string -> unit [@@js.set "model"]
    val get_speed: t -> float [@@js.get "speed"]
    val set_speed: t -> float -> unit [@@js.set "speed"]
    val get_times: t -> anonymous_interface_61 [@@js.get "times"]
    val set_times: t -> anonymous_interface_61 -> unit [@@js.set "times"]
  end
  module[@js.scope "NetworkInterfaceBase"] NetworkInterfaceBase : sig
    type t = os_NetworkInterfaceBase
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_address: t -> string [@@js.get "address"]
    val set_address: t -> string -> unit [@@js.set "address"]
    val get_netmask: t -> string [@@js.get "netmask"]
    val set_netmask: t -> string -> unit [@@js.set "netmask"]
    val get_mac: t -> string [@@js.get "mac"]
    val set_mac: t -> string -> unit [@@js.set "mac"]
    val get_internal: t -> bool [@@js.get "internal"]
    val set_internal: t -> bool -> unit [@@js.set "internal"]
    val get_cidr: t -> string or_null [@@js.get "cidr"]
    val set_cidr: t -> string or_null -> unit [@@js.set "cidr"]
  end
  module[@js.scope "NetworkInterfaceInfoIPv4"] NetworkInterfaceInfoIPv4 : sig
    type t = os_NetworkInterfaceInfoIPv4
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_family: t -> ([`L_s62_IPv4[@js "IPv4"]] [@js.enum]) [@@js.get "family"]
    val set_family: t -> ([`L_s62_IPv4] [@js.enum]) -> unit [@@js.set "family"]
    val cast: t -> os_NetworkInterfaceBase [@@js.cast]
  end
  module[@js.scope "NetworkInterfaceInfoIPv6"] NetworkInterfaceInfoIPv6 : sig
    type t = os_NetworkInterfaceInfoIPv6
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_family: t -> ([`L_s63_IPv6[@js "IPv6"]] [@js.enum]) [@@js.get "family"]
    val set_family: t -> ([`L_s63_IPv6] [@js.enum]) -> unit [@@js.set "family"]
    val get_scopeid: t -> float [@@js.get "scopeid"]
    val set_scopeid: t -> float -> unit [@@js.set "scopeid"]
    val cast: t -> os_NetworkInterfaceBase [@@js.cast]
  end
  module[@js.scope "UserInfo"] UserInfo : sig
    type 'T t = 'T os_UserInfo
    val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
    val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
    type 'T t_1 = 'T t
    val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    val get_username: 'T t -> 'T [@@js.get "username"]
    val set_username: 'T t -> 'T -> unit [@@js.set "username"]
    val get_uid: 'T t -> float [@@js.get "uid"]
    val set_uid: 'T t -> float -> unit [@@js.set "uid"]
    val get_gid: 'T t -> float [@@js.get "gid"]
    val set_gid: 'T t -> float -> unit [@@js.set "gid"]
    val get_shell: 'T t -> 'T [@@js.get "shell"]
    val set_shell: 'T t -> 'T -> unit [@@js.set "shell"]
    val get_homedir: 'T t -> 'T [@@js.get "homedir"]
    val set_homedir: 'T t -> 'T -> unit [@@js.set "homedir"]
  end
  module NetworkInterfaceInfo : sig
    type t = os_NetworkInterfaceInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  val hostname: unit -> string [@@js.global "hostname"]
  val loadavg: unit -> float list [@@js.global "loadavg"]
  val uptime: unit -> float [@@js.global "uptime"]
  val freemem: unit -> float [@@js.global "freemem"]
  val totalmem: unit -> float [@@js.global "totalmem"]
  val cpus: unit -> os_CpuInfo list [@@js.global "cpus"]
  val type_: unit -> string [@@js.global "type"]
  val release: unit -> string [@@js.global "release"]
  val networkInterfaces: unit -> os_NetworkInterfaceInfo list _NodeJS_Dict [@@js.global "networkInterfaces"]
  val homedir: unit -> string [@@js.global "homedir"]
  val userInfo: options:anonymous_interface_14 -> _Buffer os_UserInfo [@@js.global "userInfo"]
  val userInfo: ?options:anonymous_interface_11 -> unit -> string os_UserInfo [@@js.global "userInfo"]
  module SignalConstants : sig
    type t = os_SignalConstants
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "constants"] Constants : sig
    val uv_udp_reuseaddr: float [@@js.global "UV_UDP_REUSEADDR"]
    module Signals : sig
      
    end
    val signals: os_SignalConstants [@@js.global "signals"]
    module[@js.scope "errno"] Errno : sig
      val e2big: float [@@js.global "E2BIG"]
      val eacces: float [@@js.global "EACCES"]
      val eaddrinuse: float [@@js.global "EADDRINUSE"]
      val eaddrnotavail: float [@@js.global "EADDRNOTAVAIL"]
      val eafnosupport: float [@@js.global "EAFNOSUPPORT"]
      val eagain: float [@@js.global "EAGAIN"]
      val ealready: float [@@js.global "EALREADY"]
      val ebadf: float [@@js.global "EBADF"]
      val ebadmsg: float [@@js.global "EBADMSG"]
      val ebusy: float [@@js.global "EBUSY"]
      val ecanceled: float [@@js.global "ECANCELED"]
      val echild: float [@@js.global "ECHILD"]
      val econnaborted: float [@@js.global "ECONNABORTED"]
      val econnrefused: float [@@js.global "ECONNREFUSED"]
      val econnreset: float [@@js.global "ECONNRESET"]
      val edeadlk: float [@@js.global "EDEADLK"]
      val edestaddrreq: float [@@js.global "EDESTADDRREQ"]
      val edom: float [@@js.global "EDOM"]
      val edquot: float [@@js.global "EDQUOT"]
      val eexist: float [@@js.global "EEXIST"]
      val efault: float [@@js.global "EFAULT"]
      val efbig: float [@@js.global "EFBIG"]
      val ehostunreach: float [@@js.global "EHOSTUNREACH"]
      val eidrm: float [@@js.global "EIDRM"]
      val eilseq: float [@@js.global "EILSEQ"]
      val einprogress: float [@@js.global "EINPROGRESS"]
      val eintr: float [@@js.global "EINTR"]
      val einval: float [@@js.global "EINVAL"]
      val eio: float [@@js.global "EIO"]
      val eisconn: float [@@js.global "EISCONN"]
      val eisdir: float [@@js.global "EISDIR"]
      val eloop: float [@@js.global "ELOOP"]
      val emfile: float [@@js.global "EMFILE"]
      val emlink: float [@@js.global "EMLINK"]
      val emsgsize: float [@@js.global "EMSGSIZE"]
      val emultihop: float [@@js.global "EMULTIHOP"]
      val enametoolong: float [@@js.global "ENAMETOOLONG"]
      val enetdown: float [@@js.global "ENETDOWN"]
      val enetreset: float [@@js.global "ENETRESET"]
      val enetunreach: float [@@js.global "ENETUNREACH"]
      val enfile: float [@@js.global "ENFILE"]
      val enobufs: float [@@js.global "ENOBUFS"]
      val enodata: float [@@js.global "ENODATA"]
      val enodev: float [@@js.global "ENODEV"]
      val enoent: float [@@js.global "ENOENT"]
      val enoexec: float [@@js.global "ENOEXEC"]
      val enolck: float [@@js.global "ENOLCK"]
      val enolink: float [@@js.global "ENOLINK"]
      val enomem: float [@@js.global "ENOMEM"]
      val enomsg: float [@@js.global "ENOMSG"]
      val enoprotoopt: float [@@js.global "ENOPROTOOPT"]
      val enospc: float [@@js.global "ENOSPC"]
      val enosr: float [@@js.global "ENOSR"]
      val enostr: float [@@js.global "ENOSTR"]
      val enosys: float [@@js.global "ENOSYS"]
      val enotconn: float [@@js.global "ENOTCONN"]
      val enotdir: float [@@js.global "ENOTDIR"]
      val enotempty: float [@@js.global "ENOTEMPTY"]
      val enotsock: float [@@js.global "ENOTSOCK"]
      val enotsup: float [@@js.global "ENOTSUP"]
      val enotty: float [@@js.global "ENOTTY"]
      val enxio: float [@@js.global "ENXIO"]
      val eopnotsupp: float [@@js.global "EOPNOTSUPP"]
      val eoverflow: float [@@js.global "EOVERFLOW"]
      val eperm: float [@@js.global "EPERM"]
      val epipe: float [@@js.global "EPIPE"]
      val eproto: float [@@js.global "EPROTO"]
      val eprotonosupport: float [@@js.global "EPROTONOSUPPORT"]
      val eprototype: float [@@js.global "EPROTOTYPE"]
      val erange: float [@@js.global "ERANGE"]
      val erofs: float [@@js.global "EROFS"]
      val espipe: float [@@js.global "ESPIPE"]
      val esrch: float [@@js.global "ESRCH"]
      val estale: float [@@js.global "ESTALE"]
      val etime: float [@@js.global "ETIME"]
      val etimedout: float [@@js.global "ETIMEDOUT"]
      val etxtbsy: float [@@js.global "ETXTBSY"]
      val ewouldblock: float [@@js.global "EWOULDBLOCK"]
      val exdev: float [@@js.global "EXDEV"]
      val wsaeintr: float [@@js.global "WSAEINTR"]
      val wsaebadf: float [@@js.global "WSAEBADF"]
      val wsaeacces: float [@@js.global "WSAEACCES"]
      val wsaefault: float [@@js.global "WSAEFAULT"]
      val wsaeinval: float [@@js.global "WSAEINVAL"]
      val wsaemfile: float [@@js.global "WSAEMFILE"]
      val wsaewouldblock: float [@@js.global "WSAEWOULDBLOCK"]
      val wsaeinprogress: float [@@js.global "WSAEINPROGRESS"]
      val wsaealready: float [@@js.global "WSAEALREADY"]
      val wsaenotsock: float [@@js.global "WSAENOTSOCK"]
      val wsaedestaddrreq: float [@@js.global "WSAEDESTADDRREQ"]
      val wsaemsgsize: float [@@js.global "WSAEMSGSIZE"]
      val wsaeprototype: float [@@js.global "WSAEPROTOTYPE"]
      val wsaenoprotoopt: float [@@js.global "WSAENOPROTOOPT"]
      val wsaeprotonosupport: float [@@js.global "WSAEPROTONOSUPPORT"]
      val wsaesocktnosupport: float [@@js.global "WSAESOCKTNOSUPPORT"]
      val wsaeopnotsupp: float [@@js.global "WSAEOPNOTSUPP"]
      val wsaepfnosupport: float [@@js.global "WSAEPFNOSUPPORT"]
      val wsaeafnosupport: float [@@js.global "WSAEAFNOSUPPORT"]
      val wsaeaddrinuse: float [@@js.global "WSAEADDRINUSE"]
      val wsaeaddrnotavail: float [@@js.global "WSAEADDRNOTAVAIL"]
      val wsaenetdown: float [@@js.global "WSAENETDOWN"]
      val wsaenetunreach: float [@@js.global "WSAENETUNREACH"]
      val wsaenetreset: float [@@js.global "WSAENETRESET"]
      val wsaeconnaborted: float [@@js.global "WSAECONNABORTED"]
      val wsaeconnreset: float [@@js.global "WSAECONNRESET"]
      val wsaenobufs: float [@@js.global "WSAENOBUFS"]
      val wsaeisconn: float [@@js.global "WSAEISCONN"]
      val wsaenotconn: float [@@js.global "WSAENOTCONN"]
      val wsaeshutdown: float [@@js.global "WSAESHUTDOWN"]
      val wsaetoomanyrefs: float [@@js.global "WSAETOOMANYREFS"]
      val wsaetimedout: float [@@js.global "WSAETIMEDOUT"]
      val wsaeconnrefused: float [@@js.global "WSAECONNREFUSED"]
      val wsaeloop: float [@@js.global "WSAELOOP"]
      val wsaenametoolong: float [@@js.global "WSAENAMETOOLONG"]
      val wsaehostdown: float [@@js.global "WSAEHOSTDOWN"]
      val wsaehostunreach: float [@@js.global "WSAEHOSTUNREACH"]
      val wsaenotempty: float [@@js.global "WSAENOTEMPTY"]
      val wsaeproclim: float [@@js.global "WSAEPROCLIM"]
      val wsaeusers: float [@@js.global "WSAEUSERS"]
      val wsaedquot: float [@@js.global "WSAEDQUOT"]
      val wsaestale: float [@@js.global "WSAESTALE"]
      val wsaeremote: float [@@js.global "WSAEREMOTE"]
      val wsasysnotready: float [@@js.global "WSASYSNOTREADY"]
      val wsavernotsupported: float [@@js.global "WSAVERNOTSUPPORTED"]
      val wsanotinitialised: float [@@js.global "WSANOTINITIALISED"]
      val wsaediscon: float [@@js.global "WSAEDISCON"]
      val wsaenomore: float [@@js.global "WSAENOMORE"]
      val wsaecancelled: float [@@js.global "WSAECANCELLED"]
      val wsaeinvalidproctable: float [@@js.global "WSAEINVALIDPROCTABLE"]
      val wsaeinvalidprovider: float [@@js.global "WSAEINVALIDPROVIDER"]
      val wsaeproviderfailedinit: float [@@js.global "WSAEPROVIDERFAILEDINIT"]
      val wsasyscallfailure: float [@@js.global "WSASYSCALLFAILURE"]
      val wsaservice_not_found: float [@@js.global "WSASERVICE_NOT_FOUND"]
      val wsatype_not_found: float [@@js.global "WSATYPE_NOT_FOUND"]
      val wsa_e_no_more: float [@@js.global "WSA_E_NO_MORE"]
      val wsa_e_cancelled: float [@@js.global "WSA_E_CANCELLED"]
      val wsaerefused: float [@@js.global "WSAEREFUSED"]
    end
    module[@js.scope "priority"] Priority : sig
      val priority_low: float [@@js.global "PRIORITY_LOW"]
      val priority_below_normal: float [@@js.global "PRIORITY_BELOW_NORMAL"]
      val priority_normal: float [@@js.global "PRIORITY_NORMAL"]
      val priority_above_normal: float [@@js.global "PRIORITY_ABOVE_NORMAL"]
      val priority_high: float [@@js.global "PRIORITY_HIGH"]
      val priority_highest: float [@@js.global "PRIORITY_HIGHEST"]
    end
  end
  val arch: unit -> string [@@js.global "arch"]
  (**
    Returns a string identifying the kernel version.
    On POSIX systems, the operating system release is determined by calling
    \[uname(3)\]\[\]. On Windows, `pRtlGetVersion` is used, and if it is not available,
    `GetVersionExW()` will be used. See
    https://en.wikipedia.org/wiki/Uname#Examples for more information.
  *)
  val version: unit -> string [@@js.global "version"]
  val platform: unit -> NodeJS.Platform.t_0 [@@js.global "platform"]
  val tmpdir: unit -> string [@@js.global "tmpdir"]
  val eol: string [@@js.global "EOL"]
  val endianness: unit -> ([`L_s4_BE[@js "BE"] | `L_s64_LE[@js "LE"]] [@js.enum]) [@@js.global "endianness"]
  (**
    Gets the priority of a process.
    Defaults to current process.
  *)
  val getPriority: ?pid:float -> unit -> float [@@js.global "getPriority"]
  (**
    Sets the priority of the current process.
    @param priority Must be in range of -20 to 19
  *)
  val setPriority: priority:float -> unit [@@js.global "setPriority"]
  (**
    Sets the priority of the process specified process.
    @param priority Must be in range of -20 to 19
  *)
  val setPriority: pid:float -> priority:float -> unit [@@js.global "setPriority"]
end
module Node_path : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = path
    clause = NamespaceImport ([object Object])
    loc = line 2, col 5 of node_modules/@types/node/path.d.ts } *)
  (* CommonJsExport ({ name = [path]
    fullName = [path]
    loc = line 3, col 14 of node_modules/@types/node/path.d.ts }) *)
end
module[@js.scope "path"] Path : sig
  module[@js.scope "path"] Path : sig
    (** A parsed path object generated by path.parse() or consumed by path.format(). *)
    module[@js.scope "ParsedPath"] ParsedPath : sig
      type t = path_path_ParsedPath
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** The root of the path such as '/' or 'c:\' *)
      (** The root of the path such as '/' or 'c:\' *)
      val get_root: t -> string [@@js.get "root"]
      (** The root of the path such as '/' or 'c:\' *)
      val set_root: t -> string -> unit [@@js.set "root"]
      (** The full directory path such as '/home/user/dir' or 'c:\path\dir' *)
      (** The full directory path such as '/home/user/dir' or 'c:\path\dir' *)
      val get_dir: t -> string [@@js.get "dir"]
      (** The full directory path such as '/home/user/dir' or 'c:\path\dir' *)
      val set_dir: t -> string -> unit [@@js.set "dir"]
      (** The file name including extension (if any) such as 'index.html' *)
      (** The file name including extension (if any) such as 'index.html' *)
      val get_base: t -> string [@@js.get "base"]
      (** The file name including extension (if any) such as 'index.html' *)
      val set_base: t -> string -> unit [@@js.set "base"]
      (** The file extension (if any) such as '.html' *)
      (** The file extension (if any) such as '.html' *)
      val get_ext: t -> string [@@js.get "ext"]
      (** The file extension (if any) such as '.html' *)
      val set_ext: t -> string -> unit [@@js.set "ext"]
      (** The file name without extension (if any) such as 'index' *)
      (** The file name without extension (if any) such as 'index' *)
      val get_name: t -> string [@@js.get "name"]
      (** The file name without extension (if any) such as 'index' *)
      val set_name: t -> string -> unit [@@js.set "name"]
    end
    module[@js.scope "FormatInputPathObject"] FormatInputPathObject : sig
      type t = path_path_FormatInputPathObject
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** The root of the path such as '/' or 'c:\' *)
      (** The root of the path such as '/' or 'c:\' *)
      val get_root: t -> string [@@js.get "root"]
      (** The root of the path such as '/' or 'c:\' *)
      val set_root: t -> string -> unit [@@js.set "root"]
      (** The full directory path such as '/home/user/dir' or 'c:\path\dir' *)
      (** The full directory path such as '/home/user/dir' or 'c:\path\dir' *)
      val get_dir: t -> string [@@js.get "dir"]
      (** The full directory path such as '/home/user/dir' or 'c:\path\dir' *)
      val set_dir: t -> string -> unit [@@js.set "dir"]
      (** The file name including extension (if any) such as 'index.html' *)
      (** The file name including extension (if any) such as 'index.html' *)
      val get_base: t -> string [@@js.get "base"]
      (** The file name including extension (if any) such as 'index.html' *)
      val set_base: t -> string -> unit [@@js.set "base"]
      (** The file extension (if any) such as '.html' *)
      (** The file extension (if any) such as '.html' *)
      val get_ext: t -> string [@@js.get "ext"]
      (** The file extension (if any) such as '.html' *)
      val set_ext: t -> string -> unit [@@js.set "ext"]
      (** The file name without extension (if any) such as 'index' *)
      (** The file name without extension (if any) such as 'index' *)
      val get_name: t -> string [@@js.get "name"]
      (** The file name without extension (if any) such as 'index' *)
      val set_name: t -> string -> unit [@@js.set "name"]
    end
    module[@js.scope "PlatformPath"] PlatformPath : sig
      type t = path_path_PlatformPath
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (**
        Normalize a string path, reducing '..' and '.' parts.
        When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
        @param p string path to normalize.
      *)
      val normalize: t -> p:string -> string [@@js.call "normalize"]
      (**
        Join all arguments together and normalize the resulting path.
        Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.
        @param paths paths to join.
      *)
      val join: t -> paths:(string list [@js.variadic]) -> string [@@js.call "join"]
      (**
        The right-most parameter is considered \{to\}.  Other parameters are considered an array of \{from\}.
        
        Starting from leftmost \{from\} parameter, resolves \{to\} to an absolute path.
        
        If \{to\} isn't already absolute, \{from\} arguments are prepended in right to left order,
        until an absolute path is found. If after using all \{from\} paths still no absolute path is found,
        the current working directory is used as well. The resulting path is normalized,
        and trailing slashes are removed unless the path gets resolved to the root directory.
        @param pathSegments string paths to join.  Non-string arguments are ignored.
      *)
      val resolve: t -> pathSegments:(string list [@js.variadic]) -> string [@@js.call "resolve"]
      (**
        Determines whether \{path\} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
        @param path path to test.
      *)
      val isAbsolute: t -> p:string -> bool [@@js.call "isAbsolute"]
      (**
        Solve the relative path from \{from\} to \{to\}.
        At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
      *)
      val relative: t -> from:string -> to_:string -> string [@@js.call "relative"]
      (**
        Return the directory name of a path. Similar to the Unix dirname command.
        @param p the path to evaluate.
      *)
      val dirname: t -> p:string -> string [@@js.call "dirname"]
      (**
        Return the last portion of a path. Similar to the Unix basename command.
        Often used to extract the file name from a fully qualified path.
        @param p the path to evaluate.
        @param ext optionally, an extension to remove from the result.
      *)
      val basename: t -> p:string -> ?ext:string -> unit -> string [@@js.call "basename"]
      (**
        Return the extension of the path, from the last '.' to end of string in the last portion of the path.
        If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string
        @param p the path to evaluate.
      *)
      val extname: t -> p:string -> string [@@js.call "extname"]
      (** The platform-specific file separator. '\\' or '/'. *)
      val get_sep: t -> string [@@js.get "sep"]
      (** The platform-specific file delimiter. ';' or ':'. *)
      val get_delimiter: t -> string [@@js.get "delimiter"]
      (**
        Returns an object from a path string - the opposite of format().
        @param pathString path to evaluate.
      *)
      val parse: t -> p:string -> path_path_ParsedPath [@@js.call "parse"]
      (**
        Returns a path string from an object - the opposite of parse().
        @param pathString path to evaluate.
      *)
      val format: t -> pP:path_path_FormatInputPathObject -> string [@@js.call "format"]
      (**
        On Windows systems only, returns an equivalent namespace-prefixed path for the given path.
        If path is not a string, path will be returned without modifications.
        This method is meaningful only on Windows system.
        On POSIX systems, the method is non-operational and always returns path without modifications.
      *)
      val toNamespacedPath: t -> path:string -> string [@@js.call "toNamespacedPath"]
      (**
        Posix specific pathing.
        Same as parent object on posix.
      *)
      val get_posix: t -> t [@@js.get "posix"]
      (**
        Windows specific pathing.
        Same as parent object on windows
      *)
      val get_win32: t -> t [@@js.get "win32"]
    end
  end
  val path: path_path_PlatformPath [@@js.global "path"]
  (* CommonJsExport ({ name = [path]
    fullName = [path; path]
    loc = line 157, col 14 of node_modules/@types/node/path.d.ts }) *)
end
module Node_perf_hooks : sig
  (* export * from 'perf_hooks'; *)
end
module[@js.scope "perf_hooks"] Perf_hooks : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:async_hooks
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/perf_hooks.d.ts } *)
  module EntryType : sig
    type t = perf_hooks_EntryType
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "PerformanceEntry"] PerformanceEntry : sig
    type t = perf_hooks_PerformanceEntry
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      The total number of milliseconds elapsed for this entry.
      This value will not be meaningful for all Performance Entry types.
    *)
    val get_duration: t -> float [@@js.get "duration"]
    (** The name of the performance entry. *)
    val get_name: t -> string [@@js.get "name"]
    (** The high resolution millisecond timestamp marking the starting time of the Performance Entry. *)
    val get_startTime: t -> float [@@js.get "startTime"]
    (**
      The type of the performance entry.
      Currently it may be one of: 'node', 'mark', 'measure', 'gc', or 'function'.
    *)
    val get_entryType: t -> perf_hooks_EntryType [@@js.get "entryType"]
    (**
      When `performanceEntry.entryType` is equal to 'gc', `the performance.kind` property identifies
      the type of garbage collection operation that occurred.
      See perf_hooks.constants for valid values.
    *)
    val get_kind: t -> float [@@js.get "kind"]
    (**
      When `performanceEntry.entryType` is equal to 'gc', the `performance.flags`
      property contains additional information about garbage collection operation.
      See perf_hooks.constants for valid values.
    *)
    val get_flags: t -> float [@@js.get "flags"]
  end
  module[@js.scope "PerformanceNodeTiming"] PerformanceNodeTiming : sig
    type t = perf_hooks_PerformanceNodeTiming
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** The high resolution millisecond timestamp at which the Node.js process completed bootstrap. *)
    val get_bootstrapComplete: t -> float [@@js.get "bootstrapComplete"]
    (**
      The high resolution millisecond timestamp at which the Node.js process completed bootstrapping.
      If bootstrapping has not yet finished, the property has the value of -1.
    *)
    val get_environment: t -> float [@@js.get "environment"]
    (** The high resolution millisecond timestamp at which the Node.js environment was initialized. *)
    val get_idleTime: t -> float [@@js.get "idleTime"]
    (**
      The high resolution millisecond timestamp of the amount of time the event loop has been idle
       within the event loop's event provider (e.g. `epoll_wait`). This does not take CPU usage
      into consideration. If the event loop has not yet started (e.g., in the first tick of the main script),
       the property has the value of 0.
    *)
    val get_loopExit: t -> float [@@js.get "loopExit"]
    (**
      The high resolution millisecond timestamp at which the Node.js event loop started.
      If the event loop has not yet started (e.g., in the first tick of the main script), the property has the value of -1.
    *)
    val get_loopStart: t -> float [@@js.get "loopStart"]
    (** The high resolution millisecond timestamp at which the V8 platform was initialized. *)
    val get_v8Start: t -> float [@@js.get "v8Start"]
    val cast: t -> perf_hooks_PerformanceEntry [@@js.cast]
  end
  module[@js.scope "EventLoopUtilization"] EventLoopUtilization : sig
    type t = perf_hooks_EventLoopUtilization
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_idle: t -> float [@@js.get "idle"]
    val set_idle: t -> float -> unit [@@js.set "idle"]
    val get_active: t -> float [@@js.get "active"]
    val set_active: t -> float -> unit [@@js.set "active"]
    val get_utilization: t -> float [@@js.get "utilization"]
    val set_utilization: t -> float -> unit [@@js.set "utilization"]
  end
  module[@js.scope "Performance"] Performance : sig
    type t = perf_hooks_Performance
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      If name is not provided, removes all PerformanceMark objects from the Performance Timeline.
      If name is provided, removes only the named mark.
      @param name 
    *)
    val clearMarks: t -> ?name:string -> unit -> unit [@@js.call "clearMarks"]
    (**
      Creates a new PerformanceMark entry in the Performance Timeline.
      A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark',
      and whose performanceEntry.duration is always 0.
      Performance marks are used to mark specific significant moments in the Performance Timeline.
      @param name 
    *)
    val mark: t -> ?name:string -> unit -> unit [@@js.call "mark"]
    (**
      Creates a new PerformanceMeasure entry in the Performance Timeline.
      A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',
      and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.
      
      The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify
      any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,
      then startMark is set to timeOrigin by default.
      
      The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp
      properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.
      @param name 
      @param startMark 
      @param endMark 
    *)
    val measure: t -> name:string -> startMark:string -> endMark:string -> unit [@@js.call "measure"]
    (** An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones. *)
    val get_nodeTiming: t -> perf_hooks_PerformanceNodeTiming [@@js.get "nodeTiming"]
    (** @return the current high resolution millisecond timestamp *)
    val now: t -> float [@@js.call "now"]
    (** The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured. *)
    val get_timeOrigin: t -> float [@@js.get "timeOrigin"]
    (**
      Wraps a function within a new function that measures the running time of the wrapped function.
      A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed.
      @param fn 
    *)
    val timerify: t -> fn:'T -> 'T [@@js.call "timerify"]
    (**
      eventLoopUtilization is similar to CPU utilization except that it is calculated using high precision wall-clock time.
      It represents the percentage of time the event loop has spent outside the event loop's event provider (e.g. epoll_wait).
      No other CPU idle time is taken into consideration.
      @param util1 The result of a previous call to eventLoopUtilization()
      @param util2 The result of a previous call to eventLoopUtilization() prior to util1
    *)
    val eventLoopUtilization: t -> ?util1:perf_hooks_EventLoopUtilization -> ?util2:perf_hooks_EventLoopUtilization -> unit -> perf_hooks_EventLoopUtilization [@@js.call "eventLoopUtilization"]
  end
  module[@js.scope "PerformanceObserverEntryList"] PerformanceObserverEntryList : sig
    type t = perf_hooks_PerformanceObserverEntryList
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime. *)
    val getEntries: t -> perf_hooks_PerformanceEntry list [@@js.call "getEntries"]
    (**
      @return a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime
      whose performanceEntry.name is equal to name, and optionally, whose performanceEntry.entryType is equal to type.
    *)
    val getEntriesByName: t -> name:string -> ?type_:perf_hooks_EntryType -> unit -> perf_hooks_PerformanceEntry list [@@js.call "getEntriesByName"]
    (**
      @return Returns a list of PerformanceEntry objects in chronological order with respect to performanceEntry.startTime
      whose performanceEntry.entryType is equal to type.
    *)
    val getEntriesByType: t -> type_:perf_hooks_EntryType -> perf_hooks_PerformanceEntry list [@@js.call "getEntriesByType"]
  end
  module[@js.scope "PerformanceObserverCallback"] PerformanceObserverCallback : sig
    type t = perf_hooks_PerformanceObserverCallback
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> list:perf_hooks_PerformanceObserverEntryList -> observer:perf_hooks_PerformanceObserver -> unit [@@js.apply]
  end
  module[@js.scope "PerformanceObserver"] PerformanceObserver : sig
    type t = perf_hooks_PerformanceObserver
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: callback:perf_hooks_PerformanceObserverCallback -> t [@@js.create]
    (** Disconnects the PerformanceObserver instance from all notifications. *)
    val disconnect: t -> unit [@@js.call "disconnect"]
    (**
      Subscribes the PerformanceObserver instance to notifications of new PerformanceEntry instances identified by options.entryTypes.
      When options.buffered is false, the callback will be invoked once for every PerformanceEntry instance.
      Property buffered defaults to false.
      @param options 
    *)
    val observe: t -> options:anonymous_interface_21 -> unit [@@js.call "observe"]
    val cast: t -> AsyncResource.t_0 [@@js.cast]
  end
  module[@js.scope "constants"] Constants : sig
    val node_performance_gc_major: float [@@js.global "NODE_PERFORMANCE_GC_MAJOR"]
    val node_performance_gc_minor: float [@@js.global "NODE_PERFORMANCE_GC_MINOR"]
    val node_performance_gc_incremental: float [@@js.global "NODE_PERFORMANCE_GC_INCREMENTAL"]
    val node_performance_gc_weakcb: float [@@js.global "NODE_PERFORMANCE_GC_WEAKCB"]
    val node_performance_gc_flags_no: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_NO"]
    val node_performance_gc_flags_construct_retained: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED"]
    val node_performance_gc_flags_forced: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_FORCED"]
    val node_performance_gc_flags_synchronous_phantom_processing: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING"]
    val node_performance_gc_flags_all_available_garbage: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE"]
    val node_performance_gc_flags_all_external_memory: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY"]
    val node_performance_gc_flags_schedule_idle: float [@@js.global "NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE"]
  end
  val performance: perf_hooks_Performance [@@js.global "performance"]
  module[@js.scope "EventLoopMonitorOptions"] EventLoopMonitorOptions : sig
    type t = perf_hooks_EventLoopMonitorOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      The sampling rate in milliseconds.
      Must be greater than zero.
      default: 10
    *)
    (**
      The sampling rate in milliseconds.
      Must be greater than zero.
      default: 10
    *)
    val get_resolution: t -> float [@@js.get "resolution"]
    (**
      The sampling rate in milliseconds.
      Must be greater than zero.
      default: 10
    *)
    val set_resolution: t -> float -> unit [@@js.set "resolution"]
  end
  module[@js.scope "EventLoopDelayMonitor"] EventLoopDelayMonitor : sig
    type t = perf_hooks_EventLoopDelayMonitor
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Enables the event loop delay sample timer. Returns `true` if the timer was started, `false` if it was already started. *)
    val enable: t -> bool [@@js.call "enable"]
    (** Disables the event loop delay sample timer. Returns `true` if the timer was stopped, `false` if it was already stopped. *)
    val disable: t -> bool [@@js.call "disable"]
    (** Resets the collected histogram data. *)
    val reset: t -> unit [@@js.call "reset"]
    (**
      Returns the value at the given percentile.
      @param percentile A percentile value between 1 and 100.
    *)
    val percentile: t -> percentile:float -> float [@@js.call "percentile"]
    (** A `Map` object detailing the accumulated percentile distribution. *)
    val get_percentiles: t -> (float, float) Map.t_2 [@@js.get "percentiles"]
    (** The number of times the event loop delay exceeded the maximum 1 hour eventloop delay threshold. *)
    val get_exceeds: t -> float [@@js.get "exceeds"]
    (** The minimum recorded event loop delay. *)
    val get_min: t -> float [@@js.get "min"]
    (** The maximum recorded event loop delay. *)
    val get_max: t -> float [@@js.get "max"]
    (** The mean of the recorded event loop delays. *)
    val get_mean: t -> float [@@js.get "mean"]
    (** The standard deviation of the recorded event loop delays. *)
    val get_stddev: t -> float [@@js.get "stddev"]
  end
  val monitorEventLoopDelay: ?options:perf_hooks_EventLoopMonitorOptions -> unit -> perf_hooks_EventLoopDelayMonitor [@@js.global "monitorEventLoopDelay"]
end
module Node_process : sig
  (* CommonJsExport ({ name = [process]
    fullName = [process]
    loc = line 2, col 14 of node_modules/@types/node/process.d.ts }) *)
end
module[@js.scope "process"] Process : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:tty
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/process.d.ts } *)
  module[@js.scope "global"] Global : sig
    val process: process_global_NodeJS_Process [@@js.global "process"]
    module[@js.scope "NodeJS"] NodeJS : sig
      module[@js.scope "ReadStream"] ReadStream : sig
        type t = process_global_NodeJS_ReadStream
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val cast: t -> tty_ReadStream [@@js.cast]
      end
      module[@js.scope "WriteStream"] WriteStream : sig
        type t = process_global_NodeJS_WriteStream
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val cast: t -> tty_WriteStream [@@js.cast]
      end
      module[@js.scope "MemoryUsage"] MemoryUsage : sig
        type t = process_global_NodeJS_MemoryUsage
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_rss: t -> float [@@js.get "rss"]
        val set_rss: t -> float -> unit [@@js.set "rss"]
        val get_heapTotal: t -> float [@@js.get "heapTotal"]
        val set_heapTotal: t -> float -> unit [@@js.set "heapTotal"]
        val get_heapUsed: t -> float [@@js.get "heapUsed"]
        val set_heapUsed: t -> float -> unit [@@js.set "heapUsed"]
        val get_external: t -> float [@@js.get "external"]
        val set_external: t -> float -> unit [@@js.set "external"]
        val get_arrayBuffers: t -> float [@@js.get "arrayBuffers"]
        val set_arrayBuffers: t -> float -> unit [@@js.set "arrayBuffers"]
      end
      module[@js.scope "CpuUsage"] CpuUsage : sig
        type t = process_global_NodeJS_CpuUsage
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_user: t -> float [@@js.get "user"]
        val set_user: t -> float -> unit [@@js.set "user"]
        val get_system: t -> float [@@js.get "system"]
        val set_system: t -> float -> unit [@@js.set "system"]
      end
      module[@js.scope "ProcessRelease"] ProcessRelease : sig
        type t = process_global_NodeJS_ProcessRelease
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_name: t -> string [@@js.get "name"]
        val set_name: t -> string -> unit [@@js.set "name"]
        val get_sourceUrl: t -> string [@@js.get "sourceUrl"]
        val set_sourceUrl: t -> string -> unit [@@js.set "sourceUrl"]
        val get_headersUrl: t -> string [@@js.get "headersUrl"]
        val set_headersUrl: t -> string -> unit [@@js.set "headersUrl"]
        val get_libUrl: t -> string [@@js.get "libUrl"]
        val set_libUrl: t -> string -> unit [@@js.set "libUrl"]
        val get_lts: t -> string [@@js.get "lts"]
        val set_lts: t -> string -> unit [@@js.set "lts"]
      end
      module[@js.scope "ProcessVersions"] ProcessVersions : sig
        type t = process_global_NodeJS_ProcessVersions
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_http_parser: t -> string [@@js.get "http_parser"]
        val set_http_parser: t -> string -> unit [@@js.set "http_parser"]
        val get_node: t -> string [@@js.get "node"]
        val set_node: t -> string -> unit [@@js.set "node"]
        val get_v8: t -> string [@@js.get "v8"]
        val set_v8: t -> string -> unit [@@js.set "v8"]
        val get_ares: t -> string [@@js.get "ares"]
        val set_ares: t -> string -> unit [@@js.set "ares"]
        val get_uv: t -> string [@@js.get "uv"]
        val set_uv: t -> string -> unit [@@js.set "uv"]
        val get_zlib: t -> string [@@js.get "zlib"]
        val set_zlib: t -> string -> unit [@@js.set "zlib"]
        val get_modules: t -> string [@@js.get "modules"]
        val set_modules: t -> string -> unit [@@js.set "modules"]
        val get_openssl: t -> string [@@js.get "openssl"]
        val set_openssl: t -> string -> unit [@@js.set "openssl"]
        val cast: t -> string Dict.t_1 [@@js.cast]
      end
      module Platform : sig
        type t = process_global_NodeJS_Platform
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
      end
      module Signals : sig
        type t = process_global_NodeJS_Signals
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
      end
      module MultipleResolveType : sig
        type t = process_global_NodeJS_MultipleResolveType
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
      end
      module[@js.scope "BeforeExitListener"] BeforeExitListener : sig
        type t = process_global_NodeJS_BeforeExitListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> code:float -> unit [@@js.apply]
      end
      module[@js.scope "DisconnectListener"] DisconnectListener : sig
        type t = process_global_NodeJS_DisconnectListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> unit [@@js.apply]
      end
      module[@js.scope "ExitListener"] ExitListener : sig
        type t = process_global_NodeJS_ExitListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> code:float -> unit [@@js.apply]
      end
      module[@js.scope "RejectionHandledListener"] RejectionHandledListener : sig
        type t = process_global_NodeJS_RejectionHandledListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> promise:any Promise.t_1 -> unit [@@js.apply]
      end
      module[@js.scope "UncaughtExceptionListener"] UncaughtExceptionListener : sig
        type t = process_global_NodeJS_UncaughtExceptionListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> error:Error.t_0 -> unit [@@js.apply]
      end
      module[@js.scope "UnhandledRejectionListener"] UnhandledRejectionListener : sig
        type t = process_global_NodeJS_UnhandledRejectionListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> reason:anonymous_interface_0 or_null_or_undefined -> promise:any Promise.t_1 -> unit [@@js.apply]
      end
      module[@js.scope "WarningListener"] WarningListener : sig
        type t = process_global_NodeJS_WarningListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> warning:Error.t_0 -> unit [@@js.apply]
      end
      module[@js.scope "MessageListener"] MessageListener : sig
        type t = process_global_NodeJS_MessageListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> message:any -> sendHandle:any -> unit [@@js.apply]
      end
      module[@js.scope "SignalsListener"] SignalsListener : sig
        type t = process_global_NodeJS_SignalsListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> signal:process_global_NodeJS_Signals -> unit [@@js.apply]
      end
      module[@js.scope "NewListenerListener"] NewListenerListener : sig
        type t = process_global_NodeJS_NewListenerListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> type_:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> unit [@@js.apply]
      end
      module[@js.scope "RemoveListenerListener"] RemoveListenerListener : sig
        type t = process_global_NodeJS_RemoveListenerListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> type_:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> unit [@@js.apply]
      end
      module[@js.scope "MultipleResolveListener"] MultipleResolveListener : sig
        type t = process_global_NodeJS_MultipleResolveListener
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> type_:process_global_NodeJS_MultipleResolveType -> promise:any Promise.t_1 -> value:any -> unit [@@js.apply]
      end
      module[@js.scope "Socket"] Socket : sig
        type t = process_global_NodeJS_Socket
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_isTTY: t -> ([`L_b_true[@js true]] [@js.enum]) [@@js.get "isTTY"]
        val set_isTTY: t -> ([`L_b_true] [@js.enum]) -> unit [@@js.set "isTTY"]
        val cast: t -> ReadWriteStream.t_0 [@@js.cast]
      end
      module[@js.scope "ProcessEnv"] ProcessEnv : sig
        type t = process_global_NodeJS_ProcessEnv
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val cast: t -> string Dict.t_1 [@@js.cast]
      end
      module[@js.scope "HRTime"] HRTime : sig
        type t = process_global_NodeJS_HRTime
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val apply: t -> ?time:(float * float) -> unit -> (float * float) [@@js.apply]
        val bigint: t -> bigint [@@js.call "bigint"]
      end
      module[@js.scope "ProcessReport"] ProcessReport : sig
        type t = process_global_NodeJS_ProcessReport
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        (**
          Directory where the report is written.
          working directory of the Node.js process.
          default: '' indicating that reports are written to the current
        *)
        (**
          Directory where the report is written.
          working directory of the Node.js process.
          default: '' indicating that reports are written to the current
        *)
        val get_directory: t -> string [@@js.get "directory"]
        (**
          Directory where the report is written.
          working directory of the Node.js process.
          default: '' indicating that reports are written to the current
        *)
        val set_directory: t -> string -> unit [@@js.set "directory"]
        (**
          Filename where the report is written.
          The default value is the empty string.
          default: '' the output filename will be comprised of a timestamp,
          PID, and sequence number.
        *)
        (**
          Filename where the report is written.
          The default value is the empty string.
          default: '' the output filename will be comprised of a timestamp,
          PID, and sequence number.
        *)
        val get_filename: t -> string [@@js.get "filename"]
        (**
          Filename where the report is written.
          The default value is the empty string.
          default: '' the output filename will be comprised of a timestamp,
          PID, and sequence number.
        *)
        val set_filename: t -> string -> unit [@@js.set "filename"]
        (**
          Returns a JSON-formatted diagnostic report for the running process.
          The report's JavaScript stack trace is taken from err, if present.
        *)
        val getReport: t -> ?err:Error.t_0 -> unit -> string [@@js.call "getReport"]
        (**
          If true, a diagnostic report is generated on fatal errors,
          such as out of memory errors or failed C++ assertions.
          default: false
        *)
        (**
          If true, a diagnostic report is generated on fatal errors,
          such as out of memory errors or failed C++ assertions.
          default: false
        *)
        val get_reportOnFatalError: t -> bool [@@js.get "reportOnFatalError"]
        (**
          If true, a diagnostic report is generated on fatal errors,
          such as out of memory errors or failed C++ assertions.
          default: false
        *)
        val set_reportOnFatalError: t -> bool -> unit [@@js.set "reportOnFatalError"]
        (**
          If true, a diagnostic report is generated when the process
          receives the signal specified by process.report.signal.
          defaul: false
        *)
        (**
          If true, a diagnostic report is generated when the process
          receives the signal specified by process.report.signal.
          defaul: false
        *)
        val get_reportOnSignal: t -> bool [@@js.get "reportOnSignal"]
        (**
          If true, a diagnostic report is generated when the process
          receives the signal specified by process.report.signal.
          defaul: false
        *)
        val set_reportOnSignal: t -> bool -> unit [@@js.set "reportOnSignal"]
        (**
          If true, a diagnostic report is generated on uncaught exception.
          default: false
        *)
        (**
          If true, a diagnostic report is generated on uncaught exception.
          default: false
        *)
        val get_reportOnUncaughtException: t -> bool [@@js.get "reportOnUncaughtException"]
        (**
          If true, a diagnostic report is generated on uncaught exception.
          default: false
        *)
        val set_reportOnUncaughtException: t -> bool -> unit [@@js.set "reportOnUncaughtException"]
        (**
          The signal used to trigger the creation of a diagnostic report.
          default: 'SIGUSR2'
        *)
        (**
          The signal used to trigger the creation of a diagnostic report.
          default: 'SIGUSR2'
        *)
        val get_signal: t -> process_global_NodeJS_Signals [@@js.get "signal"]
        (**
          The signal used to trigger the creation of a diagnostic report.
          default: 'SIGUSR2'
        *)
        val set_signal: t -> process_global_NodeJS_Signals -> unit [@@js.set "signal"]
        (**
          Writes a diagnostic report to a file. If filename is not provided, the default filename
          includes the date, time, PID, and a sequence number.
          The report's JavaScript stack trace is taken from err, if present.
          @param fileName Name of the file where the report is written.
          This should be a relative path, that will be appended to the directory specified in
          `process.report.directory`, or the current working directory of the Node.js process,
          if unspecified.
          @param error A custom error used for reporting the JavaScript stack.
          @return Filename of the generated report.
        *)
        val writeReport: t -> ?fileName:string -> unit -> string [@@js.call "writeReport"]
        (**
          Writes a diagnostic report to a file. If filename is not provided, the default filename
          includes the date, time, PID, and a sequence number.
          The report's JavaScript stack trace is taken from err, if present.
        *)
        val writeReport': t -> ?error:Error.t_0 -> unit -> string [@@js.call "writeReport"]
        (**
          Writes a diagnostic report to a file. If filename is not provided, the default filename
          includes the date, time, PID, and a sequence number.
          The report's JavaScript stack trace is taken from err, if present.
        *)
        val writeReport'': t -> ?fileName:string -> ?err:Error.t_0 -> unit -> string [@@js.call "writeReport"]
      end
      module[@js.scope "ResourceUsage"] ResourceUsage : sig
        type t = process_global_NodeJS_ResourceUsage
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_fsRead: t -> float [@@js.get "fsRead"]
        val set_fsRead: t -> float -> unit [@@js.set "fsRead"]
        val get_fsWrite: t -> float [@@js.get "fsWrite"]
        val set_fsWrite: t -> float -> unit [@@js.set "fsWrite"]
        val get_involuntaryContextSwitches: t -> float [@@js.get "involuntaryContextSwitches"]
        val set_involuntaryContextSwitches: t -> float -> unit [@@js.set "involuntaryContextSwitches"]
        val get_ipcReceived: t -> float [@@js.get "ipcReceived"]
        val set_ipcReceived: t -> float -> unit [@@js.set "ipcReceived"]
        val get_ipcSent: t -> float [@@js.get "ipcSent"]
        val set_ipcSent: t -> float -> unit [@@js.set "ipcSent"]
        val get_majorPageFault: t -> float [@@js.get "majorPageFault"]
        val set_majorPageFault: t -> float -> unit [@@js.set "majorPageFault"]
        val get_maxRSS: t -> float [@@js.get "maxRSS"]
        val set_maxRSS: t -> float -> unit [@@js.set "maxRSS"]
        val get_minorPageFault: t -> float [@@js.get "minorPageFault"]
        val set_minorPageFault: t -> float -> unit [@@js.set "minorPageFault"]
        val get_sharedMemorySize: t -> float [@@js.get "sharedMemorySize"]
        val set_sharedMemorySize: t -> float -> unit [@@js.set "sharedMemorySize"]
        val get_signalsCount: t -> float [@@js.get "signalsCount"]
        val set_signalsCount: t -> float -> unit [@@js.set "signalsCount"]
        val get_swappedOut: t -> float [@@js.get "swappedOut"]
        val set_swappedOut: t -> float -> unit [@@js.set "swappedOut"]
        val get_systemCPUTime: t -> float [@@js.get "systemCPUTime"]
        val set_systemCPUTime: t -> float -> unit [@@js.set "systemCPUTime"]
        val get_unsharedDataSize: t -> float [@@js.get "unsharedDataSize"]
        val set_unsharedDataSize: t -> float -> unit [@@js.set "unsharedDataSize"]
        val get_unsharedStackSize: t -> float [@@js.get "unsharedStackSize"]
        val set_unsharedStackSize: t -> float -> unit [@@js.set "unsharedStackSize"]
        val get_userCPUTime: t -> float [@@js.get "userCPUTime"]
        val set_userCPUTime: t -> float -> unit [@@js.set "userCPUTime"]
        val get_voluntaryContextSwitches: t -> float [@@js.get "voluntaryContextSwitches"]
        val set_voluntaryContextSwitches: t -> float -> unit [@@js.set "voluntaryContextSwitches"]
      end
      module[@js.scope "EmitWarningOptions"] EmitWarningOptions : sig
        type t = process_global_NodeJS_EmitWarningOptions
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        (**
          When `warning` is a `string`, `type` is the name to use for the _type_ of warning being emitted.
          default: 'Warning'
        *)
        (**
          When `warning` is a `string`, `type` is the name to use for the _type_ of warning being emitted.
          default: 'Warning'
        *)
        val get_type: t -> string [@@js.get "type"]
        (**
          When `warning` is a `string`, `type` is the name to use for the _type_ of warning being emitted.
          default: 'Warning'
        *)
        val set_type: t -> string -> unit [@@js.set "type"]
        (** A unique identifier for the warning instance being emitted. *)
        (** A unique identifier for the warning instance being emitted. *)
        val get_code: t -> string [@@js.get "code"]
        (** A unique identifier for the warning instance being emitted. *)
        val set_code: t -> string -> unit [@@js.set "code"]
        (**
          When `warning` is a `string`, `ctor` is an optional function used to limit the generated stack trace.
          default: process.emitWarning
        *)
        (**
          When `warning` is a `string`, `ctor` is an optional function used to limit the generated stack trace.
          default: process.emitWarning
        *)
        val get_ctor: t -> untyped_function [@@js.get "ctor"]
        (**
          When `warning` is a `string`, `ctor` is an optional function used to limit the generated stack trace.
          default: process.emitWarning
        *)
        val set_ctor: t -> untyped_function -> unit [@@js.set "ctor"]
        (** Additional text to include with the error. *)
        (** Additional text to include with the error. *)
        val get_detail: t -> string [@@js.get "detail"]
        (** Additional text to include with the error. *)
        val set_detail: t -> string -> unit [@@js.set "detail"]
      end
      module[@js.scope "Process"] Process : sig
        type t = process_global_NodeJS_Process
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        (** Can also be a tty.WriteStream, not typed due to limitations. *)
        (** Can also be a tty.WriteStream, not typed due to limitations. *)
        val get_stdout: t -> (process_global_NodeJS_WriteStream, anonymous_interface_24) intersection2 [@@js.get "stdout"]
        (** Can also be a tty.WriteStream, not typed due to limitations. *)
        val set_stdout: t -> (process_global_NodeJS_WriteStream, anonymous_interface_24) intersection2 -> unit [@@js.set "stdout"]
        (** Can also be a tty.WriteStream, not typed due to limitations. *)
        (** Can also be a tty.WriteStream, not typed due to limitations. *)
        val get_stderr: t -> (process_global_NodeJS_WriteStream, anonymous_interface_25) intersection2 [@@js.get "stderr"]
        (** Can also be a tty.WriteStream, not typed due to limitations. *)
        val set_stderr: t -> (process_global_NodeJS_WriteStream, anonymous_interface_25) intersection2 -> unit [@@js.set "stderr"]
        val get_stdin: t -> (process_global_NodeJS_ReadStream, anonymous_interface_23) intersection2 [@@js.get "stdin"]
        val set_stdin: t -> (process_global_NodeJS_ReadStream, anonymous_interface_23) intersection2 -> unit [@@js.set "stdin"]
        val openStdin: t -> process_global_NodeJS_Socket [@@js.call "openStdin"]
        val get_argv: t -> string list [@@js.get "argv"]
        val set_argv: t -> string list -> unit [@@js.set "argv"]
        val get_argv0: t -> string [@@js.get "argv0"]
        val set_argv0: t -> string -> unit [@@js.set "argv0"]
        val get_execArgv: t -> string list [@@js.get "execArgv"]
        val set_execArgv: t -> string list -> unit [@@js.set "execArgv"]
        val get_execPath: t -> string [@@js.get "execPath"]
        val set_execPath: t -> string -> unit [@@js.set "execPath"]
        val abort: t -> never [@@js.call "abort"]
        val chdir: t -> directory:string -> unit [@@js.call "chdir"]
        val cwd: t -> string [@@js.call "cwd"]
        val get_debugPort: t -> float [@@js.get "debugPort"]
        val set_debugPort: t -> float -> unit [@@js.set "debugPort"]
        (**
          The `process.emitWarning()` method can be used to emit custom or application specific process warnings.
          
          These can be listened for by adding a handler to the `'warning'` event.
          @param warning The warning to emit.
          @param type When `warning` is a `string`, `type` is the name to use for the _type_ of warning being emitted. Default: `'Warning'`.
          @param code A unique identifier for the warning instance being emitted.
          @param ctor When `warning` is a `string`, `ctor` is an optional function used to limit the generated stack trace. Default: `process.emitWarning`.
        *)
        val emitWarning: t -> warning:Error.t_0 or_string -> ?ctor:untyped_function -> unit -> unit [@@js.call "emitWarning"]
        (**
          The `process.emitWarning()` method can be used to emit custom or application specific process warnings.
          
          These can be listened for by adding a handler to the `'warning'` event.
        *)
        val emitWarning': t -> warning:Error.t_0 or_string -> ?type_:string -> ?ctor:untyped_function -> unit -> unit [@@js.call "emitWarning"]
        (**
          The `process.emitWarning()` method can be used to emit custom or application specific process warnings.
          
          These can be listened for by adding a handler to the `'warning'` event.
        *)
        val emitWarning'': t -> warning:Error.t_0 or_string -> ?type_:string -> ?code:string -> ?ctor:untyped_function -> unit -> unit [@@js.call "emitWarning"]
        (**
          The `process.emitWarning()` method can be used to emit custom or application specific process warnings.
          
          These can be listened for by adding a handler to the `'warning'` event.
        *)
        val emitWarning''': t -> warning:Error.t_0 or_string -> ?options:process_global_NodeJS_EmitWarningOptions -> unit -> unit [@@js.call "emitWarning"]
        val get_env: t -> process_global_NodeJS_ProcessEnv [@@js.get "env"]
        val set_env: t -> process_global_NodeJS_ProcessEnv -> unit [@@js.set "env"]
        val exit: t -> ?code:float -> unit -> never [@@js.call "exit"]
        val get_exitCode: t -> float [@@js.get "exitCode"]
        val set_exitCode: t -> float -> unit [@@js.set "exitCode"]
        val getgid: t -> float [@@js.call "getgid"]
        val setgid: t -> id:string or_number -> unit [@@js.call "setgid"]
        val getuid: t -> float [@@js.call "getuid"]
        val setuid: t -> id:string or_number -> unit [@@js.call "setuid"]
        val geteuid: t -> float [@@js.call "geteuid"]
        val seteuid: t -> id:string or_number -> unit [@@js.call "seteuid"]
        val getegid: t -> float [@@js.call "getegid"]
        val setegid: t -> id:string or_number -> unit [@@js.call "setegid"]
        val getgroups: t -> float list [@@js.call "getgroups"]
        val setgroups: t -> groups:string or_number list -> unit [@@js.call "setgroups"]
        val setUncaughtExceptionCaptureCallback: t -> cb:(err:Error.t_0 -> unit) or_null -> unit [@@js.call "setUncaughtExceptionCaptureCallback"]
        val hasUncaughtExceptionCaptureCallback: t -> bool [@@js.call "hasUncaughtExceptionCaptureCallback"]
        val get_version: t -> string [@@js.get "version"]
        val set_version: t -> string -> unit [@@js.set "version"]
        val get_versions: t -> process_global_NodeJS_ProcessVersions [@@js.get "versions"]
        val set_versions: t -> process_global_NodeJS_ProcessVersions -> unit [@@js.set "versions"]
        val get_config: t -> anonymous_interface_54 [@@js.get "config"]
        val set_config: t -> anonymous_interface_54 -> unit [@@js.set "config"]
        val kill: t -> pid:float -> ?signal:string or_number -> unit -> ([`L_b_true[@js true]] [@js.enum]) [@@js.call "kill"]
        val get_pid: t -> float [@@js.get "pid"]
        val set_pid: t -> float -> unit [@@js.set "pid"]
        val get_ppid: t -> float [@@js.get "ppid"]
        val set_ppid: t -> float -> unit [@@js.set "ppid"]
        val get_title: t -> string [@@js.get "title"]
        val set_title: t -> string -> unit [@@js.set "title"]
        val get_arch: t -> string [@@js.get "arch"]
        val set_arch: t -> string -> unit [@@js.set "arch"]
        val get_platform: t -> process_global_NodeJS_Platform [@@js.get "platform"]
        val set_platform: t -> process_global_NodeJS_Platform -> unit [@@js.set "platform"]
        (** @deprecated since v14.0.0 - use `require.main` instead. *)
        (** @deprecated since v14.0.0 - use `require.main` instead. *)
        val get_mainModule: t -> Module.t_0 [@@js.get "mainModule"]
        (** @deprecated since v14.0.0 - use `require.main` instead. *)
        val set_mainModule: t -> Module.t_0 -> unit [@@js.set "mainModule"]
        val memoryUsage: t -> process_global_NodeJS_MemoryUsage [@@js.call "memoryUsage"]
        val cpuUsage: t -> ?previousValue:process_global_NodeJS_CpuUsage -> unit -> process_global_NodeJS_CpuUsage [@@js.call "cpuUsage"]
        val nextTick: t -> callback:untyped_function -> args:(any list [@js.variadic]) -> unit [@@js.call "nextTick"]
        val get_release: t -> process_global_NodeJS_ProcessRelease [@@js.get "release"]
        val set_release: t -> process_global_NodeJS_ProcessRelease -> unit [@@js.set "release"]
        val get_features: t -> anonymous_interface_30 [@@js.get "features"]
        val set_features: t -> anonymous_interface_30 -> unit [@@js.set "features"]
        (**
          @deprecated since v14.0.0 - Calling process.umask() with no argument causes
          the process-wide umask to be written twice. This introduces a race condition between threads,
          and is a potential security vulnerability. There is no safe, cross-platform alternative API.
        *)
        val umask: t -> float [@@js.call "umask"]
        (** Can only be set if not in worker thread. *)
        val umask': t -> mask:string or_number -> float [@@js.call "umask"]
        val uptime: t -> float [@@js.call "uptime"]
        val get_hrtime: t -> process_global_NodeJS_HRTime [@@js.get "hrtime"]
        val set_hrtime: t -> process_global_NodeJS_HRTime -> unit [@@js.set "hrtime"]
        val get_domain: t -> Domain.t_0 [@@js.get "domain"]
        val set_domain: t -> Domain.t_0 -> unit [@@js.set "domain"]
        val send: t -> message:any -> ?sendHandle:any -> ?options:anonymous_interface_53 -> ?callback:(error:Error.t_0 or_null -> unit) -> unit -> bool [@@js.call "send"]
        val disconnect: t -> unit [@@js.call "disconnect"]
        val get_connected: t -> bool [@@js.get "connected"]
        val set_connected: t -> bool -> unit [@@js.set "connected"]
        (**
          The `process.allowedNodeEnvironmentFlags` property is a special,
          read-only `Set` of flags allowable within the \[`NODE_OPTIONS`\]\[\]
          environment variable.
        *)
        (**
          The `process.allowedNodeEnvironmentFlags` property is a special,
          read-only `Set` of flags allowable within the \[`NODE_OPTIONS`\]\[\]
          environment variable.
        *)
        val get_allowedNodeEnvironmentFlags: t -> string ReadonlySet.t_1 [@@js.get "allowedNodeEnvironmentFlags"]
        (**
          The `process.allowedNodeEnvironmentFlags` property is a special,
          read-only `Set` of flags allowable within the \[`NODE_OPTIONS`\]\[\]
          environment variable.
        *)
        val set_allowedNodeEnvironmentFlags: t -> string ReadonlySet.t_1 -> unit [@@js.set "allowedNodeEnvironmentFlags"]
        (** Only available with `--experimental-report` *)
        (** Only available with `--experimental-report` *)
        val get_report: t -> process_global_NodeJS_ProcessReport [@@js.get "report"]
        (** Only available with `--experimental-report` *)
        val set_report: t -> process_global_NodeJS_ProcessReport -> unit [@@js.set "report"]
        val resourceUsage: t -> process_global_NodeJS_ResourceUsage [@@js.call "resourceUsage"]
        val get_traceDeprecation: t -> bool [@@js.get "traceDeprecation"]
        val set_traceDeprecation: t -> bool -> unit [@@js.set "traceDeprecation"]
        val addListener: t -> event:([`L_s183_beforeExit] [@js.enum]) -> listener:process_global_NodeJS_BeforeExitListener -> t [@@js.call "addListener"]
        val addListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:process_global_NodeJS_DisconnectListener -> t [@@js.call "addListener"]
        val addListener'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:process_global_NodeJS_ExitListener -> t [@@js.call "addListener"]
        val addListener''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> listener:process_global_NodeJS_RejectionHandledListener -> t [@@js.call "addListener"]
        val addListener'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "addListener"]
        val addListener''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "addListener"]
        val addListener'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> listener:process_global_NodeJS_UnhandledRejectionListener -> t [@@js.call "addListener"]
        val addListener''''''': t -> event:([`L_s331_warning] [@js.enum]) -> listener:process_global_NodeJS_WarningListener -> t [@@js.call "addListener"]
        val addListener'''''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:process_global_NodeJS_MessageListener -> t [@@js.call "addListener"]
        val addListener''''''''': t -> event:process_global_NodeJS_Signals -> listener:process_global_NodeJS_SignalsListener -> t [@@js.call "addListener"]
        val addListener'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> listener:process_global_NodeJS_NewListenerListener -> t [@@js.call "addListener"]
        val addListener''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> listener:process_global_NodeJS_RemoveListenerListener -> t [@@js.call "addListener"]
        val addListener'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> listener:process_global_NodeJS_MultipleResolveListener -> t [@@js.call "addListener"]
        val emit: t -> event:([`L_s183_beforeExit] [@js.enum]) -> code:float -> bool [@@js.call "emit"]
        val emit': t -> event:([`L_s205_disconnect] [@js.enum]) -> bool [@@js.call "emit"]
        val emit'': t -> event:([`L_s214_exit] [@js.enum]) -> code:float -> bool [@@js.call "emit"]
        val emit''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> promise:any Promise.t_1 -> bool [@@js.call "emit"]
        val emit'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> error:Error.t_0 -> bool [@@js.call "emit"]
        val emit''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> error:Error.t_0 -> bool [@@js.call "emit"]
        val emit'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> reason:any -> promise:any Promise.t_1 -> bool [@@js.call "emit"]
        val emit''''''': t -> event:([`L_s331_warning] [@js.enum]) -> warning:Error.t_0 -> bool [@@js.call "emit"]
        val emit'''''''': t -> event:([`L_s251_message] [@js.enum]) -> message:any -> sendHandle:any -> t [@@js.call "emit"]
        val emit''''''''': t -> event:process_global_NodeJS_Signals -> signal:process_global_NodeJS_Signals -> bool [@@js.call "emit"]
        val emit'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> eventName:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "emit"]
        val emit''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> eventName:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "emit"]
        val emit'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> listener:process_global_NodeJS_MultipleResolveListener -> t [@@js.call "emit"]
        val on: t -> event:([`L_s183_beforeExit] [@js.enum]) -> listener:process_global_NodeJS_BeforeExitListener -> t [@@js.call "on"]
        val on': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:process_global_NodeJS_DisconnectListener -> t [@@js.call "on"]
        val on'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:process_global_NodeJS_ExitListener -> t [@@js.call "on"]
        val on''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> listener:process_global_NodeJS_RejectionHandledListener -> t [@@js.call "on"]
        val on'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "on"]
        val on''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "on"]
        val on'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> listener:process_global_NodeJS_UnhandledRejectionListener -> t [@@js.call "on"]
        val on''''''': t -> event:([`L_s331_warning] [@js.enum]) -> listener:process_global_NodeJS_WarningListener -> t [@@js.call "on"]
        val on'''''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:process_global_NodeJS_MessageListener -> t [@@js.call "on"]
        val on''''''''': t -> event:process_global_NodeJS_Signals -> listener:process_global_NodeJS_SignalsListener -> t [@@js.call "on"]
        val on'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> listener:process_global_NodeJS_NewListenerListener -> t [@@js.call "on"]
        val on''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> listener:process_global_NodeJS_RemoveListenerListener -> t [@@js.call "on"]
        val on'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> listener:process_global_NodeJS_MultipleResolveListener -> t [@@js.call "on"]
        val on''''''''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
        val once: t -> event:([`L_s183_beforeExit] [@js.enum]) -> listener:process_global_NodeJS_BeforeExitListener -> t [@@js.call "once"]
        val once': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:process_global_NodeJS_DisconnectListener -> t [@@js.call "once"]
        val once'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:process_global_NodeJS_ExitListener -> t [@@js.call "once"]
        val once''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> listener:process_global_NodeJS_RejectionHandledListener -> t [@@js.call "once"]
        val once'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "once"]
        val once''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "once"]
        val once'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> listener:process_global_NodeJS_UnhandledRejectionListener -> t [@@js.call "once"]
        val once''''''': t -> event:([`L_s331_warning] [@js.enum]) -> listener:process_global_NodeJS_WarningListener -> t [@@js.call "once"]
        val once'''''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:process_global_NodeJS_MessageListener -> t [@@js.call "once"]
        val once''''''''': t -> event:process_global_NodeJS_Signals -> listener:process_global_NodeJS_SignalsListener -> t [@@js.call "once"]
        val once'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> listener:process_global_NodeJS_NewListenerListener -> t [@@js.call "once"]
        val once''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> listener:process_global_NodeJS_RemoveListenerListener -> t [@@js.call "once"]
        val once'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> listener:process_global_NodeJS_MultipleResolveListener -> t [@@js.call "once"]
        val prependListener: t -> event:([`L_s183_beforeExit] [@js.enum]) -> listener:process_global_NodeJS_BeforeExitListener -> t [@@js.call "prependListener"]
        val prependListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:process_global_NodeJS_DisconnectListener -> t [@@js.call "prependListener"]
        val prependListener'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:process_global_NodeJS_ExitListener -> t [@@js.call "prependListener"]
        val prependListener''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> listener:process_global_NodeJS_RejectionHandledListener -> t [@@js.call "prependListener"]
        val prependListener'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "prependListener"]
        val prependListener''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "prependListener"]
        val prependListener'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> listener:process_global_NodeJS_UnhandledRejectionListener -> t [@@js.call "prependListener"]
        val prependListener''''''': t -> event:([`L_s331_warning] [@js.enum]) -> listener:process_global_NodeJS_WarningListener -> t [@@js.call "prependListener"]
        val prependListener'''''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:process_global_NodeJS_MessageListener -> t [@@js.call "prependListener"]
        val prependListener''''''''': t -> event:process_global_NodeJS_Signals -> listener:process_global_NodeJS_SignalsListener -> t [@@js.call "prependListener"]
        val prependListener'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> listener:process_global_NodeJS_NewListenerListener -> t [@@js.call "prependListener"]
        val prependListener''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> listener:process_global_NodeJS_RemoveListenerListener -> t [@@js.call "prependListener"]
        val prependListener'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> listener:process_global_NodeJS_MultipleResolveListener -> t [@@js.call "prependListener"]
        val prependOnceListener: t -> event:([`L_s183_beforeExit] [@js.enum]) -> listener:process_global_NodeJS_BeforeExitListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener': t -> event:([`L_s205_disconnect] [@js.enum]) -> listener:process_global_NodeJS_DisconnectListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener'': t -> event:([`L_s214_exit] [@js.enum]) -> listener:process_global_NodeJS_ExitListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> listener:process_global_NodeJS_RejectionHandledListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> listener:process_global_NodeJS_UncaughtExceptionListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> listener:process_global_NodeJS_UnhandledRejectionListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener''''''': t -> event:([`L_s331_warning] [@js.enum]) -> listener:process_global_NodeJS_WarningListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener'''''''': t -> event:([`L_s251_message] [@js.enum]) -> listener:process_global_NodeJS_MessageListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener''''''''': t -> event:process_global_NodeJS_Signals -> listener:process_global_NodeJS_SignalsListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> listener:process_global_NodeJS_NewListenerListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> listener:process_global_NodeJS_RemoveListenerListener -> t [@@js.call "prependOnceListener"]
        val prependOnceListener'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> listener:process_global_NodeJS_MultipleResolveListener -> t [@@js.call "prependOnceListener"]
        val listeners: t -> event:([`L_s183_beforeExit] [@js.enum]) -> process_global_NodeJS_BeforeExitListener list [@@js.call "listeners"]
        val listeners': t -> event:([`L_s205_disconnect] [@js.enum]) -> process_global_NodeJS_DisconnectListener list [@@js.call "listeners"]
        val listeners'': t -> event:([`L_s214_exit] [@js.enum]) -> process_global_NodeJS_ExitListener list [@@js.call "listeners"]
        val listeners''': t -> event:([`L_s281_rejectionHandled] [@js.enum]) -> process_global_NodeJS_RejectionHandledListener list [@@js.call "listeners"]
        val listeners'''': t -> event:([`L_s319_uncaughtException] [@js.enum]) -> process_global_NodeJS_UncaughtExceptionListener list [@@js.call "listeners"]
        val listeners''''': t -> event:([`L_s320_uncaughtExceptionMonitor] [@js.enum]) -> process_global_NodeJS_UncaughtExceptionListener list [@@js.call "listeners"]
        val listeners'''''': t -> event:([`L_s323_unhandledRejection] [@js.enum]) -> process_global_NodeJS_UnhandledRejectionListener list [@@js.call "listeners"]
        val listeners''''''': t -> event:([`L_s331_warning] [@js.enum]) -> process_global_NodeJS_WarningListener list [@@js.call "listeners"]
        val listeners'''''''': t -> event:([`L_s251_message] [@js.enum]) -> process_global_NodeJS_MessageListener list [@@js.call "listeners"]
        val listeners''''''''': t -> event:process_global_NodeJS_Signals -> process_global_NodeJS_SignalsListener list [@@js.call "listeners"]
        val listeners'''''''''': t -> event:([`L_s256_newListener] [@js.enum]) -> process_global_NodeJS_NewListenerListener list [@@js.call "listeners"]
        val listeners''''''''''': t -> event:([`L_s283_removeListener] [@js.enum]) -> process_global_NodeJS_RemoveListenerListener list [@@js.call "listeners"]
        val listeners'''''''''''': t -> event:([`L_s254_multipleResolves] [@js.enum]) -> process_global_NodeJS_MultipleResolveListener list [@@js.call "listeners"]
        val cast: t -> EventEmitter.t_0 [@@js.cast]
      end
      module[@js.scope "Global"] Global : sig
        type t = process_global_NodeJS_Global
        val t_to_js: t -> Ojs.t
        val t_of_js: Ojs.t -> t
        type t_0 = t
        val t_0_to_js: t_0 -> Ojs.t
        val t_0_of_js: Ojs.t -> t_0
        val get_process: t -> process_global_NodeJS_Process [@@js.get "process"]
        val set_process: t -> process_global_NodeJS_Process -> unit [@@js.set "process"]
      end
    end
  end
  (* CommonJsExport ({ name = [process]
    fullName = [process]
    loc = line 452, col 14 of node_modules/@types/node/process.d.ts }) *)
end
(**
  @deprecated since v7.0.0
  The version of the punycode module bundled in Node.js is being deprecated.
  In a future major version of Node.js this module will be removed.
  Users currently depending on the punycode module should switch to using
  the userland-provided Punycode.js module instead.
*)
module Node_punycode : sig
  (* export * from 'punycode'; *)
end
(**
  @deprecated since v7.0.0
  The version of the punycode module bundled in Node.js is being deprecated.
  In a future major version of Node.js this module will be removed.
  Users currently depending on the punycode module should switch to using
  the userland-provided Punycode.js module instead.
*)
module[@js.scope "punycode"] Punycode : sig
  (**
    @deprecated since v7.0.0
    The version of the punycode module bundled in Node.js is being deprecated.
    In a future major version of Node.js this module will be removed.
    Users currently depending on the punycode module should switch to using
    the userland-provided Punycode.js module instead.
  *)
  val decode: string:string -> string [@@js.global "decode"]
  (**
    @deprecated since v7.0.0
    The version of the punycode module bundled in Node.js is being deprecated.
    In a future major version of Node.js this module will be removed.
    Users currently depending on the punycode module should switch to using
    the userland-provided Punycode.js module instead.
  *)
  val encode: string:string -> string [@@js.global "encode"]
  (**
    @deprecated since v7.0.0
    The version of the punycode module bundled in Node.js is being deprecated.
    In a future major version of Node.js this module will be removed.
    Users currently depending on the punycode module should switch to using
    the userland-provided Punycode.js module instead.
  *)
  val toUnicode: domain:string -> string [@@js.global "toUnicode"]
  (**
    @deprecated since v7.0.0
    The version of the punycode module bundled in Node.js is being deprecated.
    In a future major version of Node.js this module will be removed.
    Users currently depending on the punycode module should switch to using
    the userland-provided Punycode.js module instead.
  *)
  val toASCII: domain:string -> string [@@js.global "toASCII"]
  (**
    @deprecated since v7.0.0
    The version of the punycode module bundled in Node.js is being deprecated.
    In a future major version of Node.js this module will be removed.
    Users currently depending on the punycode module should switch to using
    the userland-provided Punycode.js module instead.
  *)
  val ucs2: punycode_ucs2 [@@js.global "ucs2"]
  module[@js.scope "ucs2"] Ucs2 : sig
    type t = punycode_ucs2
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      @deprecated since v7.0.0
      The version of the punycode module bundled in Node.js is being deprecated.
      In a future major version of Node.js this module will be removed.
      Users currently depending on the punycode module should switch to using
      the userland-provided Punycode.js module instead.
    *)
    val decode: t -> string:string -> float list [@@js.call "decode"]
    (**
      @deprecated since v7.0.0
      The version of the punycode module bundled in Node.js is being deprecated.
      In a future major version of Node.js this module will be removed.
      Users currently depending on the punycode module should switch to using
      the userland-provided Punycode.js module instead.
    *)
    val encode: t -> codePoints:float list -> string [@@js.call "encode"]
  end
  (**
    @deprecated since v7.0.0
    The version of the punycode module bundled in Node.js is being deprecated.
    In a future major version of Node.js this module will be removed.
    Users currently depending on the punycode module should switch to using
    the userland-provided Punycode.js module instead.
  *)
  val version: string [@@js.global "version"]
end
module Node_querystring : sig
  (* export * from 'querystring'; *)
end
module[@js.scope "querystring"] Querystring : sig
  module[@js.scope "StringifyOptions"] StringifyOptions : sig
    type t = querystring_StringifyOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val encodeURIComponent: t -> str:string -> string [@@js.call "encodeURIComponent"]
  end
  module[@js.scope "ParseOptions"] ParseOptions : sig
    type t = querystring_ParseOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_maxKeys: t -> float [@@js.get "maxKeys"]
    val set_maxKeys: t -> float -> unit [@@js.set "maxKeys"]
    val decodeURIComponent: t -> str:string -> string [@@js.call "decodeURIComponent"]
  end
  module[@js.scope "ParsedUrlQuery"] ParsedUrlQuery : sig
    type t = querystring_ParsedUrlQuery
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> string list or_string _NodeJS_Dict [@@js.cast]
  end
  module[@js.scope "ParsedUrlQueryInput"] ParsedUrlQueryInput : sig
    type t = querystring_ParsedUrlQueryInput
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> (string list, bool list, float list) union3 or_boolean or_string or_number or_null _NodeJS_Dict [@@js.cast]
  end
  val stringify: ?obj:querystring_ParsedUrlQueryInput -> ?sep:string -> ?eq:string -> ?options:querystring_StringifyOptions -> unit -> string [@@js.global "stringify"]
  val parse: str:string -> ?sep:string -> ?eq:string -> ?options:querystring_ParseOptions -> unit -> querystring_ParsedUrlQuery [@@js.global "parse"]
  (** The querystring.encode() function is an alias for querystring.stringify(). *)
  val encode: ?obj:querystring_ParsedUrlQueryInput -> ?sep:string -> ?eq:string -> ?options:querystring_StringifyOptions -> unit -> string [@@js.global "encode"]
  (** The querystring.decode() function is an alias for querystring.parse(). *)
  val decode: str:string -> ?sep:string -> ?eq:string -> ?options:querystring_ParseOptions -> unit -> querystring_ParsedUrlQuery [@@js.global "decode"]
  val escape: str:string -> string [@@js.global "escape"]
  val unescape: str:string -> string [@@js.global "unescape"]
end
module Node_readline : sig
  (* export * from 'readline'; *)
end
module[@js.scope "readline"] Readline : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/readline.d.ts } *)
  module[@js.scope "Key"] Key : sig
    type t = readline_Key
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_sequence: t -> string [@@js.get "sequence"]
    val set_sequence: t -> string -> unit [@@js.set "sequence"]
    val get_name: t -> string [@@js.get "name"]
    val set_name: t -> string -> unit [@@js.set "name"]
    val get_ctrl: t -> bool [@@js.get "ctrl"]
    val set_ctrl: t -> bool -> unit [@@js.set "ctrl"]
    val get_meta: t -> bool [@@js.get "meta"]
    val set_meta: t -> bool -> unit [@@js.set "meta"]
    val get_shift: t -> bool [@@js.get "shift"]
    val set_shift: t -> bool -> unit [@@js.set "shift"]
  end
  module[@js.scope "Interface"] Interface : sig
    type t = readline_Interface
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_terminal: t -> bool [@@js.get "terminal"]
    (** The current input data *)
    val get_line: t -> string [@@js.get "line"]
    (** The current cursor position in the input line *)
    val get_cursor: t -> float [@@js.get "cursor"]
    (**
      NOTE: According to the documentation:
      
      > Instances of the `readline.Interface` class are constructed using the
      > `readline.createInterface()` method.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
    *)
    val create: input:_NodeJS_ReadableStream -> ?output:_NodeJS_WritableStream -> ?completer:(readline_AsyncCompleter, readline_Completer) union2 -> ?terminal:bool -> unit -> t [@@js.create]
    (**
      NOTE: According to the documentation:
      
      > Instances of the `readline.Interface` class are constructed using the
      > `readline.createInterface()` method.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
    *)
    val create': options:readline_ReadLineOptions -> t [@@js.create]
    val setPrompt: t -> prompt:string -> unit [@@js.call "setPrompt"]
    val prompt: t -> ?preserveCursor:bool -> unit -> unit [@@js.call "prompt"]
    val question: t -> query:string -> callback:(answer:string -> unit) -> unit [@@js.call "question"]
    val pause: t -> t [@@js.call "pause"]
    val resume: t -> t [@@js.call "resume"]
    val close: t -> unit [@@js.call "close"]
    val write: t -> data:_Buffer or_string -> ?key:readline_Key -> unit -> unit [@@js.call "write"]
    (**
      Returns the real position of the cursor in relation to the input
      prompt + string.  Long input (wrapping) strings, as well as multiple
      line prompts are included in the calculations.
    *)
    val getCursorPos: t -> readline_CursorPos [@@js.call "getCursorPos"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s244_line] [@js.enum]) -> input:string -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s268_pause] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s290_resume] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val _Symbol_asyncIterator_: t -> string AsyncIterableIterator.t_1 [@@js.call "[Symbol.asyncIterator]"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module ReadLine : sig
    type t = readline_ReadLine
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "Completer"] Completer : sig
    type t = readline_Completer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> line:string -> readline_CompleterResult [@@js.apply]
  end
  module[@js.scope "AsyncCompleter"] AsyncCompleter : sig
    type t = readline_AsyncCompleter
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> line:string -> callback:(?err:Error.t_0 or_null -> ?result:readline_CompleterResult -> unit -> unit) -> any [@@js.apply]
  end
  module CompleterResult : sig
    type t = readline_CompleterResult
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "ReadLineOptions"] ReadLineOptions : sig
    type t = readline_ReadLineOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_input: t -> _NodeJS_ReadableStream [@@js.get "input"]
    val set_input: t -> _NodeJS_ReadableStream -> unit [@@js.set "input"]
    val get_output: t -> _NodeJS_WritableStream [@@js.get "output"]
    val set_output: t -> _NodeJS_WritableStream -> unit [@@js.set "output"]
    val get_completer: t -> (readline_AsyncCompleter, readline_Completer) union2 [@@js.get "completer"]
    val set_completer: t -> (readline_AsyncCompleter, readline_Completer) union2 -> unit [@@js.set "completer"]
    val get_terminal: t -> bool [@@js.get "terminal"]
    val set_terminal: t -> bool -> unit [@@js.set "terminal"]
    val get_historySize: t -> float [@@js.get "historySize"]
    val set_historySize: t -> float -> unit [@@js.set "historySize"]
    val get_prompt: t -> string [@@js.get "prompt"]
    val set_prompt: t -> string -> unit [@@js.set "prompt"]
    val get_crlfDelay: t -> float [@@js.get "crlfDelay"]
    val set_crlfDelay: t -> float -> unit [@@js.set "crlfDelay"]
    val get_removeHistoryDuplicates: t -> bool [@@js.get "removeHistoryDuplicates"]
    val set_removeHistoryDuplicates: t -> bool -> unit [@@js.set "removeHistoryDuplicates"]
    val get_escapeCodeTimeout: t -> float [@@js.get "escapeCodeTimeout"]
    val set_escapeCodeTimeout: t -> float -> unit [@@js.set "escapeCodeTimeout"]
    val get_tabSize: t -> float [@@js.get "tabSize"]
    val set_tabSize: t -> float -> unit [@@js.set "tabSize"]
  end
  val createInterface: input:_NodeJS_ReadableStream -> ?output:_NodeJS_WritableStream -> ?completer:(readline_AsyncCompleter, readline_Completer) union2 -> ?terminal:bool -> unit -> readline_Interface [@@js.global "createInterface"]
  val createInterface: options:readline_ReadLineOptions -> readline_Interface [@@js.global "createInterface"]
  val emitKeypressEvents: stream:_NodeJS_ReadableStream -> ?readlineInterface:readline_Interface -> unit -> unit [@@js.global "emitKeypressEvents"]
  module Direction : sig
    type t = readline_Direction
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "CursorPos"] CursorPos : sig
    type t = readline_CursorPos
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_rows: t -> float [@@js.get "rows"]
    val set_rows: t -> float -> unit [@@js.set "rows"]
    val get_cols: t -> float [@@js.get "cols"]
    val set_cols: t -> float -> unit [@@js.set "cols"]
  end
  (** Clears the current line of this WriteStream in a direction identified by `dir`. *)
  val clearLine: stream:_NodeJS_WritableStream -> dir:readline_Direction -> ?callback:(unit -> unit) -> unit -> bool [@@js.global "clearLine"]
  (** Clears this `WriteStream` from the current cursor down. *)
  val clearScreenDown: stream:_NodeJS_WritableStream -> ?callback:(unit -> unit) -> unit -> bool [@@js.global "clearScreenDown"]
  (** Moves this WriteStream's cursor to the specified position. *)
  val cursorTo: stream:_NodeJS_WritableStream -> x:float -> ?y:float -> ?callback:(unit -> unit) -> unit -> bool [@@js.global "cursorTo"]
  (** Moves this WriteStream's cursor relative to its current position. *)
  val moveCursor: stream:_NodeJS_WritableStream -> dx:float -> dy:float -> ?callback:(unit -> unit) -> unit -> bool [@@js.global "moveCursor"]
end
module Node_repl : sig
  (* export * from 'repl'; *)
end
module[@js.scope "repl"] Repl : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:readline
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/repl.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:vm
    clause = ES6Import ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/repl.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:util
    clause = ES6Import ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/repl.d.ts } *)
  module[@js.scope "ReplOptions"] ReplOptions : sig
    type t = repl_ReplOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      The input prompt to display.
      Default: `"> "`
    *)
    (**
      The input prompt to display.
      Default: `"> "`
    *)
    val get_prompt: t -> string [@@js.get "prompt"]
    (**
      The input prompt to display.
      Default: `"> "`
    *)
    val set_prompt: t -> string -> unit [@@js.set "prompt"]
    (**
      The `Readable` stream from which REPL input will be read.
      Default: `process.stdin`
    *)
    (**
      The `Readable` stream from which REPL input will be read.
      Default: `process.stdin`
    *)
    val get_input: t -> _NodeJS_ReadableStream [@@js.get "input"]
    (**
      The `Readable` stream from which REPL input will be read.
      Default: `process.stdin`
    *)
    val set_input: t -> _NodeJS_ReadableStream -> unit [@@js.set "input"]
    (**
      The `Writable` stream to which REPL output will be written.
      Default: `process.stdout`
    *)
    (**
      The `Writable` stream to which REPL output will be written.
      Default: `process.stdout`
    *)
    val get_output: t -> _NodeJS_WritableStream [@@js.get "output"]
    (**
      The `Writable` stream to which REPL output will be written.
      Default: `process.stdout`
    *)
    val set_output: t -> _NodeJS_WritableStream -> unit [@@js.set "output"]
    (**
      If `true`, specifies that the output should be treated as a TTY terminal, and have
      ANSI/VT100 escape codes written to it.
      Default: checking the value of the `isTTY` property on the output stream upon
      instantiation.
    *)
    (**
      If `true`, specifies that the output should be treated as a TTY terminal, and have
      ANSI/VT100 escape codes written to it.
      Default: checking the value of the `isTTY` property on the output stream upon
      instantiation.
    *)
    val get_terminal: t -> bool [@@js.get "terminal"]
    (**
      If `true`, specifies that the output should be treated as a TTY terminal, and have
      ANSI/VT100 escape codes written to it.
      Default: checking the value of the `isTTY` property on the output stream upon
      instantiation.
    *)
    val set_terminal: t -> bool -> unit [@@js.set "terminal"]
    (**
      The function to be used when evaluating each given line of input.
      Default: an async wrapper for the JavaScript `eval()` function. An `eval` function can
      error with `repl.Recoverable` to indicate the input was incomplete and prompt for
      additional lines.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_default_evaluation
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_custom_evaluation_functions
    *)
    (**
      The function to be used when evaluating each given line of input.
      Default: an async wrapper for the JavaScript `eval()` function. An `eval` function can
      error with `repl.Recoverable` to indicate the input was incomplete and prompt for
      additional lines.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_default_evaluation
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_custom_evaluation_functions
    *)
    val get_eval: t -> repl_REPLEval [@@js.get "eval"]
    (**
      The function to be used when evaluating each given line of input.
      Default: an async wrapper for the JavaScript `eval()` function. An `eval` function can
      error with `repl.Recoverable` to indicate the input was incomplete and prompt for
      additional lines.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_default_evaluation
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_custom_evaluation_functions
    *)
    val set_eval: t -> repl_REPLEval -> unit [@@js.set "eval"]
    (**
      Defines if the repl prints output previews or not.
      default: `true` Always `false` in case `terminal` is falsy.
    *)
    (**
      Defines if the repl prints output previews or not.
      default: `true` Always `false` in case `terminal` is falsy.
    *)
    val get_preview: t -> bool [@@js.get "preview"]
    (**
      Defines if the repl prints output previews or not.
      default: `true` Always `false` in case `terminal` is falsy.
    *)
    val set_preview: t -> bool -> unit [@@js.set "preview"]
    (**
      If `true`, specifies that the default `writer` function should include ANSI color
      styling to REPL output. If a custom `writer` function is provided then this has no
      effect.
      Default: the REPL instance's `terminal` value.
    *)
    (**
      If `true`, specifies that the default `writer` function should include ANSI color
      styling to REPL output. If a custom `writer` function is provided then this has no
      effect.
      Default: the REPL instance's `terminal` value.
    *)
    val get_useColors: t -> bool [@@js.get "useColors"]
    (**
      If `true`, specifies that the default `writer` function should include ANSI color
      styling to REPL output. If a custom `writer` function is provided then this has no
      effect.
      Default: the REPL instance's `terminal` value.
    *)
    val set_useColors: t -> bool -> unit [@@js.set "useColors"]
    (**
      If `true`, specifies that the default evaluation function will use the JavaScript
      `global` as the context as opposed to creating a new separate context for the REPL
      instance. The node CLI REPL sets this value to `true`.
      Default: `false`.
    *)
    (**
      If `true`, specifies that the default evaluation function will use the JavaScript
      `global` as the context as opposed to creating a new separate context for the REPL
      instance. The node CLI REPL sets this value to `true`.
      Default: `false`.
    *)
    val get_useGlobal: t -> bool [@@js.get "useGlobal"]
    (**
      If `true`, specifies that the default evaluation function will use the JavaScript
      `global` as the context as opposed to creating a new separate context for the REPL
      instance. The node CLI REPL sets this value to `true`.
      Default: `false`.
    *)
    val set_useGlobal: t -> bool -> unit [@@js.set "useGlobal"]
    (**
      If `true`, specifies that the default writer will not output the return value of a
      command if it evaluates to `undefined`.
      Default: `false`.
    *)
    (**
      If `true`, specifies that the default writer will not output the return value of a
      command if it evaluates to `undefined`.
      Default: `false`.
    *)
    val get_ignoreUndefined: t -> bool [@@js.get "ignoreUndefined"]
    (**
      If `true`, specifies that the default writer will not output the return value of a
      command if it evaluates to `undefined`.
      Default: `false`.
    *)
    val set_ignoreUndefined: t -> bool -> unit [@@js.set "ignoreUndefined"]
    (**
      The function to invoke to format the output of each command before writing to `output`.
      Default: a wrapper for `util.inspect`.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_customizing_repl_output
    *)
    (**
      The function to invoke to format the output of each command before writing to `output`.
      Default: a wrapper for `util.inspect`.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_customizing_repl_output
    *)
    val get_writer: t -> repl_REPLWriter [@@js.get "writer"]
    (**
      The function to invoke to format the output of each command before writing to `output`.
      Default: a wrapper for `util.inspect`.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_customizing_repl_output
    *)
    val set_writer: t -> repl_REPLWriter -> unit [@@js.set "writer"]
    (**
      An optional function used for custom Tab auto completion.
      @see "https" ://nodejs.org/dist/latest-v11.x/docs/api/readline.html#readline_use_of_the_completer_function
    *)
    (**
      An optional function used for custom Tab auto completion.
      @see "https" ://nodejs.org/dist/latest-v11.x/docs/api/readline.html#readline_use_of_the_completer_function
    *)
    val get_completer: t -> (AsyncCompleter.t_0, Completer.t_0) union2 [@@js.get "completer"]
    (**
      An optional function used for custom Tab auto completion.
      @see "https" ://nodejs.org/dist/latest-v11.x/docs/api/readline.html#readline_use_of_the_completer_function
    *)
    val set_completer: t -> (AsyncCompleter.t_0, Completer.t_0) union2 -> unit [@@js.set "completer"]
    (**
      A flag that specifies whether the default evaluator executes all JavaScript commands in
      strict mode or default (sloppy) mode.
      Accepted values are:
      - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
      - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
        prefacing every repl statement with `'use strict'`.
    *)
    (**
      A flag that specifies whether the default evaluator executes all JavaScript commands in
      strict mode or default (sloppy) mode.
      Accepted values are:
      - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
      - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
        prefacing every repl statement with `'use strict'`.
    *)
    val get_replMode: t -> (* FIXME: unknown type 'unique symbol' *)any [@@js.get "replMode"]
    (**
      A flag that specifies whether the default evaluator executes all JavaScript commands in
      strict mode or default (sloppy) mode.
      Accepted values are:
      - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
      - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
        prefacing every repl statement with `'use strict'`.
    *)
    val set_replMode: t -> (* FIXME: unknown type 'unique symbol' *)any -> unit [@@js.set "replMode"]
    (**
      Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is
      pressed. This cannot be used together with a custom `eval` function.
      Default: `false`.
    *)
    (**
      Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is
      pressed. This cannot be used together with a custom `eval` function.
      Default: `false`.
    *)
    val get_breakEvalOnSigint: t -> bool [@@js.get "breakEvalOnSigint"]
    (**
      Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is
      pressed. This cannot be used together with a custom `eval` function.
      Default: `false`.
    *)
    val set_breakEvalOnSigint: t -> bool -> unit [@@js.set "breakEvalOnSigint"]
  end
  module[@js.scope "REPLEval"] REPLEval : sig
    type t = repl_REPLEval
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> this:repl_REPLServer -> evalCmd:string -> context:Context.t_0 -> file:string -> cb:(err:Error.t_0 or_null -> result:any -> unit) -> unit [@@js.apply]
  end
  module[@js.scope "REPLWriter"] REPLWriter : sig
    type t = repl_REPLWriter
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> this:repl_REPLServer -> obj:any -> string [@@js.apply]
  end
  (**
    This is the default "writer" value, if none is passed in the REPL options,
    and it can be overridden by custom print functions.
  *)
  val writer: (repl_REPLWriter, anonymous_interface_35) intersection2 [@@js.global "writer"]
  module[@js.scope "REPLCommandAction"] REPLCommandAction : sig
    type t = repl_REPLCommandAction
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> this:repl_REPLServer -> text:string -> unit [@@js.apply]
  end
  module[@js.scope "REPLCommand"] REPLCommand : sig
    type t = repl_REPLCommand
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Help text to be displayed when `.help` is entered. *)
    (** Help text to be displayed when `.help` is entered. *)
    val get_help: t -> string [@@js.get "help"]
    (** Help text to be displayed when `.help` is entered. *)
    val set_help: t -> string -> unit [@@js.set "help"]
    (** The function to execute, optionally accepting a single string argument. *)
    (** The function to execute, optionally accepting a single string argument. *)
    val get_action: t -> repl_REPLCommandAction [@@js.get "action"]
    (** The function to execute, optionally accepting a single string argument. *)
    val set_action: t -> repl_REPLCommandAction -> unit [@@js.set "action"]
  end
  (**
    Provides a customizable Read-Eval-Print-Loop (REPL).
    
    Instances of `repl.REPLServer` will accept individual lines of user input, evaluate those
    according to a user-defined evaluation function, then output the result. Input and output
    may be from `stdin` and `stdout`, respectively, or may be connected to any Node.js `stream`.
    
    Instances of `repl.REPLServer` support automatic completion of inputs, simplistic Emacs-style
    line editing, multi-line inputs, ANSI-styled output, saving and restoring current REPL session
    state, error recovery, and customizable evaluation functions.
    
    Instances of `repl.REPLServer` are created using the `repl.start()` method and _should not_
    be created directly using the JavaScript `new` keyword.
    @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_repl
  *)
  module[@js.scope "REPLServer"] REPLServer : sig
    type t = repl_REPLServer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      The `vm.Context` provided to the `eval` function to be used for JavaScript
      evaluation.
    *)
    val get_context: t -> Context.t_0 [@@js.get "context"]
    (** @deprecated since v14.3.0 - Use `input` instead. *)
    val get_inputStream: t -> _NodeJS_ReadableStream [@@js.get "inputStream"]
    (** @deprecated since v14.3.0 - Use `output` instead. *)
    val get_outputStream: t -> _NodeJS_WritableStream [@@js.get "outputStream"]
    (** The `Readable` stream from which REPL input will be read. *)
    val get_input: t -> _NodeJS_ReadableStream [@@js.get "input"]
    (** The `Writable` stream to which REPL output will be written. *)
    val get_output: t -> _NodeJS_WritableStream [@@js.get "output"]
    (** The commands registered via `replServer.defineCommand()`. *)
    val get_commands: t -> repl_REPLCommand _NodeJS_ReadOnlyDict [@@js.get "commands"]
    (**
      A value indicating whether the REPL is currently in "editor mode".
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_commands_and_special_keys
    *)
    val get_editorMode: t -> bool [@@js.get "editorMode"]
    (**
      A value indicating whether the `_` variable has been assigned.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
    *)
    val get_underscoreAssigned: t -> bool [@@js.get "underscoreAssigned"]
    (**
      The last evaluation result from the REPL (assigned to the `_` variable inside of the REPL).
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
    *)
    val get_last: t -> any [@@js.get "last"]
    (**
      A value indicating whether the `_error` variable has been assigned.
      @since v9.8.0
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
    *)
    val get_underscoreErrAssigned: t -> bool [@@js.get "underscoreErrAssigned"]
    (**
      The last error raised inside the REPL (assigned to the `_error` variable inside of the REPL).
      @since v9.8.0
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
    *)
    val get_lastError: t -> any [@@js.get "lastError"]
    (**
      Specified in the REPL options, this is the function to be used when evaluating each
      given line of input. If not specified in the REPL options, this is an async wrapper
      for the JavaScript `eval()` function.
    *)
    val get_eval: t -> repl_REPLEval [@@js.get "eval"]
    (**
      Specified in the REPL options, this is a value indicating whether the default
      `writer` function should include ANSI color styling to REPL output.
    *)
    val get_useColors: t -> bool [@@js.get "useColors"]
    (**
      Specified in the REPL options, this is a value indicating whether the default `eval`
      function will use the JavaScript `global` as the context as opposed to creating a new
      separate context for the REPL instance.
    *)
    val get_useGlobal: t -> bool [@@js.get "useGlobal"]
    (**
      Specified in the REPL options, this is a value indicating whether the default `writer`
      function should output the result of a command if it evaluates to `undefined`.
    *)
    val get_ignoreUndefined: t -> bool [@@js.get "ignoreUndefined"]
    (**
      Specified in the REPL options, this is the function to invoke to format the output of
      each command before writing to `outputStream`. If not specified in the REPL options,
      this will be a wrapper for `util.inspect`.
    *)
    val get_writer: t -> repl_REPLWriter [@@js.get "writer"]
    (** Specified in the REPL options, this is the function to use for custom Tab auto-completion. *)
    val get_completer: t -> (AsyncCompleter.t_0, Completer.t_0) union2 [@@js.get "completer"]
    (**
      Specified in the REPL options, this is a flag that specifies whether the default `eval`
      function should execute all JavaScript commands in strict mode or default (sloppy) mode.
      Possible values are:
      - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
      - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
         prefacing every repl statement with `'use strict'`.
    *)
    val get_replMode: t -> (* FIXME: unknown type 'unique symbol' *)any [@@js.get "replMode"]
    (**
      NOTE: According to the documentation:
      
      > Instances of `repl.REPLServer` are created using the `repl.start()` method and
      > _should not_ be created directly using the JavaScript `new` keyword.
      
      `REPLServer` cannot be subclassed due to implementation specifics in NodeJS.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_class_replserver
    *)
    val create: unit -> t [@@js.create]
    (**
      Used to add new `.`-prefixed commands to the REPL instance. Such commands are invoked
      by typing a `.` followed by the `keyword`.
      @param keyword The command keyword (_without_ a leading `.` character).
      @param cmd The function to invoke when the command is processed.
      @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_replserver_definecommand_keyword_cmd
    *)
    val defineCommand: t -> keyword:string -> cmd:(repl_REPLCommand, repl_REPLCommandAction) union2 -> unit [@@js.call "defineCommand"]
    (**
      Readies the REPL instance for input from the user, printing the configured `prompt` to a
      new line in the `output` and resuming the `input` to accept new input.
      
      When multi-line input is being entered, an ellipsis is printed rather than the 'prompt'.
      
      This method is primarily intended to be called from within the action function for
      commands registered using the `replServer.defineCommand()` method.
      @param preserveCursor When `true`, the cursor placement will not be reset to `0`.
    *)
    val displayPrompt: t -> ?preserveCursor:bool -> unit -> unit [@@js.call "displayPrompt"]
    (**
      Clears any command that has been buffered but not yet executed.
      
      This method is primarily intended to be called from within the action function for
      commands registered using the `replServer.defineCommand()` method.
      @since v9.0.0
    *)
    val clearBufferedCommand: t -> unit [@@js.call "clearBufferedCommand"]
    (**
      Initializes a history log file for the REPL instance. When executing the
      Node.js binary and using the command line REPL, a history file is initialized
      by default. However, this is not the case when creating a REPL
      programmatically. Use this method to initialize a history log file when working
      with REPL instances programmatically.
      @param path The path to the history file
    *)
    val setupHistory: t -> path:string -> cb:(err:Error.t_0 or_null -> repl:t -> unit) -> unit [@@js.call "setupHistory"]
    (**
      events.EventEmitter
      1. close - inherited from `readline.Interface`
      2. line - inherited from `readline.Interface`
      3. pause - inherited from `readline.Interface`
      4. resume - inherited from `readline.Interface`
      5. SIGCONT - inherited from `readline.Interface`
      6. SIGINT - inherited from `readline.Interface`
      7. SIGTSTP - inherited from `readline.Interface`
      8. exit
      9. reset
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener'''''''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
      1. close
      2. line
      3. pause
      4. resume
      5. SIGCONT
      6. SIGINT
      7. SIGTSTP
    *)
    val addListener''''''''': t -> event:([`L_s286_reset] [@js.enum]) -> listener:(context:Context.t_0 -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s244_line] [@js.enum]) -> input:string -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s268_pause] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s290_resume] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> bool [@@js.call "emit"]
    val emit'''''''': t -> event:([`L_s214_exit] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''''''': t -> event:([`L_s286_reset] [@js.enum]) -> context:Context.t_0 -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on'''''''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''''''': t -> event:([`L_s286_reset] [@js.enum]) -> listener:(context:Context.t_0 -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once'''''''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''''''': t -> event:([`L_s286_reset] [@js.enum]) -> listener:(context:Context.t_0 -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''''''': t -> event:([`L_s286_reset] [@js.enum]) -> listener:(context:Context.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s244_line] [@js.enum]) -> listener:(input:string -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s126_SIGCONT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s131_SIGINT] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''': t -> event:([`L_s147_SIGTSTP] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''''': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''''''': t -> event:([`L_s286_reset] [@js.enum]) -> listener:(context:Context.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> Interface.t_0 [@@js.cast]
  end
  (** A flag passed in the REPL options. Evaluates expressions in sloppy mode. *)
  val repl_mode_sloppy: (* FIXME: unknown type 'unique symbol' *)any [@@js.global "REPL_MODE_SLOPPY"]
  (**
    A flag passed in the REPL options. Evaluates expressions in strict mode.
    This is equivalent to prefacing every repl statement with `'use strict'`.
  *)
  val repl_mode_strict: (* FIXME: unknown type 'unique symbol' *)any [@@js.global "REPL_MODE_STRICT"]
  (**
    Creates and starts a `repl.REPLServer` instance.
    @param options The options for the `REPLServer`. If `options` is a string, then it specifies
    the input prompt.
  *)
  val start: ?options:repl_ReplOptions or_string -> unit -> repl_REPLServer [@@js.global "start"]
  (**
    Indicates a recoverable error that a `REPLServer` can use to support multi-line input.
    @see "https" ://nodejs.org/dist/latest-v10.x/docs/api/repl.html#repl_recoverable_errors
  *)
  module[@js.scope "Recoverable"] Recoverable : sig
    type t = repl_Recoverable
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_err: t -> Error.t_0 [@@js.get "err"]
    val set_err: t -> Error.t_0 -> unit [@@js.set "err"]
    val create: err:Error.t_0 -> t [@@js.create]
    val cast: t -> SyntaxError.t_0 [@@js.cast]
  end
end
module Node_stream : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = stream
    clause = NamespaceImport ([object Object])
    loc = line 2, col 5 of node_modules/@types/node/stream.d.ts } *)
  (* CommonJsExport ({ name = [Stream]
    fullName = undefined
    loc = line 3, col 14 of node_modules/@types/node/stream.d.ts }) *)
end
module[@js.scope "stream"] Stream : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/stream.d.ts } *)
  module[@js.scope "internal"] Internal : sig
    type t = stream_internal
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val pipe: t -> destination:'T -> ?options:anonymous_interface_20 -> unit -> 'T [@@js.call "pipe"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "internal"] Internal : sig
    module[@js.scope "Stream"] Stream : sig
      type t = stream_internal_Stream
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val create: ?opts:stream_internal_ReadableOptions -> unit -> t [@@js.create]
      val cast: t -> stream_internal [@@js.cast]
    end
    module[@js.scope "ReadableOptions"] ReadableOptions : sig
      type t = stream_internal_ReadableOptions
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_highWaterMark: t -> float [@@js.get "highWaterMark"]
      val set_highWaterMark: t -> float -> unit [@@js.set "highWaterMark"]
      val get_encoding: t -> _BufferEncoding [@@js.get "encoding"]
      val set_encoding: t -> _BufferEncoding -> unit [@@js.set "encoding"]
      val get_objectMode: t -> bool [@@js.get "objectMode"]
      val set_objectMode: t -> bool -> unit [@@js.set "objectMode"]
      val read: t -> this:stream_internal_Readable -> size:float -> unit [@@js.call "read"]
      val destroy: t -> this:stream_internal_Readable -> error:Error.t_0 or_null -> callback:(error:Error.t_0 or_null -> unit) -> unit [@@js.call "destroy"]
      val get_autoDestroy: t -> bool [@@js.get "autoDestroy"]
      val set_autoDestroy: t -> bool -> unit [@@js.set "autoDestroy"]
    end
    module[@js.scope "Readable"] Readable : sig
      type t = stream_internal_Readable
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      (** A utility method for creating Readable Streams out of iterators. *)
      val from: iterable:(any AsyncIterable.t_1, any Iterable.t_1) union2 -> ?options:stream_internal_ReadableOptions -> unit -> t [@@js.global "from"]
      val get_readable: t -> bool [@@js.get "readable"]
      val set_readable: t -> bool -> unit [@@js.set "readable"]
      val get_readableEncoding: t -> _BufferEncoding or_null [@@js.get "readableEncoding"]
      val get_readableEnded: t -> bool [@@js.get "readableEnded"]
      val get_readableFlowing: t -> bool or_null [@@js.get "readableFlowing"]
      val get_readableHighWaterMark: t -> float [@@js.get "readableHighWaterMark"]
      val get_readableLength: t -> float [@@js.get "readableLength"]
      val get_readableObjectMode: t -> bool [@@js.get "readableObjectMode"]
      val get_destroyed: t -> bool [@@js.get "destroyed"]
      val set_destroyed: t -> bool -> unit [@@js.set "destroyed"]
      val create: ?opts:stream_internal_ReadableOptions -> unit -> t [@@js.create]
      val _read: t -> size:float -> unit [@@js.call "_read"]
      val read: t -> ?size:float -> unit -> any [@@js.call "read"]
      val setEncoding: t -> encoding:_BufferEncoding -> t [@@js.call "setEncoding"]
      val pause: t -> t [@@js.call "pause"]
      val resume: t -> t [@@js.call "resume"]
      val isPaused: t -> bool [@@js.call "isPaused"]
      val unpipe: t -> ?destination:_NodeJS_WritableStream -> unit -> t [@@js.call "unpipe"]
      val unshift: t -> chunk:any -> ?encoding:_BufferEncoding -> unit -> unit [@@js.call "unshift"]
      val wrap: t -> oldStream:_NodeJS_ReadableStream -> t [@@js.call "wrap"]
      val push: t -> chunk:any -> ?encoding:_BufferEncoding -> unit -> bool [@@js.call "push"]
      val _destroy: t -> error:Error.t_0 or_null -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_destroy"]
      val destroy: t -> ?error:Error.t_0 -> unit -> unit [@@js.call "destroy"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:any -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener'''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener'''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. data
        3. end
        4. error
        5. pause
        6. readable
        7. resume
      *)
      val addListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
      val emit: t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
      val emit': t -> event:([`L_s198_data] [@js.enum]) -> chunk:any -> bool [@@js.call "emit"]
      val emit'': t -> event:([`L_s211_end] [@js.enum]) -> bool [@@js.call "emit"]
      val emit''': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
      val emit'''': t -> event:([`L_s268_pause] [@js.enum]) -> bool [@@js.call "emit"]
      val emit''''': t -> event:([`L_s277_readable] [@js.enum]) -> bool [@@js.call "emit"]
      val emit'''''': t -> event:([`L_s290_resume] [@js.enum]) -> bool [@@js.call "emit"]
      val emit''''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
      val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:any -> unit) -> t [@@js.call "on"]
      val on'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
      val on'''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on'''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
      val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:any -> unit) -> t [@@js.call "once"]
      val once'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
      val once'''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once'''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
      val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:any -> unit) -> t [@@js.call "prependListener"]
      val prependListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
      val prependListener'''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener'''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
      val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:any -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener'''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener'''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
      val removeListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener': t -> event:([`L_s198_data] [@js.enum]) -> listener:(chunk:any -> unit) -> t [@@js.call "removeListener"]
      val removeListener'': t -> event:([`L_s211_end] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener''': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "removeListener"]
      val removeListener'''': t -> event:([`L_s268_pause] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener''''': t -> event:([`L_s277_readable] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener'''''': t -> event:([`L_s290_resume] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener''''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "removeListener"]
      val _Symbol_asyncIterator_: t -> any AsyncIterableIterator.t_1 [@@js.call "[Symbol.asyncIterator]"]
      val cast: t -> stream_internal_Stream [@@js.cast]
      val cast': t -> _NodeJS_ReadableStream [@@js.cast]
    end
    module[@js.scope "WritableOptions"] WritableOptions : sig
      type t = stream_internal_WritableOptions
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_highWaterMark: t -> float [@@js.get "highWaterMark"]
      val set_highWaterMark: t -> float -> unit [@@js.set "highWaterMark"]
      val get_decodeStrings: t -> bool [@@js.get "decodeStrings"]
      val set_decodeStrings: t -> bool -> unit [@@js.set "decodeStrings"]
      val get_defaultEncoding: t -> _BufferEncoding [@@js.get "defaultEncoding"]
      val set_defaultEncoding: t -> _BufferEncoding -> unit [@@js.set "defaultEncoding"]
      val get_objectMode: t -> bool [@@js.get "objectMode"]
      val set_objectMode: t -> bool -> unit [@@js.set "objectMode"]
      val get_emitClose: t -> bool [@@js.get "emitClose"]
      val set_emitClose: t -> bool -> unit [@@js.set "emitClose"]
      val write: t -> this:stream_internal_Writable -> chunk:any -> encoding:_BufferEncoding -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "write"]
      val writev: t -> this:stream_internal_Writable -> chunks:anonymous_interface_9 list -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "writev"]
      val destroy: t -> this:stream_internal_Writable -> error:Error.t_0 or_null -> callback:(error:Error.t_0 or_null -> unit) -> unit [@@js.call "destroy"]
      val final: t -> this:stream_internal_Writable -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "final"]
      val get_autoDestroy: t -> bool [@@js.get "autoDestroy"]
      val set_autoDestroy: t -> bool -> unit [@@js.set "autoDestroy"]
    end
    module[@js.scope "Writable"] Writable : sig
      type t = stream_internal_Writable
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_writable: t -> bool [@@js.get "writable"]
      val get_writableEnded: t -> bool [@@js.get "writableEnded"]
      val get_writableFinished: t -> bool [@@js.get "writableFinished"]
      val get_writableHighWaterMark: t -> float [@@js.get "writableHighWaterMark"]
      val get_writableLength: t -> float [@@js.get "writableLength"]
      val get_writableObjectMode: t -> bool [@@js.get "writableObjectMode"]
      val get_writableCorked: t -> float [@@js.get "writableCorked"]
      val get_destroyed: t -> bool [@@js.get "destroyed"]
      val set_destroyed: t -> bool -> unit [@@js.set "destroyed"]
      val create: ?opts:stream_internal_WritableOptions -> unit -> t [@@js.create]
      val _write: t -> chunk:any -> encoding:_BufferEncoding -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_write"]
      val _writev: t -> chunks:anonymous_interface_9 list -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_writev"]
      val _destroy: t -> error:Error.t_0 or_null -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_destroy"]
      val _final: t -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_final"]
      val write: t -> chunk:any -> ?cb:(error:Error.t_0 or_null_or_undefined -> unit) -> unit -> bool [@@js.call "write"]
      val write': t -> chunk:any -> encoding:_BufferEncoding -> ?cb:(error:Error.t_0 or_null_or_undefined -> unit) -> unit -> bool [@@js.call "write"]
      val setDefaultEncoding: t -> encoding:_BufferEncoding -> t [@@js.call "setDefaultEncoding"]
      val end_: t -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
      val end_': t -> chunk:any -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
      val end_'': t -> chunk:any -> encoding:_BufferEncoding -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
      val cork: t -> unit [@@js.call "cork"]
      val uncork: t -> unit [@@js.call "uncork"]
      val destroy: t -> ?error:Error.t_0 -> unit -> unit [@@js.call "destroy"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "addListener"]
      (**
        Event emitter
        The defined events on documents including:
        1. close
        2. drain
        3. error
        4. finish
        5. pipe
        6. unpipe
      *)
      val addListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
      val emit: t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
      val emit': t -> event:([`L_s206_drain] [@js.enum]) -> bool [@@js.call "emit"]
      val emit'': t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
      val emit''': t -> event:([`L_s217_finish] [@js.enum]) -> bool [@@js.call "emit"]
      val emit'''': t -> event:([`L_s271_pipe] [@js.enum]) -> src:stream_internal_Readable -> bool [@@js.call "emit"]
      val emit''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> src:stream_internal_Readable -> bool [@@js.call "emit"]
      val emit'''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
      val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
      val on''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
      val on'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "on"]
      val on''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "on"]
      val on'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
      val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
      val once''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
      val once'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "once"]
      val once''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "once"]
      val once'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
      val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
      val prependListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
      val prependListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "prependListener"]
      val prependListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "prependListener"]
      val prependListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
      val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "prependOnceListener"]
      val prependOnceListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
      val removeListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener': t -> event:([`L_s206_drain] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener'': t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "removeListener"]
      val removeListener''': t -> event:([`L_s217_finish] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
      val removeListener'''': t -> event:([`L_s271_pipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "removeListener"]
      val removeListener''''': t -> event:([`L_s325_unpipe] [@js.enum]) -> listener:(src:stream_internal_Readable -> unit) -> t [@@js.call "removeListener"]
      val removeListener'''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "removeListener"]
      val cast: t -> stream_internal_Stream [@@js.cast]
      val cast': t -> _NodeJS_WritableStream [@@js.cast]
    end
    module[@js.scope "DuplexOptions"] DuplexOptions : sig
      type t = stream_internal_DuplexOptions
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_allowHalfOpen: t -> bool [@@js.get "allowHalfOpen"]
      val set_allowHalfOpen: t -> bool -> unit [@@js.set "allowHalfOpen"]
      val get_readableObjectMode: t -> bool [@@js.get "readableObjectMode"]
      val set_readableObjectMode: t -> bool -> unit [@@js.set "readableObjectMode"]
      val get_writableObjectMode: t -> bool [@@js.get "writableObjectMode"]
      val set_writableObjectMode: t -> bool -> unit [@@js.set "writableObjectMode"]
      val get_readableHighWaterMark: t -> float [@@js.get "readableHighWaterMark"]
      val set_readableHighWaterMark: t -> float -> unit [@@js.set "readableHighWaterMark"]
      val get_writableHighWaterMark: t -> float [@@js.get "writableHighWaterMark"]
      val set_writableHighWaterMark: t -> float -> unit [@@js.set "writableHighWaterMark"]
      val get_writableCorked: t -> float [@@js.get "writableCorked"]
      val set_writableCorked: t -> float -> unit [@@js.set "writableCorked"]
      val read: t -> this:stream_internal_Duplex -> size:float -> unit [@@js.call "read"]
      val write: t -> this:stream_internal_Duplex -> chunk:any -> encoding:_BufferEncoding -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "write"]
      val writev: t -> this:stream_internal_Duplex -> chunks:anonymous_interface_9 list -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "writev"]
      val final: t -> this:stream_internal_Duplex -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "final"]
      val destroy: t -> this:stream_internal_Duplex -> error:Error.t_0 or_null -> callback:(error:Error.t_0 or_null -> unit) -> unit [@@js.call "destroy"]
      val cast: t -> stream_internal_ReadableOptions [@@js.cast]
      val cast': t -> stream_internal_WritableOptions [@@js.cast]
    end
    module[@js.scope "Duplex"] Duplex : sig
      type t = stream_internal_Duplex
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_writable: t -> bool [@@js.get "writable"]
      val get_writableEnded: t -> bool [@@js.get "writableEnded"]
      val get_writableFinished: t -> bool [@@js.get "writableFinished"]
      val get_writableHighWaterMark: t -> float [@@js.get "writableHighWaterMark"]
      val get_writableLength: t -> float [@@js.get "writableLength"]
      val get_writableObjectMode: t -> bool [@@js.get "writableObjectMode"]
      val get_writableCorked: t -> float [@@js.get "writableCorked"]
      val create: ?opts:stream_internal_DuplexOptions -> unit -> t [@@js.create]
      val _write: t -> chunk:any -> encoding:_BufferEncoding -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_write"]
      val _writev: t -> chunks:anonymous_interface_9 list -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_writev"]
      val _destroy: t -> error:Error.t_0 or_null -> callback:(error:Error.t_0 or_null -> unit) -> unit [@@js.call "_destroy"]
      val _final: t -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "_final"]
      val write: t -> chunk:any -> ?encoding:_BufferEncoding -> ?cb:(error:Error.t_0 or_null_or_undefined -> unit) -> unit -> bool [@@js.call "write"]
      val write': t -> chunk:any -> ?cb:(error:Error.t_0 or_null_or_undefined -> unit) -> unit -> bool [@@js.call "write"]
      val setDefaultEncoding: t -> encoding:_BufferEncoding -> t [@@js.call "setDefaultEncoding"]
      val end_: t -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
      val end_': t -> chunk:any -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
      val end_'': t -> chunk:any -> ?encoding:_BufferEncoding -> ?cb:(unit -> unit) -> unit -> unit [@@js.call "end"]
      val cork: t -> unit [@@js.call "cork"]
      val uncork: t -> unit [@@js.call "uncork"]
      val cast: t -> stream_internal_Readable [@@js.cast]
      val cast': t -> stream_internal_Writable [@@js.cast]
    end
    module[@js.scope "TransformCallback"] TransformCallback : sig
      type t = stream_internal_TransformCallback
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val apply: t -> ?error:Error.t_0 or_null -> ?data:any -> unit -> unit [@@js.apply]
    end
    module[@js.scope "TransformOptions"] TransformOptions : sig
      type t = stream_internal_TransformOptions
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val read: t -> this:stream_internal_Transform -> size:float -> unit [@@js.call "read"]
      val write: t -> this:stream_internal_Transform -> chunk:any -> encoding:_BufferEncoding -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "write"]
      val writev: t -> this:stream_internal_Transform -> chunks:anonymous_interface_9 list -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "writev"]
      val final: t -> this:stream_internal_Transform -> callback:(?error:Error.t_0 or_null -> unit -> unit) -> unit [@@js.call "final"]
      val destroy: t -> this:stream_internal_Transform -> error:Error.t_0 or_null -> callback:(error:Error.t_0 or_null -> unit) -> unit [@@js.call "destroy"]
      val transform: t -> this:stream_internal_Transform -> chunk:any -> encoding:_BufferEncoding -> callback:stream_internal_TransformCallback -> unit [@@js.call "transform"]
      val flush: t -> this:stream_internal_Transform -> callback:stream_internal_TransformCallback -> unit [@@js.call "flush"]
      val cast: t -> stream_internal_DuplexOptions [@@js.cast]
    end
    module[@js.scope "Transform"] Transform : sig
      type t = stream_internal_Transform
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val create: ?opts:stream_internal_TransformOptions -> unit -> t [@@js.create]
      val _transform: t -> chunk:any -> encoding:_BufferEncoding -> callback:stream_internal_TransformCallback -> unit [@@js.call "_transform"]
      val _flush: t -> callback:stream_internal_TransformCallback -> unit [@@js.call "_flush"]
      val cast: t -> stream_internal_Duplex [@@js.cast]
    end
    module[@js.scope "PassThrough"] PassThrough : sig
      type t = stream_internal_PassThrough
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val cast: t -> stream_internal_Transform [@@js.cast]
    end
    module[@js.scope "FinishedOptions"] FinishedOptions : sig
      type t = stream_internal_FinishedOptions
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val get_error: t -> bool [@@js.get "error"]
      val set_error: t -> bool -> unit [@@js.set "error"]
      val get_readable: t -> bool [@@js.get "readable"]
      val set_readable: t -> bool -> unit [@@js.set "readable"]
      val get_writable: t -> bool [@@js.get "writable"]
      val set_writable: t -> bool -> unit [@@js.set "writable"]
    end
    val finished: stream:(_NodeJS_ReadWriteStream, _NodeJS_ReadableStream, _NodeJS_WritableStream) union3 -> options:stream_internal_FinishedOptions -> callback:(?err:_NodeJS_ErrnoException or_null -> unit -> unit) -> (unit -> unit [@js.dummy]) [@@js.global "finished"]
    val finished: stream:(_NodeJS_ReadWriteStream, _NodeJS_ReadableStream, _NodeJS_WritableStream) union3 -> callback:(?err:_NodeJS_ErrnoException or_null -> unit -> unit) -> (unit -> unit [@js.dummy]) [@@js.global "finished"]
    module[@js.scope "finished"] Finished : sig
      val __promisify__: stream:(_NodeJS_ReadWriteStream, _NodeJS_ReadableStream, _NodeJS_WritableStream) union3 -> ?options:stream_internal_FinishedOptions -> unit -> unit Promise.t_1 [@@js.global "__promisify__"]
    end
    module[@js.scope "PipelineSourceFunction"] PipelineSourceFunction : sig
      type 'T t = 'T stream_internal_PipelineSourceFunction
      val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
      val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
      type 'T t_1 = 'T t
      val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
      val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
      val apply: 'T t -> ('T AsyncIterable.t_1, 'T Iterable.t_1) union2 [@@js.apply]
    end
    module PipelineSource : sig
      type 'T t = 'T stream_internal_PipelineSource
      val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
      val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
      type 'T t_1 = 'T t
      val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
      val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    end
    module PipelineTransform : sig
      type ('S, 'U) t = ('S, 'U) stream_internal_PipelineTransform
      val t_to_js: ('S -> Ojs.t) -> ('U -> Ojs.t) -> ('S, 'U) t -> Ojs.t
      val t_of_js: (Ojs.t -> 'S) -> (Ojs.t -> 'U) -> Ojs.t -> ('S, 'U) t
      type ('S, 'U) t_2 = ('S, 'U) t
      val t_2_to_js: ('S -> Ojs.t) -> ('U -> Ojs.t) -> ('S, 'U) t_2 -> Ojs.t
      val t_2_of_js: (Ojs.t -> 'S) -> (Ojs.t -> 'U) -> Ojs.t -> ('S, 'U) t_2
    end
    module PipelineTransformSource : sig
      type 'T t = 'T stream_internal_PipelineTransformSource
      val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
      val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
      type 'T t_1 = 'T t
      val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
      val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
    end
    module[@js.scope "PipelineDestinationIterableFunction"] PipelineDestinationIterableFunction : sig
      type 'T t = 'T stream_internal_PipelineDestinationIterableFunction
      val t_to_js: ('T -> Ojs.t) -> 'T t -> Ojs.t
      val t_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t
      type 'T t_1 = 'T t
      val t_1_to_js: ('T -> Ojs.t) -> 'T t_1 -> Ojs.t
      val t_1_of_js: (Ojs.t -> 'T) -> Ojs.t -> 'T t_1
      val apply: 'T t -> source:'T AsyncIterable.t_1 -> any AsyncIterable.t_1 [@@js.apply]
    end
    module[@js.scope "PipelineDestinationPromiseFunction"] PipelineDestinationPromiseFunction : sig
      type ('T, 'P) t = ('T, 'P) stream_internal_PipelineDestinationPromiseFunction
      val t_to_js: ('T -> Ojs.t) -> ('P -> Ojs.t) -> ('T, 'P) t -> Ojs.t
      val t_of_js: (Ojs.t -> 'T) -> (Ojs.t -> 'P) -> Ojs.t -> ('T, 'P) t
      type ('T, 'P) t_2 = ('T, 'P) t
      val t_2_to_js: ('T -> Ojs.t) -> ('P -> Ojs.t) -> ('T, 'P) t_2 -> Ojs.t
      val t_2_of_js: (Ojs.t -> 'T) -> (Ojs.t -> 'P) -> Ojs.t -> ('T, 'P) t_2
      val apply: ('T, 'P) t -> source:'T AsyncIterable.t_1 -> 'P Promise.t_1 [@@js.apply]
    end
    module PipelineDestination : sig
      type ('S, 'P) t = ('S, 'P) stream_internal_PipelineDestination
      val t_to_js: ('S -> Ojs.t) -> ('P -> Ojs.t) -> ('S, 'P) t -> Ojs.t
      val t_of_js: (Ojs.t -> 'S) -> (Ojs.t -> 'P) -> Ojs.t -> ('S, 'P) t
      type ('S, 'P) t_2 = ('S, 'P) t
      val t_2_to_js: ('S -> Ojs.t) -> ('P -> Ojs.t) -> ('S, 'P) t_2 -> Ojs.t
      val t_2_of_js: (Ojs.t -> 'S) -> (Ojs.t -> 'P) -> Ojs.t -> ('S, 'P) t_2
    end
    module PipelineCallback : sig
      type 'S t = 'S stream_internal_PipelineCallback
      val t_to_js: ('S -> Ojs.t) -> 'S t -> Ojs.t
      val t_of_js: (Ojs.t -> 'S) -> Ojs.t -> 'S t
      type 'S t_1 = 'S t
      val t_1_to_js: ('S -> Ojs.t) -> 'S t_1 -> Ojs.t
      val t_1_of_js: (Ojs.t -> 'S) -> Ojs.t -> 'S t_1
    end
    module PipelinePromise : sig
      type 'S t = 'S stream_internal_PipelinePromise
      val t_to_js: ('S -> Ojs.t) -> 'S t -> Ojs.t
      val t_of_js: (Ojs.t -> 'S) -> Ojs.t -> 'S t
      type 'S t_1 = 'S t
      val t_1_to_js: ('S -> Ojs.t) -> 'S t_1 -> Ojs.t
      val t_1_of_js: (Ojs.t -> 'S) -> Ojs.t -> 'S t_1
    end
    val pipeline: source:'A -> destination:'B -> ?callback:'B stream_internal_PipelineCallback -> unit -> (* FIXME: unknown type 'B extends NodeJS.WritableStream ? B : NodeJS.WritableStream' *)any [@@js.global "pipeline"]
    val pipeline: source:'A -> transform1:'T1 -> destination:'B -> ?callback:'B stream_internal_PipelineCallback -> unit -> (* FIXME: unknown type 'B extends NodeJS.WritableStream ? B : NodeJS.WritableStream' *)any [@@js.global "pipeline"]
    val pipeline: source:'A -> transform1:'T1 -> transform2:'T2 -> destination:'B -> ?callback:'B stream_internal_PipelineCallback -> unit -> (* FIXME: unknown type 'B extends NodeJS.WritableStream ? B : NodeJS.WritableStream' *)any [@@js.global "pipeline"]
    val pipeline: source:'A -> transform1:'T1 -> transform2:'T2 -> transform3:'T3 -> destination:'B -> ?callback:'B stream_internal_PipelineCallback -> unit -> (* FIXME: unknown type 'B extends NodeJS.WritableStream ? B : NodeJS.WritableStream' *)any [@@js.global "pipeline"]
    val pipeline: source:'A -> transform1:'T1 -> transform2:'T2 -> transform3:'T3 -> transform4:'T4 -> destination:'B -> ?callback:'B stream_internal_PipelineCallback -> unit -> (* FIXME: unknown type 'B extends NodeJS.WritableStream ? B : NodeJS.WritableStream' *)any [@@js.global "pipeline"]
    val pipeline: streams:(_NodeJS_ReadWriteStream, _NodeJS_ReadableStream, _NodeJS_WritableStream) union3 list -> ?callback:(err:_NodeJS_ErrnoException or_null -> unit) -> unit -> _NodeJS_WritableStream [@@js.global "pipeline"]
    val pipeline: stream1:_NodeJS_ReadableStream -> stream2:(_NodeJS_ReadWriteStream, _NodeJS_WritableStream) union2 -> streams:((* FIXME: type 'Array<union<NodeJS.ReadWriteStream | NodeJS.WritableStream | (~err:union<NodeJS.ErrnoException | Null> -> Void)>>' cannot be used for variadic argument *)any list [@js.variadic]) -> _NodeJS_WritableStream [@@js.global "pipeline"]
    module[@js.scope "pipeline"] Pipeline : sig
      val __promisify__: source:'A -> destination:'B -> 'B stream_internal_PipelinePromise [@@js.global "__promisify__"]
      val __promisify__: source:'A -> transform1:'T1 -> destination:'B -> 'B stream_internal_PipelinePromise [@@js.global "__promisify__"]
      val __promisify__: source:'A -> transform1:'T1 -> transform2:'T2 -> destination:'B -> 'B stream_internal_PipelinePromise [@@js.global "__promisify__"]
      val __promisify__: source:'A -> transform1:'T1 -> transform2:'T2 -> transform3:'T3 -> destination:'B -> 'B stream_internal_PipelinePromise [@@js.global "__promisify__"]
      val __promisify__: source:'A -> transform1:'T1 -> transform2:'T2 -> transform3:'T3 -> transform4:'T4 -> destination:'B -> 'B stream_internal_PipelinePromise [@@js.global "__promisify__"]
      val __promisify__: streams:(_NodeJS_ReadWriteStream, _NodeJS_ReadableStream, _NodeJS_WritableStream) union3 list -> unit Promise.t_1 [@@js.global "__promisify__"]
      val __promisify__: stream1:_NodeJS_ReadableStream -> stream2:(_NodeJS_ReadWriteStream, _NodeJS_WritableStream) union2 -> streams:((* FIXME: type 'Array<union<NodeJS.ReadWriteStream | NodeJS.WritableStream>>' cannot be used for variadic argument *)any list [@js.variadic]) -> unit Promise.t_1 [@@js.global "__promisify__"]
    end
    module[@js.scope "Pipe"] Pipe : sig
      type t = stream_internal_Pipe
      val t_to_js: t -> Ojs.t
      val t_of_js: Ojs.t -> t
      type t_0 = t
      val t_0_to_js: t_0 -> Ojs.t
      val t_0_of_js: Ojs.t -> t_0
      val close: t -> unit [@@js.call "close"]
      val hasRef: t -> bool [@@js.call "hasRef"]
      val ref: t -> unit [@@js.call "ref"]
      val unref: t -> unit [@@js.call "unref"]
    end
  end
  (* CommonJsExport ({ name = [internal]
    fullName = [stream; internal]
    loc = line 447, col 14 of node_modules/@types/node/stream.d.ts }) *)
end
module Node_string_decoder : sig
  (* export * from 'string_decoder'; *)
end
module[@js.scope "string_decoder"] String_decoder : sig
  module[@js.scope "StringDecoder"] StringDecoder : sig
    type t = string_decoder_StringDecoder
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?encoding:_BufferEncoding -> unit -> t [@@js.create]
    val write: t -> buffer:_Buffer -> string [@@js.call "write"]
    val end_: t -> ?buffer:_Buffer -> unit -> string [@@js.call "end"]
  end
end
module Node_timers : sig
  (* export * from 'timers'; *)
end
module[@js.scope "timers"] Timers : sig
  val setTimeout: callback:(args:(any list [@js.variadic]) -> unit) -> ?ms:float -> args:(any list [@js.variadic]) -> _NodeJS_Timeout [@@js.global "setTimeout"]
  module[@js.scope "setTimeout"] SetTimeout : sig
    val __promisify__: ms:float -> unit Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: ms:float -> value:'T -> 'T Promise.t_1 [@@js.global "__promisify__"]
  end
  val clearTimeout: timeoutId:_NodeJS_Timeout -> unit [@@js.global "clearTimeout"]
  val setInterval: callback:(args:(any list [@js.variadic]) -> unit) -> ?ms:float -> args:(any list [@js.variadic]) -> _NodeJS_Timeout [@@js.global "setInterval"]
  val clearInterval: intervalId:_NodeJS_Timeout -> unit [@@js.global "clearInterval"]
  val setImmediate: callback:(args:(any list [@js.variadic]) -> unit) -> args:(any list [@js.variadic]) -> _NodeJS_Immediate [@@js.global "setImmediate"]
  module[@js.scope "setImmediate"] SetImmediate : sig
    val __promisify__: unit -> unit Promise.t_1 [@@js.global "__promisify__"]
    val __promisify__: value:'T -> 'T Promise.t_1 [@@js.global "__promisify__"]
  end
  val clearImmediate: immediateId:_NodeJS_Immediate -> unit [@@js.global "clearImmediate"]
end
module Node_tls : sig
  (* export * from 'tls'; *)
end
module[@js.scope "tls"] Tls : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/tls.d.ts } *)
  val client_reneg_limit: float [@@js.global "CLIENT_RENEG_LIMIT"]
  val client_reneg_window: float [@@js.global "CLIENT_RENEG_WINDOW"]
  module[@js.scope "Certificate"] Certificate : sig
    type t = tls_Certificate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Country code. *)
    (** Country code. *)
    val get_C: t -> string [@@js.get "C"]
    (** Country code. *)
    val set_C: t -> string -> unit [@@js.set "C"]
    (** Street. *)
    (** Street. *)
    val get_ST: t -> string [@@js.get "ST"]
    (** Street. *)
    val set_ST: t -> string -> unit [@@js.set "ST"]
    (** Locality. *)
    (** Locality. *)
    val get_L: t -> string [@@js.get "L"]
    (** Locality. *)
    val set_L: t -> string -> unit [@@js.set "L"]
    (** Organization. *)
    (** Organization. *)
    val get_O: t -> string [@@js.get "O"]
    (** Organization. *)
    val set_O: t -> string -> unit [@@js.set "O"]
    (** Organizational unit. *)
    (** Organizational unit. *)
    val get_OU: t -> string [@@js.get "OU"]
    (** Organizational unit. *)
    val set_OU: t -> string -> unit [@@js.set "OU"]
    (** Common name. *)
    (** Common name. *)
    val get_CN: t -> string [@@js.get "CN"]
    (** Common name. *)
    val set_CN: t -> string -> unit [@@js.set "CN"]
  end
  module[@js.scope "PeerCertificate"] PeerCertificate : sig
    type t = tls_PeerCertificate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_subject: t -> tls_Certificate [@@js.get "subject"]
    val set_subject: t -> tls_Certificate -> unit [@@js.set "subject"]
    val get_issuer: t -> tls_Certificate [@@js.get "issuer"]
    val set_issuer: t -> tls_Certificate -> unit [@@js.set "issuer"]
    val get_subjectaltname: t -> string [@@js.get "subjectaltname"]
    val set_subjectaltname: t -> string -> unit [@@js.set "subjectaltname"]
    val get_infoAccess: t -> string list _NodeJS_Dict [@@js.get "infoAccess"]
    val set_infoAccess: t -> string list _NodeJS_Dict -> unit [@@js.set "infoAccess"]
    val get_modulus: t -> string [@@js.get "modulus"]
    val set_modulus: t -> string -> unit [@@js.set "modulus"]
    val get_exponent: t -> string [@@js.get "exponent"]
    val set_exponent: t -> string -> unit [@@js.set "exponent"]
    val get_valid_from: t -> string [@@js.get "valid_from"]
    val set_valid_from: t -> string -> unit [@@js.set "valid_from"]
    val get_valid_to: t -> string [@@js.get "valid_to"]
    val set_valid_to: t -> string -> unit [@@js.set "valid_to"]
    val get_fingerprint: t -> string [@@js.get "fingerprint"]
    val set_fingerprint: t -> string -> unit [@@js.set "fingerprint"]
    val get_fingerprint256: t -> string [@@js.get "fingerprint256"]
    val set_fingerprint256: t -> string -> unit [@@js.set "fingerprint256"]
    val get_ext_key_usage: t -> string list [@@js.get "ext_key_usage"]
    val set_ext_key_usage: t -> string list -> unit [@@js.set "ext_key_usage"]
    val get_serialNumber: t -> string [@@js.get "serialNumber"]
    val set_serialNumber: t -> string -> unit [@@js.set "serialNumber"]
    val get_raw: t -> _Buffer [@@js.get "raw"]
    val set_raw: t -> _Buffer -> unit [@@js.set "raw"]
  end
  module[@js.scope "DetailedPeerCertificate"] DetailedPeerCertificate : sig
    type t = tls_DetailedPeerCertificate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_issuerCertificate: t -> t [@@js.get "issuerCertificate"]
    val set_issuerCertificate: t -> t -> unit [@@js.set "issuerCertificate"]
    val cast: t -> tls_PeerCertificate [@@js.cast]
  end
  module[@js.scope "CipherNameAndProtocol"] CipherNameAndProtocol : sig
    type t = tls_CipherNameAndProtocol
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** The cipher name. *)
    (** The cipher name. *)
    val get_name: t -> string [@@js.get "name"]
    (** The cipher name. *)
    val set_name: t -> string -> unit [@@js.set "name"]
    (** SSL/TLS protocol version. *)
    (** SSL/TLS protocol version. *)
    val get_version: t -> string [@@js.get "version"]
    (** SSL/TLS protocol version. *)
    val set_version: t -> string -> unit [@@js.set "version"]
    (** IETF name for the cipher suite. *)
    (** IETF name for the cipher suite. *)
    val get_standardName: t -> string [@@js.get "standardName"]
    (** IETF name for the cipher suite. *)
    val set_standardName: t -> string -> unit [@@js.set "standardName"]
  end
  module[@js.scope "EphemeralKeyInfo"] EphemeralKeyInfo : sig
    type t = tls_EphemeralKeyInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** The supported types are 'DH' and 'ECDH'. *)
    (** The supported types are 'DH' and 'ECDH'. *)
    val get_type: t -> string [@@js.get "type"]
    (** The supported types are 'DH' and 'ECDH'. *)
    val set_type: t -> string -> unit [@@js.set "type"]
    (** The name property is available only when type is 'ECDH'. *)
    (** The name property is available only when type is 'ECDH'. *)
    val get_name: t -> string [@@js.get "name"]
    (** The name property is available only when type is 'ECDH'. *)
    val set_name: t -> string -> unit [@@js.set "name"]
    (** The size of parameter of an ephemeral key exchange. *)
    (** The size of parameter of an ephemeral key exchange. *)
    val get_size: t -> float [@@js.get "size"]
    (** The size of parameter of an ephemeral key exchange. *)
    val set_size: t -> float -> unit [@@js.set "size"]
  end
  module[@js.scope "KeyObject"] KeyObject : sig
    type t = tls_KeyObject
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Private keys in PEM format. *)
    (** Private keys in PEM format. *)
    val get_pem: t -> _Buffer or_string [@@js.get "pem"]
    (** Private keys in PEM format. *)
    val set_pem: t -> _Buffer or_string -> unit [@@js.set "pem"]
    (** Optional passphrase. *)
    (** Optional passphrase. *)
    val get_passphrase: t -> string [@@js.get "passphrase"]
    (** Optional passphrase. *)
    val set_passphrase: t -> string -> unit [@@js.set "passphrase"]
  end
  module[@js.scope "PxfObject"] PxfObject : sig
    type t = tls_PxfObject
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** PFX or PKCS12 encoded private key and certificate chain. *)
    (** PFX or PKCS12 encoded private key and certificate chain. *)
    val get_buf: t -> _Buffer or_string [@@js.get "buf"]
    (** PFX or PKCS12 encoded private key and certificate chain. *)
    val set_buf: t -> _Buffer or_string -> unit [@@js.set "buf"]
    (** Optional passphrase. *)
    (** Optional passphrase. *)
    val get_passphrase: t -> string [@@js.get "passphrase"]
    (** Optional passphrase. *)
    val set_passphrase: t -> string -> unit [@@js.set "passphrase"]
  end
  module[@js.scope "TLSSocketOptions"] TLSSocketOptions : sig
    type t = tls_TLSSocketOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      If true the TLS socket will be instantiated in server-mode.
      Defaults to false.
    *)
    (**
      If true the TLS socket will be instantiated in server-mode.
      Defaults to false.
    *)
    val get_isServer: t -> bool [@@js.get "isServer"]
    (**
      If true the TLS socket will be instantiated in server-mode.
      Defaults to false.
    *)
    val set_isServer: t -> bool -> unit [@@js.set "isServer"]
    (** An optional net.Server instance. *)
    (** An optional net.Server instance. *)
    val get_server: t -> net_Server [@@js.get "server"]
    (** An optional net.Server instance. *)
    val set_server: t -> net_Server -> unit [@@js.set "server"]
    (** An optional Buffer instance containing a TLS session. *)
    (** An optional Buffer instance containing a TLS session. *)
    val get_session: t -> _Buffer [@@js.get "session"]
    (** An optional Buffer instance containing a TLS session. *)
    val set_session: t -> _Buffer -> unit [@@js.set "session"]
    (**
      If true, specifies that the OCSP status request extension will be
      added to the client hello and an 'OCSPResponse' event will be
      emitted on the socket before establishing a secure communication
    *)
    (**
      If true, specifies that the OCSP status request extension will be
      added to the client hello and an 'OCSPResponse' event will be
      emitted on the socket before establishing a secure communication
    *)
    val get_requestOCSP: t -> bool [@@js.get "requestOCSP"]
    (**
      If true, specifies that the OCSP status request extension will be
      added to the client hello and an 'OCSPResponse' event will be
      emitted on the socket before establishing a secure communication
    *)
    val set_requestOCSP: t -> bool -> unit [@@js.set "requestOCSP"]
    val cast: t -> tls_SecureContextOptions [@@js.cast]
    val cast': t -> tls_CommonConnectionOptions [@@js.cast]
  end
  module[@js.scope "TLSSocket"] TLSSocket : sig
    type t = tls_TLSSocket
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Construct a new tls.TLSSocket object from an existing TCP socket. *)
    val create: socket:net_Socket -> ?options:tls_TLSSocketOptions -> unit -> t [@@js.create]
    (** A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false. *)
    (** A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false. *)
    val get_authorized: t -> bool [@@js.get "authorized"]
    (** A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false. *)
    val set_authorized: t -> bool -> unit [@@js.set "authorized"]
    (**
      The reason why the peer's certificate has not been verified.
      This property becomes available only when tlsSocket.authorized === false.
    *)
    (**
      The reason why the peer's certificate has not been verified.
      This property becomes available only when tlsSocket.authorized === false.
    *)
    val get_authorizationError: t -> Error.t_0 [@@js.get "authorizationError"]
    (**
      The reason why the peer's certificate has not been verified.
      This property becomes available only when tlsSocket.authorized === false.
    *)
    val set_authorizationError: t -> Error.t_0 -> unit [@@js.set "authorizationError"]
    (**
      Static boolean value, always true.
      May be used to distinguish TLS sockets from regular ones.
    *)
    (**
      Static boolean value, always true.
      May be used to distinguish TLS sockets from regular ones.
    *)
    val get_encrypted: t -> bool [@@js.get "encrypted"]
    (**
      Static boolean value, always true.
      May be used to distinguish TLS sockets from regular ones.
    *)
    val set_encrypted: t -> bool -> unit [@@js.set "encrypted"]
    (**
      String containing the selected ALPN protocol.
      When ALPN has no selected protocol, tlsSocket.alpnProtocol equals false.
    *)
    (**
      String containing the selected ALPN protocol.
      When ALPN has no selected protocol, tlsSocket.alpnProtocol equals false.
    *)
    val get_alpnProtocol: t -> string [@@js.get "alpnProtocol"]
    (**
      String containing the selected ALPN protocol.
      When ALPN has no selected protocol, tlsSocket.alpnProtocol equals false.
    *)
    val set_alpnProtocol: t -> string -> unit [@@js.set "alpnProtocol"]
    (**
      Returns an object representing the local certificate. The returned
      object has some properties corresponding to the fields of the
      certificate.
      
      See tls.TLSSocket.getPeerCertificate() for an example of the
      certificate structure.
      
      If there is no local certificate, an empty object will be returned.
      If the socket has been destroyed, null will be returned.
    *)
    val getCertificate: t -> (tls_PeerCertificate, untyped_object) union2 or_null [@@js.call "getCertificate"]
    (**
      Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection.
      @return Returns an object representing the cipher name
      and the SSL/TLS protocol version of the current connection.
    *)
    val getCipher: t -> tls_CipherNameAndProtocol [@@js.call "getCipher"]
    (**
      Returns an object representing the type, name, and size of parameter
      of an ephemeral key exchange in Perfect Forward Secrecy on a client
      connection. It returns an empty object when the key exchange is not
      ephemeral. As this is only supported on a client socket; null is
      returned if called on a server socket. The supported types are 'DH'
      and 'ECDH'. The name property is available only when type is 'ECDH'.
      
      For example: \{ type: 'ECDH', name: 'prime256v1', size: 256 \}.
    *)
    val getEphemeralKeyInfo: t -> (tls_EphemeralKeyInfo, untyped_object) union2 or_null [@@js.call "getEphemeralKeyInfo"]
    (**
      Returns the latest Finished message that has
      been sent to the socket as part of a SSL/TLS handshake, or undefined
      if no Finished message has been sent yet.
      
      As the Finished messages are message digests of the complete
      handshake (with a total of 192 bits for TLS 1.0 and more for SSL
      3.0), they can be used for external authentication procedures when
      the authentication provided by SSL/TLS is not desired or is not
      enough.
      
      Corresponds to the SSL_get_finished routine in OpenSSL and may be
      used to implement the tls-unique channel binding from RFC 5929.
    *)
    val getFinished: t -> _Buffer or_undefined [@@js.call "getFinished"]
    (**
      Returns an object representing the peer's certificate.
      The returned object has some properties corresponding to the field of the certificate.
      If detailed argument is true the full chain with issuer property will be returned,
      if false only the top certificate without issuer property.
      If the peer does not provide a certificate, it returns null or an empty object.
      @param detailed - If true; the full chain with issuer property will be returned.
      @return An object representing the peer's certificate.
    *)
    val getPeerCertificate: t -> detailed:([`L_b_true] [@js.enum]) -> tls_DetailedPeerCertificate [@@js.call "getPeerCertificate"]
    (**
      Returns an object representing the peer's certificate.
      The returned object has some properties corresponding to the field of the certificate.
      If detailed argument is true the full chain with issuer property will be returned,
      if false only the top certificate without issuer property.
      If the peer does not provide a certificate, it returns null or an empty object.
    *)
    val getPeerCertificate': t -> ?detailed:([`L_b_false] [@js.enum]) -> unit -> tls_PeerCertificate [@@js.call "getPeerCertificate"]
    (**
      Returns an object representing the peer's certificate.
      The returned object has some properties corresponding to the field of the certificate.
      If detailed argument is true the full chain with issuer property will be returned,
      if false only the top certificate without issuer property.
      If the peer does not provide a certificate, it returns null or an empty object.
    *)
    val getPeerCertificate'': t -> ?detailed:bool -> unit -> (tls_DetailedPeerCertificate, tls_PeerCertificate) union2 [@@js.call "getPeerCertificate"]
    (**
      Returns the latest Finished message that is expected or has actually
      been received from the socket as part of a SSL/TLS handshake, or
      undefined if there is no Finished message so far.
      
      As the Finished messages are message digests of the complete
      handshake (with a total of 192 bits for TLS 1.0 and more for SSL
      3.0), they can be used for external authentication procedures when
      the authentication provided by SSL/TLS is not desired or is not
      enough.
      
      Corresponds to the SSL_get_peer_finished routine in OpenSSL and may
      be used to implement the tls-unique channel binding from RFC 5929.
    *)
    val getPeerFinished: t -> _Buffer or_undefined [@@js.call "getPeerFinished"]
    (**
      Returns a string containing the negotiated SSL/TLS protocol version of the current connection.
      The value `'unknown'` will be returned for connected sockets that have not completed the handshaking process.
      The value `null` will be returned for server sockets or disconnected client sockets.
      See https://www.openssl.org/docs/man1.0.2/ssl/SSL_get_version.html for more information.
      @return negotiated SSL/TLS protocol version of the current connection
    *)
    val getProtocol: t -> string or_null [@@js.call "getProtocol"]
    (**
      Could be used to speed up handshake establishment when reconnecting to the server.
      @return ASN.1 encoded TLS session or undefined if none was negotiated.
    *)
    val getSession: t -> _Buffer or_undefined [@@js.call "getSession"]
    (**
      Returns a list of signature algorithms shared between the server and
      the client in the order of decreasing preference.
    *)
    val getSharedSigalgs: t -> string list [@@js.call "getSharedSigalgs"]
    (**
      NOTE: Works only with client TLS sockets.
      Useful only for debugging, for session reuse provide session option to tls.connect().
      @return TLS session ticket or undefined if none was negotiated.
    *)
    val getTLSTicket: t -> _Buffer or_undefined [@@js.call "getTLSTicket"]
    (** Returns true if the session was reused, false otherwise. *)
    val isSessionReused: t -> bool [@@js.call "isSessionReused"]
    (**
      Initiate TLS renegotiation process.
      
      NOTE: Can be used to request peer's certificate after the secure connection has been established.
      ANOTHER NOTE: When running as the server, socket will be destroyed with an error after handshakeTimeout timeout.
      @param options - The options may contain the following fields: rejectUnauthorized,
      requestCert (See tls.createServer() for details).
      @param callback - callback(err) will be executed with null as err, once the renegotiation
      is successfully completed.
      @return `undefined` when socket is destroy, `false` if negotiaion can't be initiated.
    *)
    val renegotiate: t -> options:anonymous_interface_47 -> callback:(err:Error.t_0 or_null -> unit) -> bool or_undefined [@@js.call "renegotiate"]
    (**
      Set maximum TLS fragment size (default and maximum value is: 16384, minimum is: 512).
      Smaller fragment size decreases buffering latency on the client: large fragments are buffered by
      the TLS layer until the entire fragment is received and its integrity is verified;
      large fragments can span multiple roundtrips, and their processing can be delayed due to packet
      loss or reordering. However, smaller fragments add extra TLS framing bytes and CPU overhead,
      which may decrease overall server throughput.
      @param size - TLS fragment size (default and maximum value is: 16384, minimum is: 512).
      @return Returns true on success, false otherwise.
    *)
    val setMaxSendFragment: t -> size:float -> bool [@@js.call "setMaxSendFragment"]
    (**
      Disables TLS renegotiation for this TLSSocket instance. Once called,
      attempts to renegotiate will trigger an 'error' event on the
      TLSSocket.
    *)
    val disableRenegotiation: t -> unit [@@js.call "disableRenegotiation"]
    (**
      When enabled, TLS packet trace information is written to `stderr`. This can be
      used to debug TLS connection problems.
      
      Note: The format of the output is identical to the output of `openssl s_client
      -trace` or `openssl s_server -trace`. While it is produced by OpenSSL's
      `SSL_trace()` function, the format is undocumented, can change without notice,
      and should not be relied on.
    *)
    val enableTrace: t -> unit [@@js.call "enableTrace"]
    (**
      @param length number of bytes to retrieve from keying material
      @param label an application specific label, typically this will be a value from the
      \[IANA Exporter Label Registry\](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels).
      @param context optionally provide a context.
    *)
    val exportKeyingMaterial: t -> length:float -> label:string -> context:_Buffer -> _Buffer [@@js.call "exportKeyingMaterial"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener': t -> event:([`L_s83_OCSPResponse] [@js.enum]) -> listener:(response:_Buffer -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener'': t -> event:([`L_s295_secureConnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener''': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:_Buffer -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener'''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s83_OCSPResponse] [@js.enum]) -> response:_Buffer -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s295_secureConnect] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s297_session] [@js.enum]) -> session:_Buffer -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s241_keylog] [@js.enum]) -> line:_Buffer -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s83_OCSPResponse] [@js.enum]) -> listener:(response:_Buffer -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s295_secureConnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:_Buffer -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s83_OCSPResponse] [@js.enum]) -> listener:(response:_Buffer -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s295_secureConnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:_Buffer -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s83_OCSPResponse] [@js.enum]) -> listener:(response:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s295_secureConnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s83_OCSPResponse] [@js.enum]) -> listener:(response:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s295_secureConnect] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s297_session] [@js.enum]) -> listener:(session:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> net_Socket [@@js.cast]
  end
  module[@js.scope "CommonConnectionOptions"] CommonConnectionOptions : sig
    type t = tls_CommonConnectionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** An optional TLS context object from tls.createSecureContext() *)
    (** An optional TLS context object from tls.createSecureContext() *)
    val get_secureContext: t -> tls_SecureContext [@@js.get "secureContext"]
    (** An optional TLS context object from tls.createSecureContext() *)
    val set_secureContext: t -> tls_SecureContext -> unit [@@js.set "secureContext"]
    (**
      When enabled, TLS packet trace information is written to `stderr`. This can be
      used to debug TLS connection problems.
      default: false
    *)
    (**
      When enabled, TLS packet trace information is written to `stderr`. This can be
      used to debug TLS connection problems.
      default: false
    *)
    val get_enableTrace: t -> bool [@@js.get "enableTrace"]
    (**
      When enabled, TLS packet trace information is written to `stderr`. This can be
      used to debug TLS connection problems.
      default: false
    *)
    val set_enableTrace: t -> bool -> unit [@@js.set "enableTrace"]
    (**
      If true the server will request a certificate from clients that
      connect and attempt to verify that certificate. Defaults to
      false.
    *)
    (**
      If true the server will request a certificate from clients that
      connect and attempt to verify that certificate. Defaults to
      false.
    *)
    val get_requestCert: t -> bool [@@js.get "requestCert"]
    (**
      If true the server will request a certificate from clients that
      connect and attempt to verify that certificate. Defaults to
      false.
    *)
    val set_requestCert: t -> bool -> unit [@@js.set "requestCert"]
    (**
      An array of strings or a Buffer naming possible ALPN protocols.
      (Protocols should be ordered by their priority.)
    *)
    (**
      An array of strings or a Buffer naming possible ALPN protocols.
      (Protocols should be ordered by their priority.)
    *)
    val get_ALPNProtocols: t -> (Uint8Array.t_0, Uint8Array.t_0 or_string) or_array [@@js.get "ALPNProtocols"]
    (**
      An array of strings or a Buffer naming possible ALPN protocols.
      (Protocols should be ordered by their priority.)
    *)
    val set_ALPNProtocols: t -> (Uint8Array.t_0, Uint8Array.t_0 or_string) or_array -> unit [@@js.set "ALPNProtocols"]
    (**
      SNICallback(servername, cb) <Function> A function that will be
      called if the client supports SNI TLS extension. Two arguments
      will be passed when called: servername and cb. SNICallback should
      invoke cb(null, ctx), where ctx is a SecureContext instance.
      (tls.createSecureContext(...) can be used to get a proper
      SecureContext.) If SNICallback wasn't provided the default callback
      with high-level API will be used (see below).
    *)
    val sNICallback: t -> servername:string -> cb:(err:Error.t_0 or_null -> ctx:tls_SecureContext -> unit) -> unit [@@js.call "SNICallback"]
    (**
      If true the server will reject any connection which is not
      authorized with the list of supplied CAs. This option only has an
      effect if requestCert is true.
      default: true
    *)
    (**
      If true the server will reject any connection which is not
      authorized with the list of supplied CAs. This option only has an
      effect if requestCert is true.
      default: true
    *)
    val get_rejectUnauthorized: t -> bool [@@js.get "rejectUnauthorized"]
    (**
      If true the server will reject any connection which is not
      authorized with the list of supplied CAs. This option only has an
      effect if requestCert is true.
      default: true
    *)
    val set_rejectUnauthorized: t -> bool -> unit [@@js.set "rejectUnauthorized"]
  end
  module[@js.scope "TlsOptions"] TlsOptions : sig
    type t = tls_TlsOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Abort the connection if the SSL/TLS handshake does not finish in the
      specified number of milliseconds. A 'tlsClientError' is emitted on
      the tls.Server object whenever a handshake times out. Default:
      120000 (120 seconds).
    *)
    (**
      Abort the connection if the SSL/TLS handshake does not finish in the
      specified number of milliseconds. A 'tlsClientError' is emitted on
      the tls.Server object whenever a handshake times out. Default:
      120000 (120 seconds).
    *)
    val get_handshakeTimeout: t -> float [@@js.get "handshakeTimeout"]
    (**
      Abort the connection if the SSL/TLS handshake does not finish in the
      specified number of milliseconds. A 'tlsClientError' is emitted on
      the tls.Server object whenever a handshake times out. Default:
      120000 (120 seconds).
    *)
    val set_handshakeTimeout: t -> float -> unit [@@js.set "handshakeTimeout"]
    (**
      The number of seconds after which a TLS session created by the
      server will no longer be resumable. See Session Resumption for more
      information. Default: 300.
    *)
    (**
      The number of seconds after which a TLS session created by the
      server will no longer be resumable. See Session Resumption for more
      information. Default: 300.
    *)
    val get_sessionTimeout: t -> float [@@js.get "sessionTimeout"]
    (**
      The number of seconds after which a TLS session created by the
      server will no longer be resumable. See Session Resumption for more
      information. Default: 300.
    *)
    val set_sessionTimeout: t -> float -> unit [@@js.set "sessionTimeout"]
    (** 48-bytes of cryptographically strong pseudo-random data. *)
    (** 48-bytes of cryptographically strong pseudo-random data. *)
    val get_ticketKeys: t -> _Buffer [@@js.get "ticketKeys"]
    (** 48-bytes of cryptographically strong pseudo-random data. *)
    val set_ticketKeys: t -> _Buffer -> unit [@@js.set "ticketKeys"]
    (**
      @param socket 
      @param identity identity parameter sent from the client.
      @return pre-shared key that must either be
      a buffer or `null` to stop the negotiation process. Returned PSK must be
      compatible with the selected cipher's digest.
      
      When negotiating TLS-PSK (pre-shared keys), this function is called
      with the identity provided by the client.
      If the return value is `null` the negotiation process will stop and an
      "unknown_psk_identity" alert message will be sent to the other party.
      If the server wishes to hide the fact that the PSK identity was not known,
      the callback must provide some random data as `psk` to make the connection
      fail with "decrypt_error" before negotiation is finished.
      PSK ciphers are disabled by default, and using TLS-PSK thus
      requires explicitly specifying a cipher suite with the `ciphers` option.
      More information can be found in the RFC 4279.
    *)
    val pskCallback: t -> socket:tls_TLSSocket -> identity:string -> (DataView.t_0, _NodeJS_TypedArray) union2 or_null [@@js.call "pskCallback"]
    (**
      hint to send to a client to help
      with selecting the identity during TLS-PSK negotiation. Will be ignored
      in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be
      emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.
    *)
    (**
      hint to send to a client to help
      with selecting the identity during TLS-PSK negotiation. Will be ignored
      in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be
      emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.
    *)
    val get_pskIdentityHint: t -> string [@@js.get "pskIdentityHint"]
    (**
      hint to send to a client to help
      with selecting the identity during TLS-PSK negotiation. Will be ignored
      in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be
      emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.
    *)
    val set_pskIdentityHint: t -> string -> unit [@@js.set "pskIdentityHint"]
    val cast: t -> tls_SecureContextOptions [@@js.cast]
    val cast': t -> tls_CommonConnectionOptions [@@js.cast]
    val cast'': t -> net_ServerOpts [@@js.cast]
  end
  module[@js.scope "PSKCallbackNegotation"] PSKCallbackNegotation : sig
    type t = tls_PSKCallbackNegotation
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_psk: t -> (DataView.t_0, _NodeJS_TypedArray) union2 [@@js.get "psk"]
    val set_psk: t -> (DataView.t_0, _NodeJS_TypedArray) union2 -> unit [@@js.set "psk"]
    val get_identity: t -> string [@@js.get "identity"]
    val set_identity: t -> string -> unit [@@js.set "identity"]
  end
  module[@js.scope "ConnectionOptions"] ConnectionOptions : sig
    type t = tls_ConnectionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_host: t -> string [@@js.get "host"]
    val set_host: t -> string -> unit [@@js.set "host"]
    val get_port: t -> float [@@js.get "port"]
    val set_port: t -> float -> unit [@@js.set "port"]
    val get_path: t -> string [@@js.get "path"]
    val set_path: t -> string -> unit [@@js.set "path"]
    val get_socket: t -> net_Socket [@@js.get "socket"]
    val set_socket: t -> net_Socket -> unit [@@js.set "socket"]
    val checkServerIdentity: t -> host:string -> cert:tls_PeerCertificate -> Error.t_0 or_undefined [@@js.call "checkServerIdentity"]
    val get_servername: t -> string [@@js.get "servername"]
    val set_servername: t -> string -> unit [@@js.set "servername"]
    val get_session: t -> _Buffer [@@js.get "session"]
    val set_session: t -> _Buffer -> unit [@@js.set "session"]
    val get_minDHSize: t -> float [@@js.get "minDHSize"]
    val set_minDHSize: t -> float -> unit [@@js.set "minDHSize"]
    val get_lookup: t -> net_LookupFunction [@@js.get "lookup"]
    val set_lookup: t -> net_LookupFunction -> unit [@@js.set "lookup"]
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    (**
      When negotiating TLS-PSK (pre-shared keys), this function is called
      with optional identity `hint` provided by the server or `null`
      in case of TLS 1.3 where `hint` was removed.
      It will be necessary to provide a custom `tls.checkServerIdentity()`
      for the connection as the default one will try to check hostname/IP
      of the server against the certificate but that's not applicable for PSK
      because there won't be a certificate present.
      More information can be found in the RFC 4279.
      @param hint message sent from the server to help client
      decide which identity to use during negotiation.
      Always `null` if TLS 1.3 is used.
      @return Return `null` to stop the negotiation process. `psk` must be
      compatible with the selected cipher's digest.
      `identity` must use UTF-8 encoding.
    *)
    val pskCallback: t -> hint:string or_null -> tls_PSKCallbackNegotation or_null [@@js.call "pskCallback"]
    val cast: t -> tls_SecureContextOptions [@@js.cast]
    val cast': t -> tls_CommonConnectionOptions [@@js.cast]
  end
  module[@js.scope "Server"] Server : sig
    type t = tls_Server
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?secureConnectionListener:(socket:tls_TLSSocket -> unit) -> unit -> t [@@js.create]
    val create': options:tls_TlsOptions -> ?secureConnectionListener:(socket:tls_TLSSocket -> unit) -> unit -> t [@@js.create]
    (**
      The server.addContext() method adds a secure context that will be
      used if the client request's SNI name matches the supplied hostname
      (or wildcard).
    *)
    val addContext: t -> hostName:string -> credentials:tls_SecureContextOptions -> unit [@@js.call "addContext"]
    (** Returns the session ticket keys. *)
    val getTicketKeys: t -> _Buffer [@@js.call "getTicketKeys"]
    (**
      The server.setSecureContext() method replaces the
      secure context of an existing server. Existing connections to the
      server are not interrupted.
    *)
    val setSecureContext: t -> details:tls_SecureContextOptions -> unit [@@js.call "setSecureContext"]
    (**
      The server.setSecureContext() method replaces the secure context of
      an existing server. Existing connections to the server are not
      interrupted.
    *)
    val setTicketKeys: t -> keys:_Buffer -> unit [@@js.call "setTicketKeys"]
    (**
      events.EventEmitter
      1. tlsClientError
      2. newSession
      3. OCSPRequest
      4. resumeSession
      5. secureConnection
      6. keylog
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener': t -> event:([`L_s313_tlsClientError] [@js.enum]) -> listener:(err:Error.t_0 -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'': t -> event:([`L_s257_newSession] [@js.enum]) -> listener:(sessionId:_Buffer -> sessionData:_Buffer -> callback:(err:Error.t_0 -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener''': t -> event:([`L_s82_OCSPRequest] [@js.enum]) -> listener:(certificate:_Buffer -> issuer:_Buffer -> callback:(err:Error.t_0 or_null -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'''': t -> event:([`L_s291_resumeSession] [@js.enum]) -> listener:(sessionId:_Buffer -> callback:(err:Error.t_0 -> sessionData:_Buffer -> unit) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener''''': t -> event:([`L_s296_secureConnection] [@js.enum]) -> listener:(tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connection
        3. error
        4. listening
    *)
    val addListener'''''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s313_tlsClientError] [@js.enum]) -> err:Error.t_0 -> tlsSocket:tls_TLSSocket -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s257_newSession] [@js.enum]) -> sessionId:_Buffer -> sessionData:_Buffer -> callback:(err:Error.t_0 -> resp:_Buffer -> unit) -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s82_OCSPRequest] [@js.enum]) -> certificate:_Buffer -> issuer:_Buffer -> callback:(err:Error.t_0 or_null -> resp:_Buffer -> unit) -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s291_resumeSession] [@js.enum]) -> sessionId:_Buffer -> callback:(err:Error.t_0 -> sessionData:_Buffer -> unit) -> bool [@@js.call "emit"]
    val emit''''': t -> event:([`L_s296_secureConnection] [@js.enum]) -> tlsSocket:tls_TLSSocket -> bool [@@js.call "emit"]
    val emit'''''': t -> event:([`L_s241_keylog] [@js.enum]) -> line:_Buffer -> tlsSocket:tls_TLSSocket -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s313_tlsClientError] [@js.enum]) -> listener:(err:Error.t_0 -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s257_newSession] [@js.enum]) -> listener:(sessionId:_Buffer -> sessionData:_Buffer -> callback:(err:Error.t_0 -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s82_OCSPRequest] [@js.enum]) -> listener:(certificate:_Buffer -> issuer:_Buffer -> callback:(err:Error.t_0 or_null -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s291_resumeSession] [@js.enum]) -> listener:(sessionId:_Buffer -> callback:(err:Error.t_0 -> sessionData:_Buffer -> unit) -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:([`L_s296_secureConnection] [@js.enum]) -> listener:(tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "on"]
    val on'''''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s313_tlsClientError] [@js.enum]) -> listener:(err:Error.t_0 -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s257_newSession] [@js.enum]) -> listener:(sessionId:_Buffer -> sessionData:_Buffer -> callback:(err:Error.t_0 -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s82_OCSPRequest] [@js.enum]) -> listener:(certificate:_Buffer -> issuer:_Buffer -> callback:(err:Error.t_0 or_null -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s291_resumeSession] [@js.enum]) -> listener:(sessionId:_Buffer -> callback:(err:Error.t_0 -> sessionData:_Buffer -> unit) -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:([`L_s296_secureConnection] [@js.enum]) -> listener:(tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "once"]
    val once'''''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s313_tlsClientError] [@js.enum]) -> listener:(err:Error.t_0 -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s257_newSession] [@js.enum]) -> listener:(sessionId:_Buffer -> sessionData:_Buffer -> callback:(err:Error.t_0 -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s82_OCSPRequest] [@js.enum]) -> listener:(certificate:_Buffer -> issuer:_Buffer -> callback:(err:Error.t_0 or_null -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s291_resumeSession] [@js.enum]) -> listener:(sessionId:_Buffer -> callback:(err:Error.t_0 -> sessionData:_Buffer -> unit) -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:([`L_s296_secureConnection] [@js.enum]) -> listener:(tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s313_tlsClientError] [@js.enum]) -> listener:(err:Error.t_0 -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s257_newSession] [@js.enum]) -> listener:(sessionId:_Buffer -> sessionData:_Buffer -> callback:(err:Error.t_0 -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s82_OCSPRequest] [@js.enum]) -> listener:(certificate:_Buffer -> issuer:_Buffer -> callback:(err:Error.t_0 or_null -> resp:_Buffer -> unit) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s291_resumeSession] [@js.enum]) -> listener:(sessionId:_Buffer -> callback:(err:Error.t_0 -> sessionData:_Buffer -> unit) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:([`L_s296_secureConnection] [@js.enum]) -> listener:(tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''''': t -> event:([`L_s241_keylog] [@js.enum]) -> listener:(line:_Buffer -> tlsSocket:tls_TLSSocket -> unit) -> t [@@js.call "prependOnceListener"]
    val cast: t -> net_Server [@@js.cast]
  end
  module[@js.scope "SecurePair"] SecurePair : sig
    type t = tls_SecurePair
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encrypted: t -> tls_TLSSocket [@@js.get "encrypted"]
    val set_encrypted: t -> tls_TLSSocket -> unit [@@js.set "encrypted"]
    val get_cleartext: t -> tls_TLSSocket [@@js.get "cleartext"]
    val set_cleartext: t -> tls_TLSSocket -> unit [@@js.set "cleartext"]
  end
  module SecureVersion : sig
    type t = tls_SecureVersion
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "SecureContextOptions"] SecureContextOptions : sig
    type t = tls_SecureContextOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Optionally override the trusted CA certificates. Default is to trust
      the well-known CAs curated by Mozilla. Mozilla's CAs are completely
      replaced when CAs are explicitly specified using this option.
    *)
    (**
      Optionally override the trusted CA certificates. Default is to trust
      the well-known CAs curated by Mozilla. Mozilla's CAs are completely
      replaced when CAs are explicitly specified using this option.
    *)
    val get_ca: t -> (_Buffer, _Buffer or_string list) union2 or_string [@@js.get "ca"]
    (**
      Optionally override the trusted CA certificates. Default is to trust
      the well-known CAs curated by Mozilla. Mozilla's CAs are completely
      replaced when CAs are explicitly specified using this option.
    *)
    val set_ca: t -> (_Buffer, _Buffer or_string list) union2 or_string -> unit [@@js.set "ca"]
    (**
      Cert chains in PEM format. One cert chain should be provided per
      private key. Each cert chain should consist of the PEM formatted
      certificate for a provided private key, followed by the PEM
      formatted intermediate certificates (if any), in order, and not
      including the root CA (the root CA must be pre-known to the peer,
      see ca). When providing multiple cert chains, they do not have to
      be in the same order as their private keys in key. If the
      intermediate certificates are not provided, the peer will not be
      able to validate the certificate, and the handshake will fail.
    *)
    (**
      Cert chains in PEM format. One cert chain should be provided per
      private key. Each cert chain should consist of the PEM formatted
      certificate for a provided private key, followed by the PEM
      formatted intermediate certificates (if any), in order, and not
      including the root CA (the root CA must be pre-known to the peer,
      see ca). When providing multiple cert chains, they do not have to
      be in the same order as their private keys in key. If the
      intermediate certificates are not provided, the peer will not be
      able to validate the certificate, and the handshake will fail.
    *)
    val get_cert: t -> (_Buffer, _Buffer or_string list) union2 or_string [@@js.get "cert"]
    (**
      Cert chains in PEM format. One cert chain should be provided per
      private key. Each cert chain should consist of the PEM formatted
      certificate for a provided private key, followed by the PEM
      formatted intermediate certificates (if any), in order, and not
      including the root CA (the root CA must be pre-known to the peer,
      see ca). When providing multiple cert chains, they do not have to
      be in the same order as their private keys in key. If the
      intermediate certificates are not provided, the peer will not be
      able to validate the certificate, and the handshake will fail.
    *)
    val set_cert: t -> (_Buffer, _Buffer or_string list) union2 or_string -> unit [@@js.set "cert"]
    (**
      Colon-separated list of supported signature algorithms. The list
      can contain digest algorithms (SHA256, MD5 etc.), public key
      algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g
      'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).
    *)
    (**
      Colon-separated list of supported signature algorithms. The list
      can contain digest algorithms (SHA256, MD5 etc.), public key
      algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g
      'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).
    *)
    val get_sigalgs: t -> string [@@js.get "sigalgs"]
    (**
      Colon-separated list of supported signature algorithms. The list
      can contain digest algorithms (SHA256, MD5 etc.), public key
      algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g
      'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).
    *)
    val set_sigalgs: t -> string -> unit [@@js.set "sigalgs"]
    (**
      Cipher suite specification, replacing the default. For more
      information, see modifying the default cipher suite. Permitted
      ciphers can be obtained via tls.getCiphers(). Cipher names must be
      uppercased in order for OpenSSL to accept them.
    *)
    (**
      Cipher suite specification, replacing the default. For more
      information, see modifying the default cipher suite. Permitted
      ciphers can be obtained via tls.getCiphers(). Cipher names must be
      uppercased in order for OpenSSL to accept them.
    *)
    val get_ciphers: t -> string [@@js.get "ciphers"]
    (**
      Cipher suite specification, replacing the default. For more
      information, see modifying the default cipher suite. Permitted
      ciphers can be obtained via tls.getCiphers(). Cipher names must be
      uppercased in order for OpenSSL to accept them.
    *)
    val set_ciphers: t -> string -> unit [@@js.set "ciphers"]
    (** Name of an OpenSSL engine which can provide the client certificate. *)
    (** Name of an OpenSSL engine which can provide the client certificate. *)
    val get_clientCertEngine: t -> string [@@js.get "clientCertEngine"]
    (** Name of an OpenSSL engine which can provide the client certificate. *)
    val set_clientCertEngine: t -> string -> unit [@@js.set "clientCertEngine"]
    (** PEM formatted CRLs (Certificate Revocation Lists). *)
    (** PEM formatted CRLs (Certificate Revocation Lists). *)
    val get_crl: t -> (_Buffer, _Buffer or_string list) union2 or_string [@@js.get "crl"]
    (** PEM formatted CRLs (Certificate Revocation Lists). *)
    val set_crl: t -> (_Buffer, _Buffer or_string list) union2 or_string -> unit [@@js.set "crl"]
    (**
      Diffie Hellman parameters, required for Perfect Forward Secrecy. Use
      openssl dhparam to create the parameters. The key length must be
      greater than or equal to 1024 bits or else an error will be thrown.
      Although 1024 bits is permissible, use 2048 bits or larger for
      stronger security. If omitted or invalid, the parameters are
      silently discarded and DHE ciphers will not be available.
    *)
    (**
      Diffie Hellman parameters, required for Perfect Forward Secrecy. Use
      openssl dhparam to create the parameters. The key length must be
      greater than or equal to 1024 bits or else an error will be thrown.
      Although 1024 bits is permissible, use 2048 bits or larger for
      stronger security. If omitted or invalid, the parameters are
      silently discarded and DHE ciphers will not be available.
    *)
    val get_dhparam: t -> _Buffer or_string [@@js.get "dhparam"]
    (**
      Diffie Hellman parameters, required for Perfect Forward Secrecy. Use
      openssl dhparam to create the parameters. The key length must be
      greater than or equal to 1024 bits or else an error will be thrown.
      Although 1024 bits is permissible, use 2048 bits or larger for
      stronger security. If omitted or invalid, the parameters are
      silently discarded and DHE ciphers will not be available.
    *)
    val set_dhparam: t -> _Buffer or_string -> unit [@@js.set "dhparam"]
    (**
      A string describing a named curve or a colon separated list of curve
      NIDs or names, for example P-521:P-384:P-256, to use for ECDH key
      agreement. Set to auto to select the curve automatically. Use
      crypto.getCurves() to obtain a list of available curve names. On
      recent releases, openssl ecparam -list_curves will also display the
      name and description of each available elliptic curve. Default:
      tls.DEFAULT_ECDH_CURVE.
    *)
    (**
      A string describing a named curve or a colon separated list of curve
      NIDs or names, for example P-521:P-384:P-256, to use for ECDH key
      agreement. Set to auto to select the curve automatically. Use
      crypto.getCurves() to obtain a list of available curve names. On
      recent releases, openssl ecparam -list_curves will also display the
      name and description of each available elliptic curve. Default:
      tls.DEFAULT_ECDH_CURVE.
    *)
    val get_ecdhCurve: t -> string [@@js.get "ecdhCurve"]
    (**
      A string describing a named curve or a colon separated list of curve
      NIDs or names, for example P-521:P-384:P-256, to use for ECDH key
      agreement. Set to auto to select the curve automatically. Use
      crypto.getCurves() to obtain a list of available curve names. On
      recent releases, openssl ecparam -list_curves will also display the
      name and description of each available elliptic curve. Default:
      tls.DEFAULT_ECDH_CURVE.
    *)
    val set_ecdhCurve: t -> string -> unit [@@js.set "ecdhCurve"]
    (**
      Attempt to use the server's cipher suite preferences instead of the
      client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be
      set in secureOptions
    *)
    (**
      Attempt to use the server's cipher suite preferences instead of the
      client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be
      set in secureOptions
    *)
    val get_honorCipherOrder: t -> bool [@@js.get "honorCipherOrder"]
    (**
      Attempt to use the server's cipher suite preferences instead of the
      client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be
      set in secureOptions
    *)
    val set_honorCipherOrder: t -> bool -> unit [@@js.set "honorCipherOrder"]
    (**
      Private keys in PEM format. PEM allows the option of private keys
      being encrypted. Encrypted keys will be decrypted with
      options.passphrase. Multiple keys using different algorithms can be
      provided either as an array of unencrypted key strings or buffers,
      or an array of objects in the form \{pem: <string|buffer>\[,
      passphrase: <string>\]\}. The object form can only occur in an array.
      object.passphrase is optional. Encrypted keys will be decrypted with
      object.passphrase if provided, or options.passphrase if it is not.
    *)
    (**
      Private keys in PEM format. PEM allows the option of private keys
      being encrypted. Encrypted keys will be decrypted with
      options.passphrase. Multiple keys using different algorithms can be
      provided either as an array of unencrypted key strings or buffers,
      or an array of objects in the form \{pem: <string|buffer>\[,
      passphrase: <string>\]\}. The object form can only occur in an array.
      object.passphrase is optional. Encrypted keys will be decrypted with
      object.passphrase if provided, or options.passphrase if it is not.
    *)
    val get_key: t -> (_Buffer, (_Buffer, tls_KeyObject) union2 list) union2 or_string [@@js.get "key"]
    (**
      Private keys in PEM format. PEM allows the option of private keys
      being encrypted. Encrypted keys will be decrypted with
      options.passphrase. Multiple keys using different algorithms can be
      provided either as an array of unencrypted key strings or buffers,
      or an array of objects in the form \{pem: <string|buffer>\[,
      passphrase: <string>\]\}. The object form can only occur in an array.
      object.passphrase is optional. Encrypted keys will be decrypted with
      object.passphrase if provided, or options.passphrase if it is not.
    *)
    val set_key: t -> (_Buffer, (_Buffer, tls_KeyObject) union2 list) union2 or_string -> unit [@@js.set "key"]
    (**
      Name of an OpenSSL engine to get private key from. Should be used
      together with privateKeyIdentifier.
    *)
    (**
      Name of an OpenSSL engine to get private key from. Should be used
      together with privateKeyIdentifier.
    *)
    val get_privateKeyEngine: t -> string [@@js.get "privateKeyEngine"]
    (**
      Name of an OpenSSL engine to get private key from. Should be used
      together with privateKeyIdentifier.
    *)
    val set_privateKeyEngine: t -> string -> unit [@@js.set "privateKeyEngine"]
    (**
      Identifier of a private key managed by an OpenSSL engine. Should be
      used together with privateKeyEngine. Should not be set together with
      key, because both options define a private key in different ways.
    *)
    (**
      Identifier of a private key managed by an OpenSSL engine. Should be
      used together with privateKeyEngine. Should not be set together with
      key, because both options define a private key in different ways.
    *)
    val get_privateKeyIdentifier: t -> string [@@js.get "privateKeyIdentifier"]
    (**
      Identifier of a private key managed by an OpenSSL engine. Should be
      used together with privateKeyEngine. Should not be set together with
      key, because both options define a private key in different ways.
    *)
    val set_privateKeyIdentifier: t -> string -> unit [@@js.set "privateKeyIdentifier"]
    (**
      Optionally set the maximum TLS version to allow. One
      of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
      `secureProtocol` option, use one or the other.
      **Default:** `'TLSv1.3'`, unless changed using CLI options. Using
      `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to
      `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.
    *)
    (**
      Optionally set the maximum TLS version to allow. One
      of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
      `secureProtocol` option, use one or the other.
      **Default:** `'TLSv1.3'`, unless changed using CLI options. Using
      `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to
      `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.
    *)
    val get_maxVersion: t -> tls_SecureVersion [@@js.get "maxVersion"]
    (**
      Optionally set the maximum TLS version to allow. One
      of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
      `secureProtocol` option, use one or the other.
      **Default:** `'TLSv1.3'`, unless changed using CLI options. Using
      `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to
      `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.
    *)
    val set_maxVersion: t -> tls_SecureVersion -> unit [@@js.set "maxVersion"]
    (**
      Optionally set the minimum TLS version to allow. One
      of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
      `secureProtocol` option, use one or the other.  It is not recommended to use
      less than TLSv1.2, but it may be required for interoperability.
      **Default:** `'TLSv1.2'`, unless changed using CLI options. Using
      `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to
      `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to
      'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.
    *)
    (**
      Optionally set the minimum TLS version to allow. One
      of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
      `secureProtocol` option, use one or the other.  It is not recommended to use
      less than TLSv1.2, but it may be required for interoperability.
      **Default:** `'TLSv1.2'`, unless changed using CLI options. Using
      `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to
      `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to
      'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.
    *)
    val get_minVersion: t -> tls_SecureVersion [@@js.get "minVersion"]
    (**
      Optionally set the minimum TLS version to allow. One
      of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the
      `secureProtocol` option, use one or the other.  It is not recommended to use
      less than TLSv1.2, but it may be required for interoperability.
      **Default:** `'TLSv1.2'`, unless changed using CLI options. Using
      `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to
      `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to
      'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.
    *)
    val set_minVersion: t -> tls_SecureVersion -> unit [@@js.set "minVersion"]
    (** Shared passphrase used for a single private key and/or a PFX. *)
    (** Shared passphrase used for a single private key and/or a PFX. *)
    val get_passphrase: t -> string [@@js.get "passphrase"]
    (** Shared passphrase used for a single private key and/or a PFX. *)
    val set_passphrase: t -> string -> unit [@@js.set "passphrase"]
    (**
      PFX or PKCS12 encoded private key and certificate chain. pfx is an
      alternative to providing key and cert individually. PFX is usually
      encrypted, if it is, passphrase will be used to decrypt it. Multiple
      PFX can be provided either as an array of unencrypted PFX buffers,
      or an array of objects in the form \{buf: <string|buffer>\[,
      passphrase: <string>\]\}. The object form can only occur in an array.
      object.passphrase is optional. Encrypted PFX will be decrypted with
      object.passphrase if provided, or options.passphrase if it is not.
    *)
    (**
      PFX or PKCS12 encoded private key and certificate chain. pfx is an
      alternative to providing key and cert individually. PFX is usually
      encrypted, if it is, passphrase will be used to decrypt it. Multiple
      PFX can be provided either as an array of unencrypted PFX buffers,
      or an array of objects in the form \{buf: <string|buffer>\[,
      passphrase: <string>\]\}. The object form can only occur in an array.
      object.passphrase is optional. Encrypted PFX will be decrypted with
      object.passphrase if provided, or options.passphrase if it is not.
    *)
    val get_pfx: t -> (_Buffer, (_Buffer, tls_PxfObject) union2 or_string list) union2 or_string [@@js.get "pfx"]
    (**
      PFX or PKCS12 encoded private key and certificate chain. pfx is an
      alternative to providing key and cert individually. PFX is usually
      encrypted, if it is, passphrase will be used to decrypt it. Multiple
      PFX can be provided either as an array of unencrypted PFX buffers,
      or an array of objects in the form \{buf: <string|buffer>\[,
      passphrase: <string>\]\}. The object form can only occur in an array.
      object.passphrase is optional. Encrypted PFX will be decrypted with
      object.passphrase if provided, or options.passphrase if it is not.
    *)
    val set_pfx: t -> (_Buffer, (_Buffer, tls_PxfObject) union2 or_string list) union2 or_string -> unit [@@js.set "pfx"]
    (**
      Optionally affect the OpenSSL protocol behavior, which is not
      usually necessary. This should be used carefully if at all! Value is
      a numeric bitmask of the SSL_OP_* options from OpenSSL Options
    *)
    (**
      Optionally affect the OpenSSL protocol behavior, which is not
      usually necessary. This should be used carefully if at all! Value is
      a numeric bitmask of the SSL_OP_* options from OpenSSL Options
    *)
    val get_secureOptions: t -> float [@@js.get "secureOptions"]
    (**
      Optionally affect the OpenSSL protocol behavior, which is not
      usually necessary. This should be used carefully if at all! Value is
      a numeric bitmask of the SSL_OP_* options from OpenSSL Options
    *)
    val set_secureOptions: t -> float -> unit [@@js.set "secureOptions"]
    (**
      Legacy mechanism to select the TLS protocol version to use, it does
      not support independent control of the minimum and maximum version,
      and does not support limiting the protocol to TLSv1.3. Use
      minVersion and maxVersion instead. The possible values are listed as
      SSL_METHODS, use the function names as strings. For example, use
      'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow
      any TLS protocol version up to TLSv1.3. It is not recommended to use
      TLS versions less than 1.2, but it may be required for
      interoperability. Default: none, see minVersion.
    *)
    (**
      Legacy mechanism to select the TLS protocol version to use, it does
      not support independent control of the minimum and maximum version,
      and does not support limiting the protocol to TLSv1.3. Use
      minVersion and maxVersion instead. The possible values are listed as
      SSL_METHODS, use the function names as strings. For example, use
      'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow
      any TLS protocol version up to TLSv1.3. It is not recommended to use
      TLS versions less than 1.2, but it may be required for
      interoperability. Default: none, see minVersion.
    *)
    val get_secureProtocol: t -> string [@@js.get "secureProtocol"]
    (**
      Legacy mechanism to select the TLS protocol version to use, it does
      not support independent control of the minimum and maximum version,
      and does not support limiting the protocol to TLSv1.3. Use
      minVersion and maxVersion instead. The possible values are listed as
      SSL_METHODS, use the function names as strings. For example, use
      'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow
      any TLS protocol version up to TLSv1.3. It is not recommended to use
      TLS versions less than 1.2, but it may be required for
      interoperability. Default: none, see minVersion.
    *)
    val set_secureProtocol: t -> string -> unit [@@js.set "secureProtocol"]
    (**
      Opaque identifier used by servers to ensure session state is not
      shared between applications. Unused by clients.
    *)
    (**
      Opaque identifier used by servers to ensure session state is not
      shared between applications. Unused by clients.
    *)
    val get_sessionIdContext: t -> string [@@js.get "sessionIdContext"]
    (**
      Opaque identifier used by servers to ensure session state is not
      shared between applications. Unused by clients.
    *)
    val set_sessionIdContext: t -> string -> unit [@@js.set "sessionIdContext"]
    (**
      48-bytes of cryptographically strong pseudo-random data.
      See Session Resumption for more information.
    *)
    (**
      48-bytes of cryptographically strong pseudo-random data.
      See Session Resumption for more information.
    *)
    val get_ticketKeys: t -> _Buffer [@@js.get "ticketKeys"]
    (**
      48-bytes of cryptographically strong pseudo-random data.
      See Session Resumption for more information.
    *)
    val set_ticketKeys: t -> _Buffer -> unit [@@js.set "ticketKeys"]
    (**
      The number of seconds after which a TLS session created by the
      server will no longer be resumable. See Session Resumption for more
      information. Default: 300.
    *)
    (**
      The number of seconds after which a TLS session created by the
      server will no longer be resumable. See Session Resumption for more
      information. Default: 300.
    *)
    val get_sessionTimeout: t -> float [@@js.get "sessionTimeout"]
    (**
      The number of seconds after which a TLS session created by the
      server will no longer be resumable. See Session Resumption for more
      information. Default: 300.
    *)
    val set_sessionTimeout: t -> float -> unit [@@js.set "sessionTimeout"]
  end
  module[@js.scope "SecureContext"] SecureContext : sig
    type t = tls_SecureContext
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_context: t -> any [@@js.get "context"]
    val set_context: t -> any -> unit [@@js.set "context"]
  end
  val checkServerIdentity: host:string -> cert:tls_PeerCertificate -> Error.t_0 or_undefined [@@js.global "checkServerIdentity"]
  val createServer: ?secureConnectionListener:(socket:tls_TLSSocket -> unit) -> unit -> tls_Server [@@js.global "createServer"]
  val createServer: options:tls_TlsOptions -> ?secureConnectionListener:(socket:tls_TLSSocket -> unit) -> unit -> tls_Server [@@js.global "createServer"]
  val connect: options:tls_ConnectionOptions -> ?secureConnectListener:(unit -> unit) -> unit -> tls_TLSSocket [@@js.global "connect"]
  val connect: port:float -> ?host:string -> ?options:tls_ConnectionOptions -> ?secureConnectListener:(unit -> unit) -> unit -> tls_TLSSocket [@@js.global "connect"]
  val connect: port:float -> ?options:tls_ConnectionOptions -> ?secureConnectListener:(unit -> unit) -> unit -> tls_TLSSocket [@@js.global "connect"]
  (** @deprecated since v0.11.3 Use `tls.TLSSocket` instead. *)
  val createSecurePair: ?credentials:tls_SecureContext -> ?isServer:bool -> ?requestCert:bool -> ?rejectUnauthorized:bool -> unit -> tls_SecurePair [@@js.global "createSecurePair"]
  val createSecureContext: ?options:tls_SecureContextOptions -> unit -> tls_SecureContext [@@js.global "createSecureContext"]
  val getCiphers: unit -> string list [@@js.global "getCiphers"]
  (**
    The default curve name to use for ECDH key agreement in a tls server.
    The default value is 'auto'. See tls.createSecureContext() for further
    information.
  *)
  val default_ecdh_curve: string [@@js.global "DEFAULT_ECDH_CURVE"]
  (**
    The default value of the maxVersion option of
    tls.createSecureContext(). It can be assigned any of the supported TLS
    protocol versions, 'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default:
    'TLSv1.3', unless changed using CLI options. Using --tls-max-v1.2 sets
    the default to 'TLSv1.2'. Using --tls-max-v1.3 sets the default to
    'TLSv1.3'. If multiple of the options are provided, the highest maximum
    is used.
  *)
  val default_max_version: tls_SecureVersion [@@js.global "DEFAULT_MAX_VERSION"]
  (**
    The default value of the minVersion option of tls.createSecureContext().
    It can be assigned any of the supported TLS protocol versions,
    'TLSv1.3', 'TLSv1.2', 'TLSv1.1', or 'TLSv1'. Default: 'TLSv1.2', unless
    changed using CLI options. Using --tls-min-v1.0 sets the default to
    'TLSv1'. Using --tls-min-v1.1 sets the default to 'TLSv1.1'. Using
    --tls-min-v1.3 sets the default to 'TLSv1.3'. If multiple of the options
    are provided, the lowest minimum is used.
  *)
  val default_min_version: tls_SecureVersion [@@js.global "DEFAULT_MIN_VERSION"]
  (**
    An immutable array of strings representing the root certificates (in PEM
    format) used for verifying peer certificates. This is the default value
    of the ca option to tls.createSecureContext().
  *)
  val rootCertificates: string list [@@js.global "rootCertificates"]
end
module Node_trace_events : sig
  (* export * from 'trace_events'; *)
end
module[@js.scope "trace_events"] Trace_events : sig
  (**
    The `Tracing` object is used to enable or disable tracing for sets of
    categories. Instances are created using the
    `trace_events.createTracing()` method.
    
    When created, the `Tracing` object is disabled. Calling the
    `tracing.enable()` method adds the categories to the set of enabled trace
    event categories. Calling `tracing.disable()` will remove the categories
    from the set of enabled trace event categories.
  *)
  module[@js.scope "Tracing"] Tracing : sig
    type t = trace_events_Tracing
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      A comma-separated list of the trace event categories covered by this
      `Tracing` object.
    *)
    val get_categories: t -> string [@@js.get "categories"]
    (**
      Disables this `Tracing` object.
      
      Only trace event categories _not_ covered by other enabled `Tracing`
      objects and _not_ specified by the `--trace-event-categories` flag
      will be disabled.
    *)
    val disable: t -> unit [@@js.call "disable"]
    (**
      Enables this `Tracing` object for the set of categories covered by
      the `Tracing` object.
    *)
    val enable: t -> unit [@@js.call "enable"]
    (** `true` only if the `Tracing` object has been enabled. *)
    val get_enabled: t -> bool [@@js.get "enabled"]
  end
  module[@js.scope "CreateTracingOptions"] CreateTracingOptions : sig
    type t = trace_events_CreateTracingOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      An array of trace category names. Values included in the array are
      coerced to a string when possible. An error will be thrown if the
      value cannot be coerced.
    *)
    (**
      An array of trace category names. Values included in the array are
      coerced to a string when possible. An error will be thrown if the
      value cannot be coerced.
    *)
    val get_categories: t -> string list [@@js.get "categories"]
    (**
      An array of trace category names. Values included in the array are
      coerced to a string when possible. An error will be thrown if the
      value cannot be coerced.
    *)
    val set_categories: t -> string list -> unit [@@js.set "categories"]
  end
  (** Creates and returns a Tracing object for the given set of categories. *)
  val createTracing: options:trace_events_CreateTracingOptions -> trace_events_Tracing [@@js.global "createTracing"]
  (**
    Returns a comma-separated list of all currently-enabled trace event
    categories. The current set of enabled trace event categories is
    determined by the union of all currently-enabled `Tracing` objects and
    any categories enabled using the `--trace-event-categories` flag.
  *)
  val getEnabledCategories: unit -> string or_undefined [@@js.global "getEnabledCategories"]
end
module Node_tty : sig
  (* export * from 'tty'; *)
end
module[@js.scope "tty"] Tty : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:net
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/tty.d.ts } *)
  val isatty: fd:float -> bool [@@js.global "isatty"]
  module[@js.scope "ReadStream"] ReadStream : sig
    type t = tty_ReadStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: fd:float -> ?options:net_SocketConstructorOpts -> unit -> t [@@js.create]
    val get_isRaw: t -> bool [@@js.get "isRaw"]
    val set_isRaw: t -> bool -> unit [@@js.set "isRaw"]
    val setRawMode: t -> mode:bool -> t [@@js.call "setRawMode"]
    val get_isTTY: t -> bool [@@js.get "isTTY"]
    val set_isTTY: t -> bool -> unit [@@js.set "isTTY"]
    val cast: t -> net_Socket [@@js.cast]
  end
  (**
    -1 - to the left from cursor
     0 - the entire line
     1 - to the right from cursor
  *)
  module Direction : sig
    type t = tty_Direction
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "WriteStream"] WriteStream : sig
    type t = tty_WriteStream
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: fd:float -> t [@@js.create]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    (**
      events.EventEmitter
        1. close
        2. connect
        3. data
        4. drain
        5. end
        6. error
        7. lookup
        8. timeout
    *)
    val addListener': t -> event:([`L_s287_resize] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s287_resize] [@js.enum]) -> bool [@@js.call "emit"]
    val on: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s287_resize] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val once: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s287_resize] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s287_resize] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s287_resize] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    (** Clears the current line of this WriteStream in a direction identified by `dir`. *)
    val clearLine: t -> dir:tty_Direction -> ?callback:(unit -> unit) -> unit -> bool [@@js.call "clearLine"]
    (** Clears this `WriteStream` from the current cursor down. *)
    val clearScreenDown: t -> ?callback:(unit -> unit) -> unit -> bool [@@js.call "clearScreenDown"]
    (** Moves this WriteStream's cursor to the specified position. *)
    val cursorTo: t -> x:float -> ?y:float -> ?callback:(unit -> unit) -> unit -> bool [@@js.call "cursorTo"]
    (** Moves this WriteStream's cursor to the specified position. *)
    val cursorTo': t -> x:float -> callback:(unit -> unit) -> bool [@@js.call "cursorTo"]
    (** Moves this WriteStream's cursor relative to its current position. *)
    val moveCursor: t -> dx:float -> dy:float -> ?callback:(unit -> unit) -> unit -> bool [@@js.call "moveCursor"]
    (** default: `process.env` *)
    val getColorDepth: t -> ?env:anonymous_interface_0 -> unit -> float [@@js.call "getColorDepth"]
    val hasColors: t -> ?depth:float -> unit -> bool [@@js.call "hasColors"]
    val hasColors': t -> ?env:anonymous_interface_0 -> unit -> bool [@@js.call "hasColors"]
    val hasColors'': t -> depth:float -> ?env:anonymous_interface_0 -> unit -> bool [@@js.call "hasColors"]
    val getWindowSize: t -> (float * float) [@@js.call "getWindowSize"]
    val get_columns: t -> float [@@js.get "columns"]
    val set_columns: t -> float -> unit [@@js.set "columns"]
    val get_rows: t -> float [@@js.get "rows"]
    val set_rows: t -> float -> unit [@@js.set "rows"]
    val get_isTTY: t -> bool [@@js.get "isTTY"]
    val set_isTTY: t -> bool -> unit [@@js.set "isTTY"]
    val cast: t -> net_Socket [@@js.cast]
  end
end
module Node_url : sig
  (* export * from 'url'; *)
end
module[@js.scope "url"] Url : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:querystring
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/url.d.ts } *)
  module[@js.scope "UrlObject"] UrlObject : sig
    type t = url_UrlObject
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_auth: t -> string or_null [@@js.get "auth"]
    val set_auth: t -> string or_null -> unit [@@js.set "auth"]
    val get_hash: t -> string or_null [@@js.get "hash"]
    val set_hash: t -> string or_null -> unit [@@js.set "hash"]
    val get_host: t -> string or_null [@@js.get "host"]
    val set_host: t -> string or_null -> unit [@@js.set "host"]
    val get_hostname: t -> string or_null [@@js.get "hostname"]
    val set_hostname: t -> string or_null -> unit [@@js.set "hostname"]
    val get_href: t -> string or_null [@@js.get "href"]
    val set_href: t -> string or_null -> unit [@@js.set "href"]
    val get_pathname: t -> string or_null [@@js.get "pathname"]
    val set_pathname: t -> string or_null -> unit [@@js.set "pathname"]
    val get_protocol: t -> string or_null [@@js.get "protocol"]
    val set_protocol: t -> string or_null -> unit [@@js.set "protocol"]
    val get_search: t -> string or_null [@@js.get "search"]
    val set_search: t -> string or_null -> unit [@@js.set "search"]
    val get_slashes: t -> bool or_null [@@js.get "slashes"]
    val set_slashes: t -> bool or_null -> unit [@@js.set "slashes"]
    val get_port: t -> string or_number or_null [@@js.get "port"]
    val set_port: t -> string or_number or_null -> unit [@@js.set "port"]
    val get_query: t -> ParsedUrlQueryInput.t_0 or_string or_null [@@js.get "query"]
    val set_query: t -> ParsedUrlQueryInput.t_0 or_string or_null -> unit [@@js.set "query"]
  end
  module[@js.scope "Url"] Url : sig
    type t = url_Url
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_auth: t -> string or_null [@@js.get "auth"]
    val set_auth: t -> string or_null -> unit [@@js.set "auth"]
    val get_hash: t -> string or_null [@@js.get "hash"]
    val set_hash: t -> string or_null -> unit [@@js.set "hash"]
    val get_host: t -> string or_null [@@js.get "host"]
    val set_host: t -> string or_null -> unit [@@js.set "host"]
    val get_hostname: t -> string or_null [@@js.get "hostname"]
    val set_hostname: t -> string or_null -> unit [@@js.set "hostname"]
    val get_href: t -> string [@@js.get "href"]
    val set_href: t -> string -> unit [@@js.set "href"]
    val get_path: t -> string or_null [@@js.get "path"]
    val set_path: t -> string or_null -> unit [@@js.set "path"]
    val get_pathname: t -> string or_null [@@js.get "pathname"]
    val set_pathname: t -> string or_null -> unit [@@js.set "pathname"]
    val get_protocol: t -> string or_null [@@js.get "protocol"]
    val set_protocol: t -> string or_null -> unit [@@js.set "protocol"]
    val get_search: t -> string or_null [@@js.get "search"]
    val set_search: t -> string or_null -> unit [@@js.set "search"]
    val get_slashes: t -> bool or_null [@@js.get "slashes"]
    val set_slashes: t -> bool or_null -> unit [@@js.set "slashes"]
    val get_port: t -> string or_null [@@js.get "port"]
    val set_port: t -> string or_null -> unit [@@js.set "port"]
    val get_query: t -> ParsedUrlQuery.t_0 or_string or_null [@@js.get "query"]
    val set_query: t -> ParsedUrlQuery.t_0 or_string or_null -> unit [@@js.set "query"]
  end
  module[@js.scope "UrlWithParsedQuery"] UrlWithParsedQuery : sig
    type t = url_UrlWithParsedQuery
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_query: t -> ParsedUrlQuery.t_0 [@@js.get "query"]
    val set_query: t -> ParsedUrlQuery.t_0 -> unit [@@js.set "query"]
    val cast: t -> url_Url [@@js.cast]
  end
  module[@js.scope "UrlWithStringQuery"] UrlWithStringQuery : sig
    type t = url_UrlWithStringQuery
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_query: t -> string or_null [@@js.get "query"]
    val set_query: t -> string or_null -> unit [@@js.set "query"]
    val cast: t -> url_Url [@@js.cast]
  end
  (** @deprecated since v11.0.0 - Use the WHATWG URL API. *)
  val parse: urlStr:string -> url_UrlWithStringQuery [@@js.global "parse"]
  (** @deprecated since v11.0.0 - Use the WHATWG URL API. *)
  val parse: urlStr:string -> parseQueryString:([`L_b_false] [@js.enum]) or_undefined -> ?slashesDenoteHost:bool -> unit -> url_UrlWithStringQuery [@@js.global "parse"]
  (** @deprecated since v11.0.0 - Use the WHATWG URL API. *)
  val parse: urlStr:string -> parseQueryString:([`L_b_true] [@js.enum]) -> ?slashesDenoteHost:bool -> unit -> url_UrlWithParsedQuery [@@js.global "parse"]
  (** @deprecated since v11.0.0 - Use the WHATWG URL API. *)
  val parse: urlStr:string -> parseQueryString:bool -> ?slashesDenoteHost:bool -> unit -> url_Url [@@js.global "parse"]
  val format: url:url_URL -> ?options:url_URLFormatOptions -> unit -> string [@@js.global "format"]
  (** @deprecated since v11.0.0 - Use the WHATWG URL API. *)
  val format: urlObject:url_UrlObject or_string -> string [@@js.global "format"]
  (** @deprecated since v11.0.0 - Use the WHATWG URL API. *)
  val resolve: from:string -> to_:string -> string [@@js.global "resolve"]
  val domainToASCII: domain:string -> string [@@js.global "domainToASCII"]
  val domainToUnicode: domain:string -> string [@@js.global "domainToUnicode"]
  (**
    This function ensures the correct decodings of percent-encoded characters as
    well as ensuring a cross-platform valid absolute path string.
    @param url The file URL string or URL object to convert to a path.
  *)
  val fileURLToPath: url:url_URL or_string -> string [@@js.global "fileURLToPath"]
  (**
    This function ensures that path is resolved absolutely, and that the URL
    control characters are correctly encoded when converting into a File URL.
    @param url The path to convert to a File URL.
  *)
  val pathToFileURL: url:string -> url_URL [@@js.global "pathToFileURL"]
  module[@js.scope "URLFormatOptions"] URLFormatOptions : sig
    type t = url_URLFormatOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_auth: t -> bool [@@js.get "auth"]
    val set_auth: t -> bool -> unit [@@js.set "auth"]
    val get_fragment: t -> bool [@@js.get "fragment"]
    val set_fragment: t -> bool -> unit [@@js.set "fragment"]
    val get_search: t -> bool [@@js.get "search"]
    val set_search: t -> bool -> unit [@@js.set "search"]
    val get_unicode: t -> bool [@@js.get "unicode"]
    val set_unicode: t -> bool -> unit [@@js.set "unicode"]
  end
  module[@js.scope "URL"] URL : sig
    type t = url_URL
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: input:string -> ?base:t or_string -> unit -> t [@@js.create]
    val get_hash: t -> string [@@js.get "hash"]
    val set_hash: t -> string -> unit [@@js.set "hash"]
    val get_host: t -> string [@@js.get "host"]
    val set_host: t -> string -> unit [@@js.set "host"]
    val get_hostname: t -> string [@@js.get "hostname"]
    val set_hostname: t -> string -> unit [@@js.set "hostname"]
    val get_href: t -> string [@@js.get "href"]
    val set_href: t -> string -> unit [@@js.set "href"]
    val get_origin: t -> string [@@js.get "origin"]
    val get_password: t -> string [@@js.get "password"]
    val set_password: t -> string -> unit [@@js.set "password"]
    val get_pathname: t -> string [@@js.get "pathname"]
    val set_pathname: t -> string -> unit [@@js.set "pathname"]
    val get_port: t -> string [@@js.get "port"]
    val set_port: t -> string -> unit [@@js.set "port"]
    val get_protocol: t -> string [@@js.get "protocol"]
    val set_protocol: t -> string -> unit [@@js.set "protocol"]
    val get_search: t -> string [@@js.get "search"]
    val set_search: t -> string -> unit [@@js.set "search"]
    val get_searchParams: t -> url_URLSearchParams [@@js.get "searchParams"]
    val get_username: t -> string [@@js.get "username"]
    val set_username: t -> string -> unit [@@js.set "username"]
    val toString: t -> string [@@js.call "toString"]
    val toJSON: t -> string [@@js.call "toJSON"]
  end
  module[@js.scope "URLSearchParams"] URLSearchParams : sig
    type t = url_URLSearchParams
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?init:(t, (string * string) Iterable.t_1, string list or_string _NodeJS_Dict, (string * string) list) union4 or_string -> unit -> t [@@js.create]
    val append: t -> name:string -> value:string -> unit [@@js.call "append"]
    val delete: t -> name:string -> unit [@@js.call "delete"]
    val entries: t -> (string * string) IterableIterator.t_1 [@@js.call "entries"]
    val forEach: t -> callback:(value:string -> name:string -> searchParams:t -> unit) -> unit [@@js.call "forEach"]
    val get_: t -> name:string -> string or_null [@@js.call "get"]
    val getAll: t -> name:string -> string list [@@js.call "getAll"]
    val has: t -> name:string -> bool [@@js.call "has"]
    val keys: t -> string IterableIterator.t_1 [@@js.call "keys"]
    val set_: t -> name:string -> value:string -> unit [@@js.call "set"]
    val sort: t -> unit [@@js.call "sort"]
    val toString: t -> string [@@js.call "toString"]
    val values: t -> string IterableIterator.t_1 [@@js.call "values"]
    val _Symbol_iterator_: t -> (string * string) IterableIterator.t_1 [@@js.call "[Symbol.iterator]"]
    val cast: t -> (string * string) Iterable.t_1 [@@js.cast]
  end
end
module Node_util : sig
  (* export * from 'util'; *)
end
module[@js.scope "util"] Util : sig
  module[@js.scope "InspectOptions"] InspectOptions : sig
    type t = util_InspectOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> _NodeJS_InspectOptions [@@js.cast]
  end
  module Style : sig
    type t = util_Style
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "CustomInspectFunction"] CustomInspectFunction : sig
    type t = util_CustomInspectFunction
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> depth:float -> options:util_InspectOptionsStylized -> string [@@js.apply]
  end
  module[@js.scope "InspectOptionsStylized"] InspectOptionsStylized : sig
    type t = util_InspectOptionsStylized
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val stylize: t -> text:string -> styleType:util_Style -> string [@@js.call "stylize"]
    val cast: t -> util_InspectOptions [@@js.cast]
  end
  val format: ?format:any -> param:(any list [@js.variadic]) -> string [@@js.global "format"]
  val formatWithOptions: inspectOptions:util_InspectOptions -> ?format:any -> param:(any list [@js.variadic]) -> string [@@js.global "formatWithOptions"]
  (** @deprecated since v0.11.3 - use a third party module instead. *)
  val log: string:string -> unit [@@js.global "log"]
  val inspect: object_:any -> ?showHidden:bool -> ?depth:float or_null -> ?color:bool -> unit -> string [@@js.global "inspect"]
  val inspect: object_:any -> options:util_InspectOptions -> string [@@js.global "inspect"]
  module[@js.scope "inspect"] Inspect : sig
    val colors: (float * float) _NodeJS_Dict [@@js.global "colors"]
    val styles: (* FIXME: unknown type '{
                [K in Style]: string
            }' *)any [@@js.global "styles"]
    val defaultOptions: util_InspectOptions [@@js.global "defaultOptions"]
    (** Allows changing inspect settings from the repl. *)
    val replDefaults: util_InspectOptions [@@js.global "replDefaults"]
    val custom: (* FIXME: unknown type 'unique symbol' *)any [@@js.global "custom"]
  end
  (** @deprecated since v4.0.0 - use `Array.isArray()` instead. *)
  val isArray: object_:any -> bool [@@js.global "isArray"]
  (** @deprecated since v4.0.0 - use `util.types.isRegExp()` instead. *)
  val isRegExp: object_:any -> bool [@@js.global "isRegExp"]
  (** @deprecated since v4.0.0 - use `util.types.isDate()` instead. *)
  val isDate: object_:any -> bool [@@js.global "isDate"]
  (** @deprecated since v4.0.0 - use `util.types.isNativeError()` instead. *)
  val isError: object_:any -> bool [@@js.global "isError"]
  val inherits: constructor:any -> superConstructor:any -> unit [@@js.global "inherits"]
  val debuglog: key:string -> (msg:string -> param:(any list [@js.variadic]) -> unit [@js.dummy]) [@@js.global "debuglog"]
  (** @deprecated since v4.0.0 - use `typeof value === 'boolean'` instead. *)
  val isBoolean: object_:any -> bool [@@js.global "isBoolean"]
  (** @deprecated since v4.0.0 - use `Buffer.isBuffer()` instead. *)
  val isBuffer: object_:any -> bool [@@js.global "isBuffer"]
  (** @deprecated since v4.0.0 - use `typeof value === 'function'` instead. *)
  val isFunction: object_:any -> bool [@@js.global "isFunction"]
  (** @deprecated since v4.0.0 - use `value === null` instead. *)
  val isNull: object_:any -> bool [@@js.global "isNull"]
  (** @deprecated since v4.0.0 - use `value === null || value === undefined` instead. *)
  val isNullOrUndefined: object_:any -> bool [@@js.global "isNullOrUndefined"]
  (** @deprecated since v4.0.0 - use `typeof value === 'number'` instead. *)
  val isNumber: object_:any -> bool [@@js.global "isNumber"]
  (** @deprecated since v4.0.0 - use `value !== null && typeof value === 'object'` instead. *)
  val isObject: object_:any -> bool [@@js.global "isObject"]
  (** @deprecated since v4.0.0 - use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead. *)
  val isPrimitive: object_:any -> bool [@@js.global "isPrimitive"]
  (** @deprecated since v4.0.0 - use `typeof value === 'string'` instead. *)
  val isString: object_:any -> bool [@@js.global "isString"]
  (** @deprecated since v4.0.0 - use `typeof value === 'symbol'` instead. *)
  val isSymbol: object_:any -> bool [@@js.global "isSymbol"]
  (** @deprecated since v4.0.0 - use `value === undefined` instead. *)
  val isUndefined: object_:any -> bool [@@js.global "isUndefined"]
  val deprecate: fn:'T -> message:string -> ?code:string -> unit -> 'T [@@js.global "deprecate"]
  val isDeepStrictEqual: val1:any -> val2:any -> bool [@@js.global "isDeepStrictEqual"]
  val callbackify: fn:(unit -> unit Promise.t_1) -> (callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(unit -> 'TResult Promise.t_1) -> (callback:(err:_NodeJS_ErrnoException -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> unit Promise.t_1) -> (arg1:'T1 -> callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> 'TResult Promise.t_1) -> (arg1:'T1 -> callback:(err:_NodeJS_ErrnoException -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> unit Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> 'TResult Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> callback:(err:_NodeJS_ErrnoException or_null -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> unit Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> 'TResult Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> callback:(err:_NodeJS_ErrnoException or_null -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> unit Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> 'TResult Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> callback:(err:_NodeJS_ErrnoException or_null -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> unit Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> 'TResult Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> callback:(err:_NodeJS_ErrnoException or_null -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> arg6:'T6 -> unit Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> arg6:'T6 -> callback:(err:_NodeJS_ErrnoException -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  val callbackify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> arg6:'T6 -> 'TResult Promise.t_1) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> arg6:'T6 -> callback:(err:_NodeJS_ErrnoException or_null -> result:'TResult -> unit) -> unit [@js.dummy]) [@@js.global "callbackify"]
  module[@js.scope "CustomPromisifyLegacy"] CustomPromisifyLegacy : sig
    type 'TCustom t = 'TCustom util_CustomPromisifyLegacy
    val t_to_js: ('TCustom -> Ojs.t) -> 'TCustom t -> Ojs.t
    val t_of_js: (Ojs.t -> 'TCustom) -> Ojs.t -> 'TCustom t
    type 'TCustom t_1 = 'TCustom t
    val t_1_to_js: ('TCustom -> Ojs.t) -> 'TCustom t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'TCustom) -> Ojs.t -> 'TCustom t_1
    val get___promisify__: 'TCustom t -> 'TCustom [@@js.get "__promisify__"]
    val set___promisify__: 'TCustom t -> 'TCustom -> unit [@@js.set "__promisify__"]
    val cast: 'TCustom t -> untyped_function [@@js.cast]
  end
  module[@js.scope "CustomPromisifySymbol"] CustomPromisifySymbol : sig
    type 'TCustom t = 'TCustom util_CustomPromisifySymbol
    val t_to_js: ('TCustom -> Ojs.t) -> 'TCustom t -> Ojs.t
    val t_of_js: (Ojs.t -> 'TCustom) -> Ojs.t -> 'TCustom t
    type 'TCustom t_1 = 'TCustom t
    val t_1_to_js: ('TCustom -> Ojs.t) -> 'TCustom t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'TCustom) -> Ojs.t -> 'TCustom t_1
    val get__promisify_custom_: 'TCustom t -> 'TCustom [@@js.get "[promisify.custom]"]
    val set__promisify_custom_: 'TCustom t -> 'TCustom -> unit [@@js.set "[promisify.custom]"]
    val cast: 'TCustom t -> untyped_function [@@js.cast]
  end
  module CustomPromisify : sig
    type 'TCustom t = 'TCustom util_CustomPromisify
    val t_to_js: ('TCustom -> Ojs.t) -> 'TCustom t -> Ojs.t
    val t_of_js: (Ojs.t -> 'TCustom) -> Ojs.t -> 'TCustom t
    type 'TCustom t_1 = 'TCustom t
    val t_1_to_js: ('TCustom -> Ojs.t) -> 'TCustom t_1 -> Ojs.t
    val t_1_of_js: (Ojs.t -> 'TCustom) -> Ojs.t -> 'TCustom t_1
  end
  val promisify: fn:'TCustom util_CustomPromisify -> 'TCustom [@@js.global "promisify"]
  val promisify: fn:(callback:(err:any -> result:'TResult -> unit) -> unit) -> (unit -> 'TResult Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(callback:(?err:any -> unit -> unit) -> unit) -> (unit -> unit Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> callback:(err:any -> result:'TResult -> unit) -> unit) -> (arg1:'T1 -> 'TResult Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> callback:(?err:any -> unit -> unit) -> unit) -> (arg1:'T1 -> unit Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> callback:(err:any -> result:'TResult -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> 'TResult Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> callback:(?err:any -> unit -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> unit Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> callback:(err:any -> result:'TResult -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> 'TResult Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> callback:(?err:any -> unit -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> unit Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> callback:(err:any -> result:'TResult -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> 'TResult Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> callback:(?err:any -> unit -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> unit Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> callback:(err:any -> result:'TResult -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> 'TResult Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:(arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> callback:(?err:any -> unit -> unit) -> unit) -> (arg1:'T1 -> arg2:'T2 -> arg3:'T3 -> arg4:'T4 -> arg5:'T5 -> unit Promise.t_1 [@js.dummy]) [@@js.global "promisify"]
  val promisify: fn:untyped_function -> untyped_function [@@js.global "promisify"]
  module[@js.scope "promisify"] Promisify : sig
    val custom: (* FIXME: unknown type 'unique symbol' *)any [@@js.global "custom"]
  end
  module[@js.scope "types"] Types : sig
    val isAnyArrayBuffer: object_:any -> bool [@@js.global "isAnyArrayBuffer"]
    val isArgumentsObject: object_:any -> bool [@@js.global "isArgumentsObject"]
    val isArrayBuffer: object_:any -> bool [@@js.global "isArrayBuffer"]
    val isArrayBufferView: object_:any -> bool [@@js.global "isArrayBufferView"]
    val isAsyncFunction: object_:any -> bool [@@js.global "isAsyncFunction"]
    val isBigInt64Array: value:any -> bool [@@js.global "isBigInt64Array"]
    val isBigUint64Array: value:any -> bool [@@js.global "isBigUint64Array"]
    val isBooleanObject: object_:any -> bool [@@js.global "isBooleanObject"]
    val isBoxedPrimitive: object_:any -> bool [@@js.global "isBoxedPrimitive"]
    val isDataView: object_:any -> bool [@@js.global "isDataView"]
    val isDate: object_:any -> bool [@@js.global "isDate"]
    val isExternal: object_:any -> bool [@@js.global "isExternal"]
    val isFloat32Array: object_:any -> bool [@@js.global "isFloat32Array"]
    val isFloat64Array: object_:any -> bool [@@js.global "isFloat64Array"]
    val isGeneratorFunction: object_:any -> bool [@@js.global "isGeneratorFunction"]
    val isGeneratorObject: object_:any -> bool [@@js.global "isGeneratorObject"]
    val isInt8Array: object_:any -> bool [@@js.global "isInt8Array"]
    val isInt16Array: object_:any -> bool [@@js.global "isInt16Array"]
    val isInt32Array: object_:any -> bool [@@js.global "isInt32Array"]
    val isMap: object_:('T, anonymous_interface_0) union2 -> bool [@@js.global "isMap"]
    val isMapIterator: object_:any -> bool [@@js.global "isMapIterator"]
    val isModuleNamespaceObject: value:any -> bool [@@js.global "isModuleNamespaceObject"]
    val isNativeError: object_:any -> bool [@@js.global "isNativeError"]
    val isNumberObject: object_:any -> bool [@@js.global "isNumberObject"]
    val isPromise: object_:any -> bool [@@js.global "isPromise"]
    val isProxy: object_:any -> bool [@@js.global "isProxy"]
    val isRegExp: object_:any -> bool [@@js.global "isRegExp"]
    val isSet: object_:('T, anonymous_interface_0) union2 -> bool [@@js.global "isSet"]
    val isSetIterator: object_:any -> bool [@@js.global "isSetIterator"]
    val isSharedArrayBuffer: object_:any -> bool [@@js.global "isSharedArrayBuffer"]
    val isStringObject: object_:any -> bool [@@js.global "isStringObject"]
    val isSymbolObject: object_:any -> bool [@@js.global "isSymbolObject"]
    val isTypedArray: object_:any -> bool [@@js.global "isTypedArray"]
    val isUint8Array: object_:any -> bool [@@js.global "isUint8Array"]
    val isUint8ClampedArray: object_:any -> bool [@@js.global "isUint8ClampedArray"]
    val isUint16Array: object_:any -> bool [@@js.global "isUint16Array"]
    val isUint32Array: object_:any -> bool [@@js.global "isUint32Array"]
    val isWeakMap: object_:any -> bool [@@js.global "isWeakMap"]
    val isWeakSet: object_:any -> bool [@@js.global "isWeakSet"]
  end
  module[@js.scope "TextDecoder"] TextDecoder : sig
    type t = util_TextDecoder
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> string [@@js.get "encoding"]
    val get_fatal: t -> bool [@@js.get "fatal"]
    val get_ignoreBOM: t -> bool [@@js.get "ignoreBOM"]
    val create: ?encoding:string -> ?options:anonymous_interface_22 -> unit -> t [@@js.create]
    val decode: t -> ?input:(ArrayBuffer.t_0, _NodeJS_ArrayBufferView) union2 or_null -> ?options:anonymous_interface_52 -> unit -> string [@@js.call "decode"]
  end
  module[@js.scope "EncodeIntoResult"] EncodeIntoResult : sig
    type t = util_EncodeIntoResult
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** The read Unicode code units of input. *)
    (** The read Unicode code units of input. *)
    val get_read: t -> float [@@js.get "read"]
    (** The read Unicode code units of input. *)
    val set_read: t -> float -> unit [@@js.set "read"]
    (** The written UTF-8 bytes of output. *)
    (** The written UTF-8 bytes of output. *)
    val get_written: t -> float [@@js.get "written"]
    (** The written UTF-8 bytes of output. *)
    val set_written: t -> float -> unit [@@js.set "written"]
  end
  module[@js.scope "TextEncoder"] TextEncoder : sig
    type t = util_TextEncoder
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_encoding: t -> string [@@js.get "encoding"]
    val encode: t -> ?input:string -> unit -> Uint8Array.t_0 [@@js.call "encode"]
    val encodeInto: t -> input:string -> output:Uint8Array.t_0 -> util_EncodeIntoResult [@@js.call "encodeInto"]
  end
end
module Node_v8 : sig
  (* export * from 'v8'; *)
end
module[@js.scope "v8"] V8 : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/v8.d.ts } *)
  module[@js.scope "HeapSpaceInfo"] HeapSpaceInfo : sig
    type t = v8_HeapSpaceInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_space_name: t -> string [@@js.get "space_name"]
    val set_space_name: t -> string -> unit [@@js.set "space_name"]
    val get_space_size: t -> float [@@js.get "space_size"]
    val set_space_size: t -> float -> unit [@@js.set "space_size"]
    val get_space_used_size: t -> float [@@js.get "space_used_size"]
    val set_space_used_size: t -> float -> unit [@@js.set "space_used_size"]
    val get_space_available_size: t -> float [@@js.get "space_available_size"]
    val set_space_available_size: t -> float -> unit [@@js.set "space_available_size"]
    val get_physical_space_size: t -> float [@@js.get "physical_space_size"]
    val set_physical_space_size: t -> float -> unit [@@js.set "physical_space_size"]
  end
  module DoesZapCodeSpaceFlag : sig
    type t = v8_DoesZapCodeSpaceFlag
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "HeapInfo"] HeapInfo : sig
    type t = v8_HeapInfo
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_total_heap_size: t -> float [@@js.get "total_heap_size"]
    val set_total_heap_size: t -> float -> unit [@@js.set "total_heap_size"]
    val get_total_heap_size_executable: t -> float [@@js.get "total_heap_size_executable"]
    val set_total_heap_size_executable: t -> float -> unit [@@js.set "total_heap_size_executable"]
    val get_total_physical_size: t -> float [@@js.get "total_physical_size"]
    val set_total_physical_size: t -> float -> unit [@@js.set "total_physical_size"]
    val get_total_available_size: t -> float [@@js.get "total_available_size"]
    val set_total_available_size: t -> float -> unit [@@js.set "total_available_size"]
    val get_used_heap_size: t -> float [@@js.get "used_heap_size"]
    val set_used_heap_size: t -> float -> unit [@@js.set "used_heap_size"]
    val get_heap_size_limit: t -> float [@@js.get "heap_size_limit"]
    val set_heap_size_limit: t -> float -> unit [@@js.set "heap_size_limit"]
    val get_malloced_memory: t -> float [@@js.get "malloced_memory"]
    val set_malloced_memory: t -> float -> unit [@@js.set "malloced_memory"]
    val get_peak_malloced_memory: t -> float [@@js.get "peak_malloced_memory"]
    val set_peak_malloced_memory: t -> float -> unit [@@js.set "peak_malloced_memory"]
    val get_does_zap_garbage: t -> v8_DoesZapCodeSpaceFlag [@@js.get "does_zap_garbage"]
    val set_does_zap_garbage: t -> v8_DoesZapCodeSpaceFlag -> unit [@@js.set "does_zap_garbage"]
    val get_number_of_native_contexts: t -> float [@@js.get "number_of_native_contexts"]
    val set_number_of_native_contexts: t -> float -> unit [@@js.set "number_of_native_contexts"]
    val get_number_of_detached_contexts: t -> float [@@js.get "number_of_detached_contexts"]
    val set_number_of_detached_contexts: t -> float -> unit [@@js.set "number_of_detached_contexts"]
  end
  module[@js.scope "HeapCodeStatistics"] HeapCodeStatistics : sig
    type t = v8_HeapCodeStatistics
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_code_and_metadata_size: t -> float [@@js.get "code_and_metadata_size"]
    val set_code_and_metadata_size: t -> float -> unit [@@js.set "code_and_metadata_size"]
    val get_bytecode_and_metadata_size: t -> float [@@js.get "bytecode_and_metadata_size"]
    val set_bytecode_and_metadata_size: t -> float -> unit [@@js.set "bytecode_and_metadata_size"]
    val get_external_script_source_size: t -> float [@@js.get "external_script_source_size"]
    val set_external_script_source_size: t -> float -> unit [@@js.set "external_script_source_size"]
  end
  (**
    Returns an integer representing a "version tag" derived from the V8 version, command line flags and detected CPU features.
    This is useful for determining whether a vm.Script cachedData buffer is compatible with this instance of V8.
  *)
  val cachedDataVersionTag: unit -> float [@@js.global "cachedDataVersionTag"]
  val getHeapStatistics: unit -> v8_HeapInfo [@@js.global "getHeapStatistics"]
  val getHeapSpaceStatistics: unit -> v8_HeapSpaceInfo list [@@js.global "getHeapSpaceStatistics"]
  val setFlagsFromString: flags:string -> unit [@@js.global "setFlagsFromString"]
  (**
    Generates a snapshot of the current V8 heap and returns a Readable
    Stream that may be used to read the JSON serialized representation.
    This conversation was marked as resolved by joyeecheung
    This JSON stream format is intended to be used with tools such as
    Chrome DevTools. The JSON schema is undocumented and specific to the
    V8 engine, and may change from one version of V8 to the next.
  *)
  val getHeapSnapshot: unit -> Readable.t_0 [@@js.global "getHeapSnapshot"]
  (**
    @param fileName The file path where the V8 heap snapshot is to be
    saved. If not specified, a file name with the pattern
    `'Heap-$\{yyyymmdd\}-$\{hhmmss\}-$\{pid\}-$\{thread_id\}.heapsnapshot'` will be
    generated, where `\{pid\}` will be the PID of the Node.js process,
    `\{thread_id\}` will be `0` when `writeHeapSnapshot()` is called from
    the main Node.js thread or the id of a worker thread.
  *)
  val writeHeapSnapshot: ?fileName:string -> unit -> string [@@js.global "writeHeapSnapshot"]
  val getHeapCodeStatistics: unit -> v8_HeapCodeStatistics [@@js.global "getHeapCodeStatistics"]
  module[@js.scope "Serializer"] Serializer : sig
    type t = v8_Serializer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Writes out a header, which includes the serialization format version. *)
    val writeHeader: t -> unit [@@js.call "writeHeader"]
    (**
      Serializes a JavaScript value and adds the serialized representation to the internal buffer.
      This throws an error if value cannot be serialized.
    *)
    val writeValue: t -> val_:any -> bool [@@js.call "writeValue"]
    (**
      Returns the stored internal buffer.
      This serializer should not be used once the buffer is released.
      Calling this method results in undefined behavior if a previous write has failed.
    *)
    val releaseBuffer: t -> _Buffer [@@js.call "releaseBuffer"]
    (**
      Marks an ArrayBuffer as having its contents transferred out of band.\
      Pass the corresponding ArrayBuffer in the deserializing context to deserializer.transferArrayBuffer().
    *)
    val transferArrayBuffer: t -> id:float -> arrayBuffer:ArrayBuffer.t_0 -> unit [@@js.call "transferArrayBuffer"]
    (** Write a raw 32-bit unsigned integer. *)
    val writeUint32: t -> value:float -> unit [@@js.call "writeUint32"]
    (** Write a raw 64-bit unsigned integer, split into high and low 32-bit parts. *)
    val writeUint64: t -> hi:float -> lo:float -> unit [@@js.call "writeUint64"]
    (** Write a JS number value. *)
    val writeDouble: t -> value:float -> unit [@@js.call "writeDouble"]
    (**
      Write raw bytes into the serializers internal buffer.
      The deserializer will require a way to compute the length of the buffer.
    *)
    val writeRawBytes: t -> buffer:_NodeJS_TypedArray -> unit [@@js.call "writeRawBytes"]
  end
  (**
    A subclass of `Serializer` that serializes `TypedArray` (in particular `Buffer`) and `DataView` objects as host objects,
    and only stores the part of their underlying `ArrayBuffers` that they are referring to.
  *)
  module[@js.scope "DefaultSerializer"] DefaultSerializer : sig
    type t = v8_DefaultSerializer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> v8_Serializer [@@js.cast]
  end
  module[@js.scope "Deserializer"] Deserializer : sig
    type t = v8_Deserializer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: data:_NodeJS_TypedArray -> t [@@js.create]
    (**
      Reads and validates a header (including the format version).
      May, for example, reject an invalid or unsupported wire format.
      In that case, an Error is thrown.
    *)
    val readHeader: t -> bool [@@js.call "readHeader"]
    (** Deserializes a JavaScript value from the buffer and returns it. *)
    val readValue: t -> any [@@js.call "readValue"]
    (**
      Marks an ArrayBuffer as having its contents transferred out of band.
      Pass the corresponding `ArrayBuffer` in the serializing context to serializer.transferArrayBuffer()
      (or return the id from serializer._getSharedArrayBufferId() in the case of SharedArrayBuffers).
    *)
    val transferArrayBuffer: t -> id:float -> arrayBuffer:ArrayBuffer.t_0 -> unit [@@js.call "transferArrayBuffer"]
    (**
      Reads the underlying wire format version.
      Likely mostly to be useful to legacy code reading old wire format versions.
      May not be called before .readHeader().
    *)
    val getWireFormatVersion: t -> float [@@js.call "getWireFormatVersion"]
    (** Read a raw 32-bit unsigned integer and return it. *)
    val readUint32: t -> float [@@js.call "readUint32"]
    (** Read a raw 64-bit unsigned integer and return it as an array \[hi, lo\] with two 32-bit unsigned integer entries. *)
    val readUint64: t -> (float * float) [@@js.call "readUint64"]
    (** Read a JS number value. *)
    val readDouble: t -> float [@@js.call "readDouble"]
    (**
      Read raw bytes from the deserializers internal buffer.
      The length parameter must correspond to the length of the buffer that was passed to serializer.writeRawBytes().
    *)
    val readRawBytes: t -> length:float -> _Buffer [@@js.call "readRawBytes"]
  end
  (**
    A subclass of `Serializer` that serializes `TypedArray` (in particular `Buffer`) and `DataView` objects as host objects,
    and only stores the part of their underlying `ArrayBuffers` that they are referring to.
  *)
  module[@js.scope "DefaultDeserializer"] DefaultDeserializer : sig
    type t = v8_DefaultDeserializer
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> v8_Deserializer [@@js.cast]
  end
  (** Uses a `DefaultSerializer` to serialize value into a buffer. *)
  val serialize: value:any -> _Buffer [@@js.global "serialize"]
  (** Uses a `DefaultDeserializer` with default options to read a JS value from a buffer. *)
  val deserialize: data:_NodeJS_TypedArray -> any [@@js.global "deserialize"]
end
module Node_vm : sig
  (* export * from 'vm'; *)
end
module[@js.scope "vm"] Vm : sig
  module[@js.scope "Context"] Context : sig
    type t = vm_Context
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> any _NodeJS_Dict [@@js.cast]
  end
  module[@js.scope "BaseOptions"] BaseOptions : sig
    type t = vm_BaseOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Specifies the filename used in stack traces produced by this script.
      Default: `''`.
    *)
    (**
      Specifies the filename used in stack traces produced by this script.
      Default: `''`.
    *)
    val get_filename: t -> string [@@js.get "filename"]
    (**
      Specifies the filename used in stack traces produced by this script.
      Default: `''`.
    *)
    val set_filename: t -> string -> unit [@@js.set "filename"]
    (**
      Specifies the line number offset that is displayed in stack traces produced by this script.
      Default: `0`.
    *)
    (**
      Specifies the line number offset that is displayed in stack traces produced by this script.
      Default: `0`.
    *)
    val get_lineOffset: t -> float [@@js.get "lineOffset"]
    (**
      Specifies the line number offset that is displayed in stack traces produced by this script.
      Default: `0`.
    *)
    val set_lineOffset: t -> float -> unit [@@js.set "lineOffset"]
    (**
      Specifies the column number offset that is displayed in stack traces produced by this script.
      Default: `0`
    *)
    (**
      Specifies the column number offset that is displayed in stack traces produced by this script.
      Default: `0`
    *)
    val get_columnOffset: t -> float [@@js.get "columnOffset"]
    (**
      Specifies the column number offset that is displayed in stack traces produced by this script.
      Default: `0`
    *)
    val set_columnOffset: t -> float -> unit [@@js.set "columnOffset"]
  end
  module[@js.scope "ScriptOptions"] ScriptOptions : sig
    type t = vm_ScriptOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_displayErrors: t -> bool [@@js.get "displayErrors"]
    val set_displayErrors: t -> bool -> unit [@@js.set "displayErrors"]
    val get_timeout: t -> float [@@js.get "timeout"]
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    val get_cachedData: t -> _Buffer [@@js.get "cachedData"]
    val set_cachedData: t -> _Buffer -> unit [@@js.set "cachedData"]
    (** @deprecated in favor of `script.createCachedData()` *)
    (** @deprecated in favor of `script.createCachedData()` *)
    val get_produceCachedData: t -> bool [@@js.get "produceCachedData"]
    (** @deprecated in favor of `script.createCachedData()` *)
    val set_produceCachedData: t -> bool -> unit [@@js.set "produceCachedData"]
    val cast: t -> vm_BaseOptions [@@js.cast]
  end
  module[@js.scope "RunningScriptOptions"] RunningScriptOptions : sig
    type t = vm_RunningScriptOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace.
      Default: `true`.
    *)
    (**
      When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace.
      Default: `true`.
    *)
    val get_displayErrors: t -> bool [@@js.get "displayErrors"]
    (**
      When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace.
      Default: `true`.
    *)
    val set_displayErrors: t -> bool -> unit [@@js.set "displayErrors"]
    (**
      Specifies the number of milliseconds to execute code before terminating execution.
      If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer.
    *)
    (**
      Specifies the number of milliseconds to execute code before terminating execution.
      If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer.
    *)
    val get_timeout: t -> float [@@js.get "timeout"]
    (**
      Specifies the number of milliseconds to execute code before terminating execution.
      If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer.
    *)
    val set_timeout: t -> float -> unit [@@js.set "timeout"]
    (**
      If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received.
      Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that.
      If execution is terminated, an `Error` will be thrown.
      Default: `false`.
    *)
    (**
      If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received.
      Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that.
      If execution is terminated, an `Error` will be thrown.
      Default: `false`.
    *)
    val get_breakOnSigint: t -> bool [@@js.get "breakOnSigint"]
    (**
      If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received.
      Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that.
      If execution is terminated, an `Error` will be thrown.
      Default: `false`.
    *)
    val set_breakOnSigint: t -> bool -> unit [@@js.set "breakOnSigint"]
    (** If set to `afterEvaluate`, microtasks will be run immediately after the script has run. *)
    (** If set to `afterEvaluate`, microtasks will be run immediately after the script has run. *)
    val get_microtaskMode: t -> ([`L_s175_afterEvaluate[@js "afterEvaluate"]] [@js.enum]) [@@js.get "microtaskMode"]
    (** If set to `afterEvaluate`, microtasks will be run immediately after the script has run. *)
    val set_microtaskMode: t -> ([`L_s175_afterEvaluate] [@js.enum]) -> unit [@@js.set "microtaskMode"]
    val cast: t -> vm_BaseOptions [@@js.cast]
  end
  module[@js.scope "CompileFunctionOptions"] CompileFunctionOptions : sig
    type t = vm_CompileFunctionOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** Provides an optional data with V8's code cache data for the supplied source. *)
    (** Provides an optional data with V8's code cache data for the supplied source. *)
    val get_cachedData: t -> _Buffer [@@js.get "cachedData"]
    (** Provides an optional data with V8's code cache data for the supplied source. *)
    val set_cachedData: t -> _Buffer -> unit [@@js.set "cachedData"]
    (**
      Specifies whether to produce new cache data.
      Default: `false`,
    *)
    (**
      Specifies whether to produce new cache data.
      Default: `false`,
    *)
    val get_produceCachedData: t -> bool [@@js.get "produceCachedData"]
    (**
      Specifies whether to produce new cache data.
      Default: `false`,
    *)
    val set_produceCachedData: t -> bool -> unit [@@js.set "produceCachedData"]
    (** The sandbox/context in which the said function should be compiled in. *)
    (** The sandbox/context in which the said function should be compiled in. *)
    val get_parsingContext: t -> vm_Context [@@js.get "parsingContext"]
    (** The sandbox/context in which the said function should be compiled in. *)
    val set_parsingContext: t -> vm_Context -> unit [@@js.set "parsingContext"]
    (** An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling *)
    (** An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling *)
    val get_contextExtensions: t -> untyped_object list [@@js.get "contextExtensions"]
    (** An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling *)
    val set_contextExtensions: t -> untyped_object list -> unit [@@js.set "contextExtensions"]
    val cast: t -> vm_BaseOptions [@@js.cast]
  end
  module[@js.scope "CreateContextOptions"] CreateContextOptions : sig
    type t = vm_CreateContextOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      Human-readable name of the newly created context.
      default: 'VM Context i' Where i is an ascending numerical index of the created context.
    *)
    (**
      Human-readable name of the newly created context.
      default: 'VM Context i' Where i is an ascending numerical index of the created context.
    *)
    val get_name: t -> string [@@js.get "name"]
    (**
      Human-readable name of the newly created context.
      default: 'VM Context i' Where i is an ascending numerical index of the created context.
    *)
    val set_name: t -> string -> unit [@@js.set "name"]
    (**
      Corresponds to the newly created context for display purposes.
      The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary),
      like the value of the `url.origin` property of a URL object.
      Most notably, this string should omit the trailing slash, as that denotes a path.
      default: ''
    *)
    (**
      Corresponds to the newly created context for display purposes.
      The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary),
      like the value of the `url.origin` property of a URL object.
      Most notably, this string should omit the trailing slash, as that denotes a path.
      default: ''
    *)
    val get_origin: t -> string [@@js.get "origin"]
    (**
      Corresponds to the newly created context for display purposes.
      The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary),
      like the value of the `url.origin` property of a URL object.
      Most notably, this string should omit the trailing slash, as that denotes a path.
      default: ''
    *)
    val set_origin: t -> string -> unit [@@js.set "origin"]
    val get_codeGeneration: t -> anonymous_interface_75 [@@js.get "codeGeneration"]
    val set_codeGeneration: t -> anonymous_interface_75 -> unit [@@js.set "codeGeneration"]
    (** If set to `afterEvaluate`, microtasks will be run immediately after the script has run. *)
    (** If set to `afterEvaluate`, microtasks will be run immediately after the script has run. *)
    val get_microtaskMode: t -> ([`L_s175_afterEvaluate[@js "afterEvaluate"]] [@js.enum]) [@@js.get "microtaskMode"]
    (** If set to `afterEvaluate`, microtasks will be run immediately after the script has run. *)
    val set_microtaskMode: t -> ([`L_s175_afterEvaluate] [@js.enum]) -> unit [@@js.set "microtaskMode"]
  end
  module MeasureMemoryMode : sig
    type t = vm_MeasureMemoryMode
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "MeasureMemoryOptions"] MeasureMemoryOptions : sig
    type t = vm_MeasureMemoryOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** default: 'summary' *)
    (** default: 'summary' *)
    val get_mode: t -> vm_MeasureMemoryMode [@@js.get "mode"]
    (** default: 'summary' *)
    val set_mode: t -> vm_MeasureMemoryMode -> unit [@@js.set "mode"]
    val get_context: t -> vm_Context [@@js.get "context"]
    val set_context: t -> vm_Context -> unit [@@js.set "context"]
  end
  module[@js.scope "MemoryMeasurement"] MemoryMeasurement : sig
    type t = vm_MemoryMeasurement
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_total: t -> anonymous_interface_31 [@@js.get "total"]
    val set_total: t -> anonymous_interface_31 -> unit [@@js.set "total"]
  end
  module[@js.scope "Script"] Script : sig
    type t = vm_Script
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: code:string -> ?options:vm_ScriptOptions -> unit -> t [@@js.create]
    val runInContext: t -> contextifiedSandbox:vm_Context -> ?options:vm_RunningScriptOptions -> unit -> any [@@js.call "runInContext"]
    val runInNewContext: t -> ?sandbox:vm_Context -> ?options:vm_RunningScriptOptions -> unit -> any [@@js.call "runInNewContext"]
    val runInThisContext: t -> ?options:vm_RunningScriptOptions -> unit -> any [@@js.call "runInThisContext"]
    val createCachedData: t -> _Buffer [@@js.call "createCachedData"]
    val get_cachedDataRejected: t -> bool [@@js.get "cachedDataRejected"]
    val set_cachedDataRejected: t -> bool -> unit [@@js.set "cachedDataRejected"]
  end
  val createContext: ?sandbox:vm_Context -> ?options:vm_CreateContextOptions -> unit -> vm_Context [@@js.global "createContext"]
  val isContext: sandbox:vm_Context -> bool [@@js.global "isContext"]
  val runInContext: code:string -> contextifiedSandbox:vm_Context -> ?options:vm_RunningScriptOptions or_string -> unit -> any [@@js.global "runInContext"]
  val runInNewContext: code:string -> ?sandbox:vm_Context -> ?options:vm_RunningScriptOptions or_string -> unit -> any [@@js.global "runInNewContext"]
  val runInThisContext: code:string -> ?options:vm_RunningScriptOptions or_string -> unit -> any [@@js.global "runInThisContext"]
  val compileFunction: code:string -> ?params:string list -> ?options:vm_CompileFunctionOptions -> unit -> untyped_function [@@js.global "compileFunction"]
  (**
    Measure the memory known to V8 and used by the current execution context or a specified context.
    
    The format of the object that the returned Promise may resolve with is
    specific to the V8 engine and may change from one version of V8 to the next.
    
    The returned result is different from the statistics returned by
    `v8.getHeapSpaceStatistics()` in that `vm.measureMemory()` measures
    the memory reachable by V8 from a specific context, while
    `v8.getHeapSpaceStatistics()` measures the memory used by an instance
    of V8 engine, which can switch among multiple contexts that reference
    objects in the heap of one engine.
    experimental: 
  *)
  val measureMemory: ?options:vm_MeasureMemoryOptions -> unit -> vm_MemoryMeasurement Promise.t_1 [@@js.global "measureMemory"]
end
module Node_wasi : sig
  (* export * from 'wasi'; *)
end
module[@js.scope "wasi"] Wasi : sig
  module[@js.scope "WASIOptions"] WASIOptions : sig
    type t = wasi_WASIOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      An array of strings that the WebAssembly application will
      see as command line arguments. The first argument is the virtual path to the
      WASI command itself.
    *)
    (**
      An array of strings that the WebAssembly application will
      see as command line arguments. The first argument is the virtual path to the
      WASI command itself.
    *)
    val get_args: t -> string list [@@js.get "args"]
    (**
      An array of strings that the WebAssembly application will
      see as command line arguments. The first argument is the virtual path to the
      WASI command itself.
    *)
    val set_args: t -> string list -> unit [@@js.set "args"]
    (**
      An object similar to `process.env` that the WebAssembly
      application will see as its environment.
    *)
    (**
      An object similar to `process.env` that the WebAssembly
      application will see as its environment.
    *)
    val get_env: t -> untyped_object [@@js.get "env"]
    (**
      An object similar to `process.env` that the WebAssembly
      application will see as its environment.
    *)
    val set_env: t -> untyped_object -> unit [@@js.set "env"]
    (**
      This object represents the WebAssembly application's
      sandbox directory structure. The string keys of `preopens` are treated as
      directories within the sandbox. The corresponding values in `preopens` are
      the real paths to those directories on the host machine.
    *)
    (**
      This object represents the WebAssembly application's
      sandbox directory structure. The string keys of `preopens` are treated as
      directories within the sandbox. The corresponding values in `preopens` are
      the real paths to those directories on the host machine.
    *)
    val get_preopens: t -> string _NodeJS_Dict [@@js.get "preopens"]
    (**
      This object represents the WebAssembly application's
      sandbox directory structure. The string keys of `preopens` are treated as
      directories within the sandbox. The corresponding values in `preopens` are
      the real paths to those directories on the host machine.
    *)
    val set_preopens: t -> string _NodeJS_Dict -> unit [@@js.set "preopens"]
    (**
      By default, WASI applications terminate the Node.js
      process via the `__wasi_proc_exit()` function. Setting this option to `true`
      causes `wasi.start()` to return the exit code rather than terminate the
      process.
      default: false
    *)
    (**
      By default, WASI applications terminate the Node.js
      process via the `__wasi_proc_exit()` function. Setting this option to `true`
      causes `wasi.start()` to return the exit code rather than terminate the
      process.
      default: false
    *)
    val get_returnOnExit: t -> bool [@@js.get "returnOnExit"]
    (**
      By default, WASI applications terminate the Node.js
      process via the `__wasi_proc_exit()` function. Setting this option to `true`
      causes `wasi.start()` to return the exit code rather than terminate the
      process.
      default: false
    *)
    val set_returnOnExit: t -> bool -> unit [@@js.set "returnOnExit"]
    (**
      The file descriptor used as standard input in the WebAssembly application.
      default: 0
    *)
    (**
      The file descriptor used as standard input in the WebAssembly application.
      default: 0
    *)
    val get_stdin: t -> float [@@js.get "stdin"]
    (**
      The file descriptor used as standard input in the WebAssembly application.
      default: 0
    *)
    val set_stdin: t -> float -> unit [@@js.set "stdin"]
    (**
      The file descriptor used as standard output in the WebAssembly application.
      default: 1
    *)
    (**
      The file descriptor used as standard output in the WebAssembly application.
      default: 1
    *)
    val get_stdout: t -> float [@@js.get "stdout"]
    (**
      The file descriptor used as standard output in the WebAssembly application.
      default: 1
    *)
    val set_stdout: t -> float -> unit [@@js.set "stdout"]
    (**
      The file descriptor used as standard error in the WebAssembly application.
      default: 2
    *)
    (**
      The file descriptor used as standard error in the WebAssembly application.
      default: 2
    *)
    val get_stderr: t -> float [@@js.get "stderr"]
    (**
      The file descriptor used as standard error in the WebAssembly application.
      default: 2
    *)
    val set_stderr: t -> float -> unit [@@js.set "stderr"]
  end
  module[@js.scope "WASI"] WASI : sig
    type t = wasi_WASI
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val create: ?options:wasi_WASIOptions -> unit -> t [@@js.create]
    (**
      Attempt to begin execution of `instance` by invoking its `_start()` export.
      If `instance` does not contain a `_start()` export, then `start()` attempts to
      invoke the `__wasi_unstable_reactor_start()` export. If neither of those exports
      is present on `instance`, then `start()` does nothing.
      
      `start()` requires that `instance` exports a \[`WebAssembly.Memory`\]\[\] named
      `memory`. If `instance` does not have a `memory` export an exception is thrown.
      
      If `start()` is called more than once, an exception is thrown.
    *)
    val start: t -> instance:untyped_object -> unit [@@js.call "start"]
    (**
      Attempt to initialize `instance` as a WASI reactor by invoking its `_initialize()` export, if it is present.
      If `instance` contains a `_start()` export, then an exception is thrown.
      
      `start()` requires that `instance` exports a \[`WebAssembly.Memory`\]\[\] named
      `memory`. If `instance` does not have a `memory` export an exception is thrown.
      
      If `initialize()` is called more than once, an exception is thrown.
    *)
    val initialize: t -> instance:untyped_object -> unit [@@js.call "initialize"]
    (**
      Is an object that implements the WASI system call API. This object
      should be passed as the `wasi_snapshot_preview1` import during the instantiation of a
      \[`WebAssembly.Instance`\]\[\].
    *)
    val get_wasiImport: t -> any _NodeJS_Dict [@@js.get "wasiImport"]
  end
end
module Node_worker_threads : sig
  (* export * from 'worker_threads'; *)
end
module[@js.scope "worker_threads"] Worker_threads : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:vm
    clause = ES6Import ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/worker_threads.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:events
    clause = NamespaceImport ([object Object])
    loc = line 7, col 5 of node_modules/@types/node/worker_threads.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = ES6Import ([object Object])
    loc = line 8, col 5 of node_modules/@types/node/worker_threads.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:url
    clause = ES6Import ([object Object])
    loc = line 9, col 5 of node_modules/@types/node/worker_threads.d.ts } *)
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:fs/promises
    clause = ES6Import ([object Object])
    loc = line 10, col 5 of node_modules/@types/node/worker_threads.d.ts } *)
  val isMainThread: bool [@@js.global "isMainThread"]
  val parentPort: worker_threads_MessagePort or_null [@@js.global "parentPort"]
  val resourceLimits: worker_threads_ResourceLimits [@@js.global "resourceLimits"]
  val share_env: (* FIXME: unknown type 'unique symbol' *)any [@@js.global "SHARE_ENV"]
  val threadId: float [@@js.global "threadId"]
  val workerData: any [@@js.global "workerData"]
  module[@js.scope "MessageChannel"] MessageChannel : sig
    type t = worker_threads_MessageChannel
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_port1: t -> worker_threads_MessagePort [@@js.get "port1"]
    val get_port2: t -> worker_threads_MessagePort [@@js.get "port2"]
  end
  module TransferListItem : sig
    type t = worker_threads_TransferListItem
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "MessagePort"] MessagePort : sig
    type t = worker_threads_MessagePort
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val close: t -> unit [@@js.call "close"]
    val postMessage: t -> value:any -> ?transferList:worker_threads_TransferListItem list -> unit -> unit [@@js.call "postMessage"]
    val ref: t -> unit [@@js.call "ref"]
    val unref: t -> unit [@@js.call "unref"]
    val start: t -> unit [@@js.call "start"]
    val addListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val addListener': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "addListener"]
    val addListener'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    val addListener''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s191_close] [@js.enum]) -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s251_message] [@js.enum]) -> value:any -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s252_messageerror] [@js.enum]) -> error:Error.t_0 -> bool [@@js.call "emit"]
    val emit''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val removeListener: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
    val removeListener': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "removeListener"]
    val removeListener'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "removeListener"]
    val removeListener''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "removeListener"]
    val off: t -> event:([`L_s191_close] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "off"]
    val off': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "off"]
    val off'': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "off"]
    val off''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "off"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  module[@js.scope "WorkerOptions"] WorkerOptions : sig
    type t = worker_threads_WorkerOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (**
      List of arguments which would be stringified and appended to
      `process.argv` in the worker. This is mostly similar to the `workerData`
      but the values will be available on the global `process.argv` as if they
      were passed as CLI options to the script.
    *)
    (**
      List of arguments which would be stringified and appended to
      `process.argv` in the worker. This is mostly similar to the `workerData`
      but the values will be available on the global `process.argv` as if they
      were passed as CLI options to the script.
    *)
    val get_argv: t -> any list [@@js.get "argv"]
    (**
      List of arguments which would be stringified and appended to
      `process.argv` in the worker. This is mostly similar to the `workerData`
      but the values will be available on the global `process.argv` as if they
      were passed as CLI options to the script.
    *)
    val set_argv: t -> any list -> unit [@@js.set "argv"]
    val get_env: t -> (string _NodeJS_Dict, (* FIXME: unknown type 'unique symbol' *)any) union2 [@@js.get "env"]
    val set_env: t -> (string _NodeJS_Dict, (* FIXME: unknown type 'unique symbol' *)any) union2 -> unit [@@js.set "env"]
    val get_eval: t -> bool [@@js.get "eval"]
    val set_eval: t -> bool -> unit [@@js.set "eval"]
    val get_workerData: t -> any [@@js.get "workerData"]
    val set_workerData: t -> any -> unit [@@js.set "workerData"]
    val get_stdin: t -> bool [@@js.get "stdin"]
    val set_stdin: t -> bool -> unit [@@js.set "stdin"]
    val get_stdout: t -> bool [@@js.get "stdout"]
    val set_stdout: t -> bool -> unit [@@js.set "stdout"]
    val get_stderr: t -> bool [@@js.get "stderr"]
    val set_stderr: t -> bool -> unit [@@js.set "stderr"]
    val get_execArgv: t -> string list [@@js.get "execArgv"]
    val set_execArgv: t -> string list -> unit [@@js.set "execArgv"]
    val get_resourceLimits: t -> worker_threads_ResourceLimits [@@js.get "resourceLimits"]
    val set_resourceLimits: t -> worker_threads_ResourceLimits -> unit [@@js.set "resourceLimits"]
    (** Additional data to send in the first worker message. *)
    (** Additional data to send in the first worker message. *)
    val get_transferList: t -> worker_threads_TransferListItem list [@@js.get "transferList"]
    (** Additional data to send in the first worker message. *)
    val set_transferList: t -> worker_threads_TransferListItem list -> unit [@@js.set "transferList"]
    val get_trackUnmanagedFds: t -> bool [@@js.get "trackUnmanagedFds"]
    val set_trackUnmanagedFds: t -> bool -> unit [@@js.set "trackUnmanagedFds"]
  end
  module[@js.scope "ResourceLimits"] ResourceLimits : sig
    type t = worker_threads_ResourceLimits
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** The maximum size of a heap space for recently created objects. *)
    (** The maximum size of a heap space for recently created objects. *)
    val get_maxYoungGenerationSizeMb: t -> float [@@js.get "maxYoungGenerationSizeMb"]
    (** The maximum size of a heap space for recently created objects. *)
    val set_maxYoungGenerationSizeMb: t -> float -> unit [@@js.set "maxYoungGenerationSizeMb"]
    (** The maximum size of the main heap in MB. *)
    (** The maximum size of the main heap in MB. *)
    val get_maxOldGenerationSizeMb: t -> float [@@js.get "maxOldGenerationSizeMb"]
    (** The maximum size of the main heap in MB. *)
    val set_maxOldGenerationSizeMb: t -> float -> unit [@@js.set "maxOldGenerationSizeMb"]
    (** The size of a pre-allocated memory range used for generated code. *)
    (** The size of a pre-allocated memory range used for generated code. *)
    val get_codeRangeSizeMb: t -> float [@@js.get "codeRangeSizeMb"]
    (** The size of a pre-allocated memory range used for generated code. *)
    val set_codeRangeSizeMb: t -> float -> unit [@@js.set "codeRangeSizeMb"]
    (**
      The default maximum stack size for the thread. Small values may lead to unusable Worker instances.
      default: 4
    *)
    (**
      The default maximum stack size for the thread. Small values may lead to unusable Worker instances.
      default: 4
    *)
    val get_stackSizeMb: t -> float [@@js.get "stackSizeMb"]
    (**
      The default maximum stack size for the thread. Small values may lead to unusable Worker instances.
      default: 4
    *)
    val set_stackSizeMb: t -> float -> unit [@@js.set "stackSizeMb"]
  end
  module[@js.scope "Worker"] Worker : sig
    type t = worker_threads_Worker
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val get_stdin: t -> Writable.t_0 or_null [@@js.get "stdin"]
    val get_stdout: t -> Readable.t_0 [@@js.get "stdout"]
    val get_stderr: t -> Readable.t_0 [@@js.get "stderr"]
    val get_threadId: t -> float [@@js.get "threadId"]
    val get_resourceLimits: t -> worker_threads_ResourceLimits [@@js.get "resourceLimits"]
    (**
      @param filename The path to the Workers main script or module.
      Must be either an absolute path or a relative path (i.e. relative to the current working directory) starting with ./ or ../,
      or a WHATWG URL object using file: protocol. If options.eval is true, this is a string containing JavaScript code rather than a path.
    *)
    val create: filename:URL.t_0 or_string -> ?options:worker_threads_WorkerOptions -> unit -> t [@@js.create]
    val postMessage: t -> value:any -> ?transferList:worker_threads_TransferListItem list -> unit -> unit [@@js.call "postMessage"]
    val ref: t -> unit [@@js.call "ref"]
    val unref: t -> unit [@@js.call "unref"]
    (**
      Stop all JavaScript execution in the worker thread as soon as possible.
      Returns a Promise for the exit code that is fulfilled when the `exit` event is emitted.
    *)
    val terminate: t -> float Promise.t_1 [@@js.call "terminate"]
    (**
      Returns a readable stream for a V8 snapshot of the current state of the Worker.
      See \[`v8.getHeapSnapshot()`\]\[\] for more details.
      
      If the Worker thread is no longer running, which may occur before the
      \[`'exit'` event\]\[\] is emitted, the returned `Promise` will be rejected
      immediately with an \[`ERR_WORKER_NOT_RUNNING`\]\[\] error
    *)
    val getHeapSnapshot: t -> Readable.t_0 Promise.t_1 [@@js.call "getHeapSnapshot"]
    val addListener: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    val addListener': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "addListener"]
    val addListener'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "addListener"]
    val addListener''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "addListener"]
    val addListener'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "addListener"]
    val addListener''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "addListener"]
    val emit: t -> event:([`L_s213_error] [@js.enum]) -> err:Error.t_0 -> bool [@@js.call "emit"]
    val emit': t -> event:([`L_s214_exit] [@js.enum]) -> exitCode:float -> bool [@@js.call "emit"]
    val emit'': t -> event:([`L_s251_message] [@js.enum]) -> value:any -> bool [@@js.call "emit"]
    val emit''': t -> event:([`L_s252_messageerror] [@js.enum]) -> error:Error.t_0 -> bool [@@js.call "emit"]
    val emit'''': t -> event:([`L_s264_online] [@js.enum]) -> bool [@@js.call "emit"]
    val emit''''': t -> event:symbol or_string -> args:(any list [@js.variadic]) -> bool [@@js.call "emit"]
    val on: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "on"]
    val on'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "on"]
    val on''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "on"]
    val on'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "on"]
    val on''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "on"]
    val once: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "once"]
    val once'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "once"]
    val once''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "once"]
    val once'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "once"]
    val once''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "once"]
    val prependListener: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "prependListener"]
    val prependListener'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "prependListener"]
    val prependListener''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependListener"]
    val prependListener'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependListener"]
    val prependListener''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependListener"]
    val prependOnceListener: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "prependOnceListener"]
    val prependOnceListener''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "prependOnceListener"]
    val removeListener: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "removeListener"]
    val removeListener': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "removeListener"]
    val removeListener'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "removeListener"]
    val removeListener''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "removeListener"]
    val removeListener'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "removeListener"]
    val removeListener''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "removeListener"]
    val off: t -> event:([`L_s213_error] [@js.enum]) -> listener:(err:Error.t_0 -> unit) -> t [@@js.call "off"]
    val off': t -> event:([`L_s214_exit] [@js.enum]) -> listener:(exitCode:float -> unit) -> t [@@js.call "off"]
    val off'': t -> event:([`L_s251_message] [@js.enum]) -> listener:(value:any -> unit) -> t [@@js.call "off"]
    val off''': t -> event:([`L_s252_messageerror] [@js.enum]) -> listener:(error:Error.t_0 -> unit) -> t [@@js.call "off"]
    val off'''': t -> event:([`L_s264_online] [@js.enum]) -> listener:(unit -> unit) -> t [@@js.call "off"]
    val off''''': t -> event:symbol or_string -> listener:(args:(any list [@js.variadic]) -> unit) -> t [@@js.call "off"]
    val cast: t -> EventEmitter.t_0 [@@js.cast]
  end
  (**
    Mark an object as not transferable.
    If `object` occurs in the transfer list of a `port.postMessage()` call, it will be ignored.
    
    In particular, this makes sense for objects that can be cloned, rather than transferred,
    and which are used by other objects on the sending side. For example, Node.js marks
    the `ArrayBuffer`s it uses for its Buffer pool with this.
    
    This operation cannot be undone.
  *)
  val markAsUntransferable: object_:untyped_object -> unit [@@js.global "markAsUntransferable"]
  (**
    Transfer a `MessagePort` to a different `vm` Context. The original `port`
    object will be rendered unusable, and the returned `MessagePort` instance will
    take its place.
    
    The returned `MessagePort` will be an object in the target context, and will
    inherit from its global `Object` class. Objects passed to the
    `port.onmessage()` listener will also be created in the target context
    and inherit from its global `Object` class.
    
    However, the created `MessagePort` will no longer inherit from
    `EventEmitter`, and only `port.onmessage()` can be used to receive
    events using it.
  *)
  val moveMessagePortToContext: port:worker_threads_MessagePort -> context:Context.t_0 -> worker_threads_MessagePort [@@js.global "moveMessagePortToContext"]
  (**
    Receive a single message from a given `MessagePort`. If no message is available,
    `undefined` is returned, otherwise an object with a single `message` property
    that contains the message payload, corresponding to the oldest message in the
    `MessagePort`s queue.
  *)
  val receiveMessageOnPort: port:worker_threads_MessagePort -> anonymous_interface_32 or_undefined [@@js.global "receiveMessageOnPort"]
end
module Node_zlib : sig
  (* export * from 'zlib'; *)
end
module[@js.scope "zlib"] Zlib : sig
  (* { comments = []
    isTypeOnly = false
    isExported = No
    moduleSpecifier = node:stream
    clause = NamespaceImport ([object Object])
    loc = line 6, col 5 of node_modules/@types/node/zlib.d.ts } *)
  module[@js.scope "ZlibOptions"] ZlibOptions : sig
    type t = zlib_ZlibOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** default: constants.Z_NO_FLUSH *)
    (** default: constants.Z_NO_FLUSH *)
    val get_flush: t -> float [@@js.get "flush"]
    (** default: constants.Z_NO_FLUSH *)
    val set_flush: t -> float -> unit [@@js.set "flush"]
    (** default: constants.Z_FINISH *)
    (** default: constants.Z_FINISH *)
    val get_finishFlush: t -> float [@@js.get "finishFlush"]
    (** default: constants.Z_FINISH *)
    val set_finishFlush: t -> float -> unit [@@js.set "finishFlush"]
    (** default: 16*1024 *)
    (** default: 16*1024 *)
    val get_chunkSize: t -> float [@@js.get "chunkSize"]
    (** default: 16*1024 *)
    val set_chunkSize: t -> float -> unit [@@js.set "chunkSize"]
    val get_windowBits: t -> float [@@js.get "windowBits"]
    val set_windowBits: t -> float -> unit [@@js.set "windowBits"]
    val get_level: t -> float [@@js.get "level"]
    val set_level: t -> float -> unit [@@js.set "level"]
    val get_memLevel: t -> float [@@js.get "memLevel"]
    val set_memLevel: t -> float -> unit [@@js.set "memLevel"]
    val get_strategy: t -> float [@@js.get "strategy"]
    val set_strategy: t -> float -> unit [@@js.set "strategy"]
    val get_dictionary: t -> (ArrayBuffer.t_0, _NodeJS_ArrayBufferView) union2 [@@js.get "dictionary"]
    val set_dictionary: t -> (ArrayBuffer.t_0, _NodeJS_ArrayBufferView) union2 -> unit [@@js.set "dictionary"]
    val get_info: t -> bool [@@js.get "info"]
    val set_info: t -> bool -> unit [@@js.set "info"]
    val get_maxOutputLength: t -> float [@@js.get "maxOutputLength"]
    val set_maxOutputLength: t -> float -> unit [@@js.set "maxOutputLength"]
  end
  module[@js.scope "BrotliOptions"] BrotliOptions : sig
    type t = zlib_BrotliOptions
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** default: constants.BROTLI_OPERATION_PROCESS *)
    (** default: constants.BROTLI_OPERATION_PROCESS *)
    val get_flush: t -> float [@@js.get "flush"]
    (** default: constants.BROTLI_OPERATION_PROCESS *)
    val set_flush: t -> float -> unit [@@js.set "flush"]
    (** default: constants.BROTLI_OPERATION_FINISH *)
    (** default: constants.BROTLI_OPERATION_FINISH *)
    val get_finishFlush: t -> float [@@js.get "finishFlush"]
    (** default: constants.BROTLI_OPERATION_FINISH *)
    val set_finishFlush: t -> float -> unit [@@js.set "finishFlush"]
    (** default: 16*1024 *)
    (** default: 16*1024 *)
    val get_chunkSize: t -> float [@@js.get "chunkSize"]
    (** default: 16*1024 *)
    val set_chunkSize: t -> float -> unit [@@js.set "chunkSize"]
    val get_params: t -> anonymous_interface_72 [@@js.get "params"]
    val set_params: t -> anonymous_interface_72 -> unit [@@js.set "params"]
    val get_maxOutputLength: t -> float [@@js.get "maxOutputLength"]
    val set_maxOutputLength: t -> float -> unit [@@js.set "maxOutputLength"]
  end
  module[@js.scope "Zlib"] Zlib : sig
    type t = zlib_Zlib
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    (** @deprecated Use bytesWritten instead. *)
    val get_bytesRead: t -> float [@@js.get "bytesRead"]
    val get_bytesWritten: t -> float [@@js.get "bytesWritten"]
    val get_shell: t -> bool or_string [@@js.get "shell"]
    val set_shell: t -> bool or_string -> unit [@@js.set "shell"]
    val close: t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "close"]
    val flush: t -> ?kind:float -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "flush"]
    val flush': t -> ?callback:(unit -> unit) -> unit -> unit [@@js.call "flush"]
  end
  module[@js.scope "ZlibParams"] ZlibParams : sig
    type t = zlib_ZlibParams
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val params: t -> level:float -> strategy:float -> callback:(unit -> unit) -> unit [@@js.call "params"]
  end
  module[@js.scope "ZlibReset"] ZlibReset : sig
    type t = zlib_ZlibReset
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val reset: t -> unit [@@js.call "reset"]
  end
  module[@js.scope "BrotliCompress"] BrotliCompress : sig
    type t = zlib_BrotliCompress
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
  end
  module[@js.scope "BrotliDecompress"] BrotliDecompress : sig
    type t = zlib_BrotliDecompress
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
  end
  module[@js.scope "Gzip"] Gzip : sig
    type t = zlib_Gzip
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
  end
  module[@js.scope "Gunzip"] Gunzip : sig
    type t = zlib_Gunzip
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
  end
  module[@js.scope "Deflate"] Deflate : sig
    type t = zlib_Deflate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
    val cast'': t -> zlib_ZlibReset [@@js.cast]
    val cast''': t -> zlib_ZlibParams [@@js.cast]
  end
  module[@js.scope "Inflate"] Inflate : sig
    type t = zlib_Inflate
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
    val cast'': t -> zlib_ZlibReset [@@js.cast]
  end
  module[@js.scope "DeflateRaw"] DeflateRaw : sig
    type t = zlib_DeflateRaw
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
    val cast'': t -> zlib_ZlibReset [@@js.cast]
    val cast''': t -> zlib_ZlibParams [@@js.cast]
  end
  module[@js.scope "InflateRaw"] InflateRaw : sig
    type t = zlib_InflateRaw
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
    val cast'': t -> zlib_ZlibReset [@@js.cast]
  end
  module[@js.scope "Unzip"] Unzip : sig
    type t = zlib_Unzip
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val cast: t -> Stream.Transform.t_0 [@@js.cast]
    val cast': t -> zlib_Zlib [@@js.cast]
  end
  val createBrotliCompress: ?options:zlib_BrotliOptions -> unit -> zlib_BrotliCompress [@@js.global "createBrotliCompress"]
  val createBrotliDecompress: ?options:zlib_BrotliOptions -> unit -> zlib_BrotliDecompress [@@js.global "createBrotliDecompress"]
  val createGzip: ?options:zlib_ZlibOptions -> unit -> zlib_Gzip [@@js.global "createGzip"]
  val createGunzip: ?options:zlib_ZlibOptions -> unit -> zlib_Gunzip [@@js.global "createGunzip"]
  val createDeflate: ?options:zlib_ZlibOptions -> unit -> zlib_Deflate [@@js.global "createDeflate"]
  val createInflate: ?options:zlib_ZlibOptions -> unit -> zlib_Inflate [@@js.global "createInflate"]
  val createDeflateRaw: ?options:zlib_ZlibOptions -> unit -> zlib_DeflateRaw [@@js.global "createDeflateRaw"]
  val createInflateRaw: ?options:zlib_ZlibOptions -> unit -> zlib_InflateRaw [@@js.global "createInflateRaw"]
  val createUnzip: ?options:zlib_ZlibOptions -> unit -> zlib_Unzip [@@js.global "createUnzip"]
  module InputType : sig
    type t = zlib_InputType
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
  end
  module[@js.scope "CompressCallback"] CompressCallback : sig
    type t = zlib_CompressCallback
    val t_to_js: t -> Ojs.t
    val t_of_js: Ojs.t -> t
    type t_0 = t
    val t_0_to_js: t_0 -> Ojs.t
    val t_0_of_js: Ojs.t -> t_0
    val apply: t -> error:Error.t_0 or_null -> result:_Buffer -> unit [@@js.apply]
  end
  val brotliCompress: buf:zlib_InputType -> options:zlib_BrotliOptions -> callback:zlib_CompressCallback -> unit [@@js.global "brotliCompress"]
  val brotliCompress: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "brotliCompress"]
  module[@js.scope "brotliCompress"] BrotliCompress : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_BrotliOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val brotliCompressSync: buf:zlib_InputType -> ?options:zlib_BrotliOptions -> unit -> _Buffer [@@js.global "brotliCompressSync"]
  val brotliDecompress: buf:zlib_InputType -> options:zlib_BrotliOptions -> callback:zlib_CompressCallback -> unit [@@js.global "brotliDecompress"]
  val brotliDecompress: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "brotliDecompress"]
  module[@js.scope "brotliDecompress"] BrotliDecompress : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_BrotliOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val brotliDecompressSync: buf:zlib_InputType -> ?options:zlib_BrotliOptions -> unit -> _Buffer [@@js.global "brotliDecompressSync"]
  val deflate: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "deflate"]
  val deflate: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "deflate"]
  module[@js.scope "deflate"] Deflate : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val deflateSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "deflateSync"]
  val deflateRaw: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "deflateRaw"]
  val deflateRaw: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "deflateRaw"]
  module[@js.scope "deflateRaw"] DeflateRaw : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val deflateRawSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "deflateRawSync"]
  val gzip: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "gzip"]
  val gzip: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "gzip"]
  module[@js.scope "gzip"] Gzip : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val gzipSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "gzipSync"]
  val gunzip: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "gunzip"]
  val gunzip: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "gunzip"]
  module[@js.scope "gunzip"] Gunzip : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val gunzipSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "gunzipSync"]
  val inflate: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "inflate"]
  val inflate: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "inflate"]
  module[@js.scope "inflate"] Inflate : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val inflateSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "inflateSync"]
  val inflateRaw: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "inflateRaw"]
  val inflateRaw: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "inflateRaw"]
  module[@js.scope "inflateRaw"] InflateRaw : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val inflateRawSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "inflateRawSync"]
  val unzip: buf:zlib_InputType -> callback:zlib_CompressCallback -> unit [@@js.global "unzip"]
  val unzip: buf:zlib_InputType -> options:zlib_ZlibOptions -> callback:zlib_CompressCallback -> unit [@@js.global "unzip"]
  module[@js.scope "unzip"] Unzip : sig
    val __promisify__: buffer:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer Promise.t_1 [@@js.global "__promisify__"]
  end
  val unzipSync: buf:zlib_InputType -> ?options:zlib_ZlibOptions -> unit -> _Buffer [@@js.global "unzipSync"]
  module[@js.scope "constants"] Constants : sig
    val brotli_decode: float [@@js.global "BROTLI_DECODE"]
    val brotli_decoder_error_alloc_block_type_trees: float [@@js.global "BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES"]
    val brotli_decoder_error_alloc_context_map: float [@@js.global "BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP"]
    val brotli_decoder_error_alloc_context_modes: float [@@js.global "BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES"]
    val brotli_decoder_error_alloc_ring_buffer_1: float [@@js.global "BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1"]
    val brotli_decoder_error_alloc_ring_buffer_2: float [@@js.global "BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2"]
    val brotli_decoder_error_alloc_tree_groups: float [@@js.global "BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS"]
    val brotli_decoder_error_dictionary_not_set: float [@@js.global "BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET"]
    val brotli_decoder_error_format_block_length_1: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1"]
    val brotli_decoder_error_format_block_length_2: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2"]
    val brotli_decoder_error_format_cl_space: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_CL_SPACE"]
    val brotli_decoder_error_format_context_map_repeat: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT"]
    val brotli_decoder_error_format_dictionary: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_DICTIONARY"]
    val brotli_decoder_error_format_distance: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_DISTANCE"]
    val brotli_decoder_error_format_exuberant_meta_nibble: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE"]
    val brotli_decoder_error_format_exuberant_nibble: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE"]
    val brotli_decoder_error_format_huffman_space: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE"]
    val brotli_decoder_error_format_padding_1: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_PADDING_1"]
    val brotli_decoder_error_format_padding_2: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_PADDING_2"]
    val brotli_decoder_error_format_reserved: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_RESERVED"]
    val brotli_decoder_error_format_simple_huffman_alphabet: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET"]
    val brotli_decoder_error_format_simple_huffman_same: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME"]
    val brotli_decoder_error_format_transform: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_TRANSFORM"]
    val brotli_decoder_error_format_window_bits: float [@@js.global "BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS"]
    val brotli_decoder_error_invalid_arguments: float [@@js.global "BROTLI_DECODER_ERROR_INVALID_ARGUMENTS"]
    val brotli_decoder_error_unreachable: float [@@js.global "BROTLI_DECODER_ERROR_UNREACHABLE"]
    val brotli_decoder_needs_more_input: float [@@js.global "BROTLI_DECODER_NEEDS_MORE_INPUT"]
    val brotli_decoder_needs_more_output: float [@@js.global "BROTLI_DECODER_NEEDS_MORE_OUTPUT"]
    val brotli_decoder_no_error: float [@@js.global "BROTLI_DECODER_NO_ERROR"]
    val brotli_decoder_param_disable_ring_buffer_reallocation: float [@@js.global "BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION"]
    val brotli_decoder_param_large_window: float [@@js.global "BROTLI_DECODER_PARAM_LARGE_WINDOW"]
    val brotli_decoder_result_error: float [@@js.global "BROTLI_DECODER_RESULT_ERROR"]
    val brotli_decoder_result_needs_more_input: float [@@js.global "BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT"]
    val brotli_decoder_result_needs_more_output: float [@@js.global "BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT"]
    val brotli_decoder_result_success: float [@@js.global "BROTLI_DECODER_RESULT_SUCCESS"]
    val brotli_decoder_success: float [@@js.global "BROTLI_DECODER_SUCCESS"]
    val brotli_default_mode: float [@@js.global "BROTLI_DEFAULT_MODE"]
    val brotli_default_quality: float [@@js.global "BROTLI_DEFAULT_QUALITY"]
    val brotli_default_window: float [@@js.global "BROTLI_DEFAULT_WINDOW"]
    val brotli_encode: float [@@js.global "BROTLI_ENCODE"]
    val brotli_large_max_window_bits: float [@@js.global "BROTLI_LARGE_MAX_WINDOW_BITS"]
    val brotli_max_input_block_bits: float [@@js.global "BROTLI_MAX_INPUT_BLOCK_BITS"]
    val brotli_max_quality: float [@@js.global "BROTLI_MAX_QUALITY"]
    val brotli_max_window_bits: float [@@js.global "BROTLI_MAX_WINDOW_BITS"]
    val brotli_min_input_block_bits: float [@@js.global "BROTLI_MIN_INPUT_BLOCK_BITS"]
    val brotli_min_quality: float [@@js.global "BROTLI_MIN_QUALITY"]
    val brotli_min_window_bits: float [@@js.global "BROTLI_MIN_WINDOW_BITS"]
    val brotli_mode_font: float [@@js.global "BROTLI_MODE_FONT"]
    val brotli_mode_generic: float [@@js.global "BROTLI_MODE_GENERIC"]
    val brotli_mode_text: float [@@js.global "BROTLI_MODE_TEXT"]
    val brotli_operation_emit_metadata: float [@@js.global "BROTLI_OPERATION_EMIT_METADATA"]
    val brotli_operation_finish: float [@@js.global "BROTLI_OPERATION_FINISH"]
    val brotli_operation_flush: float [@@js.global "BROTLI_OPERATION_FLUSH"]
    val brotli_operation_process: float [@@js.global "BROTLI_OPERATION_PROCESS"]
    val brotli_param_disable_literal_context_modeling: float [@@js.global "BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING"]
    val brotli_param_large_window: float [@@js.global "BROTLI_PARAM_LARGE_WINDOW"]
    val brotli_param_lgblock: float [@@js.global "BROTLI_PARAM_LGBLOCK"]
    val brotli_param_lgwin: float [@@js.global "BROTLI_PARAM_LGWIN"]
    val brotli_param_mode: float [@@js.global "BROTLI_PARAM_MODE"]
    val brotli_param_ndirect: float [@@js.global "BROTLI_PARAM_NDIRECT"]
    val brotli_param_npostfix: float [@@js.global "BROTLI_PARAM_NPOSTFIX"]
    val brotli_param_quality: float [@@js.global "BROTLI_PARAM_QUALITY"]
    val brotli_param_size_hint: float [@@js.global "BROTLI_PARAM_SIZE_HINT"]
    val deflate: float [@@js.global "DEFLATE"]
    val deflateraw: float [@@js.global "DEFLATERAW"]
    val gunzip: float [@@js.global "GUNZIP"]
    val gzip: float [@@js.global "GZIP"]
    val inflate: float [@@js.global "INFLATE"]
    val inflateraw: float [@@js.global "INFLATERAW"]
    val unzip: float [@@js.global "UNZIP"]
    val z_no_flush: float [@@js.global "Z_NO_FLUSH"]
    val z_partial_flush: float [@@js.global "Z_PARTIAL_FLUSH"]
    val z_sync_flush: float [@@js.global "Z_SYNC_FLUSH"]
    val z_full_flush: float [@@js.global "Z_FULL_FLUSH"]
    val z_finish: float [@@js.global "Z_FINISH"]
    val z_block: float [@@js.global "Z_BLOCK"]
    val z_trees: float [@@js.global "Z_TREES"]
    val z_ok: float [@@js.global "Z_OK"]
    val z_stream_end: float [@@js.global "Z_STREAM_END"]
    val z_need_dict: float [@@js.global "Z_NEED_DICT"]
    val z_errno: float [@@js.global "Z_ERRNO"]
    val z_stream_error: float [@@js.global "Z_STREAM_ERROR"]
    val z_data_error: float [@@js.global "Z_DATA_ERROR"]
    val z_mem_error: float [@@js.global "Z_MEM_ERROR"]
    val z_buf_error: float [@@js.global "Z_BUF_ERROR"]
    val z_version_error: float [@@js.global "Z_VERSION_ERROR"]
    val z_no_compression: float [@@js.global "Z_NO_COMPRESSION"]
    val z_best_speed: float [@@js.global "Z_BEST_SPEED"]
    val z_best_compression: float [@@js.global "Z_BEST_COMPRESSION"]
    val z_default_compression: float [@@js.global "Z_DEFAULT_COMPRESSION"]
    val z_filtered: float [@@js.global "Z_FILTERED"]
    val z_huffman_only: float [@@js.global "Z_HUFFMAN_ONLY"]
    val z_rle: float [@@js.global "Z_RLE"]
    val z_fixed: float [@@js.global "Z_FIXED"]
    val z_default_strategy: float [@@js.global "Z_DEFAULT_STRATEGY"]
    val z_default_windowbits: float [@@js.global "Z_DEFAULT_WINDOWBITS"]
    val z_min_windowbits: float [@@js.global "Z_MIN_WINDOWBITS"]
    val z_max_windowbits: float [@@js.global "Z_MAX_WINDOWBITS"]
    val z_min_chunk: float [@@js.global "Z_MIN_CHUNK"]
    val z_max_chunk: float [@@js.global "Z_MAX_CHUNK"]
    val z_default_chunk: float [@@js.global "Z_DEFAULT_CHUNK"]
    val z_min_memlevel: float [@@js.global "Z_MIN_MEMLEVEL"]
    val z_max_memlevel: float [@@js.global "Z_MAX_MEMLEVEL"]
    val z_default_memlevel: float [@@js.global "Z_DEFAULT_MEMLEVEL"]
    val z_min_level: float [@@js.global "Z_MIN_LEVEL"]
    val z_max_level: float [@@js.global "Z_MAX_LEVEL"]
    val z_default_level: float [@@js.global "Z_DEFAULT_LEVEL"]
    val zlib_vernum: float [@@js.global "ZLIB_VERNUM"]
  end
  (** @deprecated Use `constants.Z_NO_FLUSH` *)
  val z_no_flush: float [@@js.global "Z_NO_FLUSH"]
  (** @deprecated Use `constants.Z_PARTIAL_FLUSH` *)
  val z_partial_flush: float [@@js.global "Z_PARTIAL_FLUSH"]
  (** @deprecated Use `constants.Z_SYNC_FLUSH` *)
  val z_sync_flush: float [@@js.global "Z_SYNC_FLUSH"]
  (** @deprecated Use `constants.Z_FULL_FLUSH` *)
  val z_full_flush: float [@@js.global "Z_FULL_FLUSH"]
  (** @deprecated Use `constants.Z_FINISH` *)
  val z_finish: float [@@js.global "Z_FINISH"]
  (** @deprecated Use `constants.Z_BLOCK` *)
  val z_block: float [@@js.global "Z_BLOCK"]
  (** @deprecated Use `constants.Z_TREES` *)
  val z_trees: float [@@js.global "Z_TREES"]
  (** @deprecated Use `constants.Z_OK` *)
  val z_ok: float [@@js.global "Z_OK"]
  (** @deprecated Use `constants.Z_STREAM_END` *)
  val z_stream_end: float [@@js.global "Z_STREAM_END"]
  (** @deprecated Use `constants.Z_NEED_DICT` *)
  val z_need_dict: float [@@js.global "Z_NEED_DICT"]
  (** @deprecated Use `constants.Z_ERRNO` *)
  val z_errno: float [@@js.global "Z_ERRNO"]
  (** @deprecated Use `constants.Z_STREAM_ERROR` *)
  val z_stream_error: float [@@js.global "Z_STREAM_ERROR"]
  (** @deprecated Use `constants.Z_DATA_ERROR` *)
  val z_data_error: float [@@js.global "Z_DATA_ERROR"]
  (** @deprecated Use `constants.Z_MEM_ERROR` *)
  val z_mem_error: float [@@js.global "Z_MEM_ERROR"]
  (** @deprecated Use `constants.Z_BUF_ERROR` *)
  val z_buf_error: float [@@js.global "Z_BUF_ERROR"]
  (** @deprecated Use `constants.Z_VERSION_ERROR` *)
  val z_version_error: float [@@js.global "Z_VERSION_ERROR"]
  (** @deprecated Use `constants.Z_NO_COMPRESSION` *)
  val z_no_compression: float [@@js.global "Z_NO_COMPRESSION"]
  (** @deprecated Use `constants.Z_BEST_SPEED` *)
  val z_best_speed: float [@@js.global "Z_BEST_SPEED"]
  (** @deprecated Use `constants.Z_BEST_COMPRESSION` *)
  val z_best_compression: float [@@js.global "Z_BEST_COMPRESSION"]
  (** @deprecated Use `constants.Z_DEFAULT_COMPRESSION` *)
  val z_default_compression: float [@@js.global "Z_DEFAULT_COMPRESSION"]
  (** @deprecated Use `constants.Z_FILTERED` *)
  val z_filtered: float [@@js.global "Z_FILTERED"]
  (** @deprecated Use `constants.Z_HUFFMAN_ONLY` *)
  val z_huffman_only: float [@@js.global "Z_HUFFMAN_ONLY"]
  (** @deprecated Use `constants.Z_RLE` *)
  val z_rle: float [@@js.global "Z_RLE"]
  (** @deprecated Use `constants.Z_FIXED` *)
  val z_fixed: float [@@js.global "Z_FIXED"]
  (** @deprecated Use `constants.Z_DEFAULT_STRATEGY` *)
  val z_default_strategy: float [@@js.global "Z_DEFAULT_STRATEGY"]
  (** @deprecated  *)
  val z_binary: float [@@js.global "Z_BINARY"]
  (** @deprecated  *)
  val z_text: float [@@js.global "Z_TEXT"]
  (** @deprecated  *)
  val z_ascii: float [@@js.global "Z_ASCII"]
  (** @deprecated  *)
  val z_unknown: float [@@js.global "Z_UNKNOWN"]
  (** @deprecated  *)
  val z_deflated: float [@@js.global "Z_DEFLATED"]
end
